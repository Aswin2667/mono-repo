
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Stores
 * 
 */
export type Stores = $Result.DefaultSelection<Prisma.$StoresPayload>
/**
 * Model Members
 * 
 */
export type Members = $Result.DefaultSelection<Prisma.$MembersPayload>
/**
 * Model Programs
 * 
 */
export type Programs = $Result.DefaultSelection<Prisma.$ProgramsPayload>
/**
 * Model Tiers
 * 
 */
export type Tiers = $Result.DefaultSelection<Prisma.$TiersPayload>
/**
 * Model CustomerDiscounts
 * 
 */
export type CustomerDiscounts = $Result.DefaultSelection<Prisma.$CustomerDiscountsPayload>
/**
 * Model Orders
 * 
 */
export type Orders = $Result.DefaultSelection<Prisma.$OrdersPayload>
/**
 * Model OrderItems
 * 
 */
export type OrderItems = $Result.DefaultSelection<Prisma.$OrderItemsPayload>
/**
 * Model Commissions
 * 
 */
export type Commissions = $Result.DefaultSelection<Prisma.$CommissionsPayload>
/**
 * Model Payouts
 * 
 */
export type Payouts = $Result.DefaultSelection<Prisma.$PayoutsPayload>
/**
 * Model Bonus
 * 
 */
export type Bonus = $Result.DefaultSelection<Prisma.$BonusPayload>
/**
 * Model Gifts
 * 
 */
export type Gifts = $Result.DefaultSelection<Prisma.$GiftsPayload>
/**
 * Model Transactions
 * 
 */
export type Transactions = $Result.DefaultSelection<Prisma.$TransactionsPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model Jobs
 * 
 */
export type Jobs = $Result.DefaultSelection<Prisma.$JobsPayload>
/**
 * Model Customers
 * 
 */
export type Customers = $Result.DefaultSelection<Prisma.$CustomersPayload>
/**
 * Model Affiliates
 * 
 */
export type Affiliates = $Result.DefaultSelection<Prisma.$AffiliatesPayload>
/**
 * Model AffiliatePrograms
 * 
 */
export type AffiliatePrograms = $Result.DefaultSelection<Prisma.$AffiliateProgramsPayload>
/**
 * Model AffiliateProgramHistory
 * 
 */
export type AffiliateProgramHistory = $Result.DefaultSelection<Prisma.$AffiliateProgramHistoryPayload>
/**
 * Model AffiliateDiscounts
 * 
 */
export type AffiliateDiscounts = $Result.DefaultSelection<Prisma.$AffiliateDiscountsPayload>
/**
 * Model AffiliateGifts
 * 
 */
export type AffiliateGifts = $Result.DefaultSelection<Prisma.$AffiliateGiftsPayload>
/**
 * Model AffiliateBonus
 * 
 */
export type AffiliateBonus = $Result.DefaultSelection<Prisma.$AffiliateBonusPayload>
/**
 * Model ProgramBonus
 * 
 */
export type ProgramBonus = $Result.DefaultSelection<Prisma.$ProgramBonusPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model Notifications
 * 
 */
export type Notifications = $Result.DefaultSelection<Prisma.$NotificationsPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model MessageHistory
 * 
 */
export type MessageHistory = $Result.DefaultSelection<Prisma.$MessageHistoryPayload>
/**
 * Model PaymentGateway
 * 
 */
export type PaymentGateway = $Result.DefaultSelection<Prisma.$PaymentGatewayPayload>
/**
 * Model AppSubscription
 * 
 */
export type AppSubscription = $Result.DefaultSelection<Prisma.$AppSubscriptionPayload>
/**
 * Model Integrations
 * 
 */
export type Integrations = $Result.DefaultSelection<Prisma.$IntegrationsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const StoreStatusType: {
  INSTALLED: 'INSTALLED',
  UNINSTALLED: 'UNINSTALLED',
  STORE_REOPENED: 'STORE_REOPENED',
  STORE_CLOSED: 'STORE_CLOSED'
};

export type StoreStatusType = (typeof StoreStatusType)[keyof typeof StoreStatusType]


export const ProgramStatusType: {
  ACTIVE: 'ACTIVE',
  DRAFT: 'DRAFT',
  ARCHIVED: 'ARCHIVED'
};

export type ProgramStatusType = (typeof ProgramStatusType)[keyof typeof ProgramStatusType]


export const TierType: {
  TOTAL_AMOUNT: 'TOTAL_AMOUNT',
  TOTAL_SALES: 'TOTAL_SALES',
  TOTAL_REFERRALS: 'TOTAL_REFERRALS',
  DEFAULT: 'DEFAULT'
};

export type TierType = (typeof TierType)[keyof typeof TierType]


export const EarningType: {
  FLAT: 'FLAT',
  PERCENTAGE: 'PERCENTAGE'
};

export type EarningType = (typeof EarningType)[keyof typeof EarningType]


export const CustomerDiscountType: {
  FLAT: 'FLAT',
  PERCENTAGE: 'PERCENTAGE',
  FREE_SHIPPING: 'FREE_SHIPPING',
  NO_DISCOUNT: 'NO_DISCOUNT'
};

export type CustomerDiscountType = (typeof CustomerDiscountType)[keyof typeof CustomerDiscountType]


export const OrderAttributeType: {
  REFERRAL_SALE: 'REFERRAL_SALE',
  RECURRING_SALE: 'RECURRING_SALE'
};

export type OrderAttributeType = (typeof OrderAttributeType)[keyof typeof OrderAttributeType]


export const OrderStatusType: {
  SUCCESSFUL: 'SUCCESSFUL',
  UNSUCCESSFUL: 'UNSUCCESSFUL',
  FRAUDULENT: 'FRAUDULENT'
};

export type OrderStatusType = (typeof OrderStatusType)[keyof typeof OrderStatusType]


export const StatusType: {
  APPROVED: 'APPROVED',
  PENDING: 'PENDING',
  REJECTED: 'REJECTED'
};

export type StatusType = (typeof StatusType)[keyof typeof StatusType]


export const ApprovalModeType: {
  MANUAL: 'MANUAL',
  IMMEDIATE: 'IMMEDIATE',
  AUTOMATIC: 'AUTOMATIC'
};

export type ApprovalModeType = (typeof ApprovalModeType)[keyof typeof ApprovalModeType]


export const PaymentType: {
  OFFLINE: 'OFFLINE',
  PAYPAL: 'PAYPAL',
  GIFT_CARD: 'GIFT_CARD',
  COUPON: 'COUPON',
  TREMENDOUS: 'TREMENDOUS'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const BonusType: {
  MEMBERS: 'MEMBERS',
  PROGRAMS: 'PROGRAMS'
};

export type BonusType = (typeof BonusType)[keyof typeof BonusType]


export const GiftType: {
  DISCOUNTED: 'DISCOUNTED',
  FREE: 'FREE'
};

export type GiftType = (typeof GiftType)[keyof typeof GiftType]


export const ShippingType: {
  NOT_INCLUDED: 'NOT_INCLUDED',
  INCLUDED: 'INCLUDED'
};

export type ShippingType = (typeof ShippingType)[keyof typeof ShippingType]


export const TransactionReferenceType: {
  ORDER: 'ORDER',
  PAYOUT: 'PAYOUT'
};

export type TransactionReferenceType = (typeof TransactionReferenceType)[keyof typeof TransactionReferenceType]


export const TransactionType: {
  CREDIT: 'CREDIT',
  DEBIT: 'DEBIT'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const CommissionCalculationType: {
  BOTH: 'BOTH',
  NORMAL: 'NORMAL',
  WITHOUT_TAXES: 'WITHOUT_TAXES',
  WITHOUT_SHIPPING: 'WITHOUT_SHIPPING'
};

export type CommissionCalculationType = (typeof CommissionCalculationType)[keyof typeof CommissionCalculationType]


export const JobsStatusType: {
  CREATED: 'CREATED',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type JobsStatusType = (typeof JobsStatusType)[keyof typeof JobsStatusType]


export const JobType: {
  IMPORT_CSV: 'IMPORT_CSV',
  PAYOUT_PROCESS: 'PAYOUT_PROCESS'
};

export type JobType = (typeof JobType)[keyof typeof JobType]


export const ContactType: {
  BOTH: 'BOTH',
  PHONE: 'PHONE',
  EMAIL: 'EMAIL'
};

export type ContactType = (typeof ContactType)[keyof typeof ContactType]


export const AffiliateStatusType: {
  APPROVED: 'APPROVED',
  PENDING: 'PENDING',
  REJECTED: 'REJECTED',
  ARCHIVED: 'ARCHIVED'
};

export type AffiliateStatusType = (typeof AffiliateStatusType)[keyof typeof AffiliateStatusType]


export const AffiliateSourceType: {
  MANUAL_UPLOAD: 'MANUAL_UPLOAD',
  MANUAL_CREATE: 'MANUAL_CREATE',
  SIGN_UP_FORM: 'SIGN_UP_FORM'
};

export type AffiliateSourceType = (typeof AffiliateSourceType)[keyof typeof AffiliateSourceType]


export const ProgramHistoryStatusType: {
  ADDED: 'ADDED',
  REMOVED: 'REMOVED'
};

export type ProgramHistoryStatusType = (typeof ProgramHistoryStatusType)[keyof typeof ProgramHistoryStatusType]


export const DiscountStatusType: {
  ACTIVATED: 'ACTIVATED',
  DEACTIVATED: 'DEACTIVATED'
};

export type DiscountStatusType = (typeof DiscountStatusType)[keyof typeof DiscountStatusType]


export const NotificationType: {
  AFFILIATE_APPLICATION_RECEIVED: 'AFFILIATE_APPLICATION_RECEIVED',
  AFFILIATE_APPLICATION_APPROVED: 'AFFILIATE_APPLICATION_APPROVED',
  AFFILIATE_APPLICATION_REJECTED: 'AFFILIATE_APPLICATION_REJECTED',
  AFFILIATE_SALE_MADE: 'AFFILIATE_SALE_MADE',
  AFFILIATE_COMMISSION_APPROVED: 'AFFILIATE_COMMISSION_APPROVED',
  AFFILIATE_PAYOUT_REQUEST_RECEIVED: 'AFFILIATE_PAYOUT_REQUEST_RECEIVED',
  AFFILIATE_PAYOUT_PROCESSED: 'AFFILIATE_PAYOUT_PROCESSED'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationReceiverType: {
  AFFILIATE: 'AFFILIATE',
  STORE_OWNER: 'STORE_OWNER'
};

export type NotificationReceiverType = (typeof NotificationReceiverType)[keyof typeof NotificationReceiverType]


export const NotificationStatusType: {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED'
};

export type NotificationStatusType = (typeof NotificationStatusType)[keyof typeof NotificationStatusType]


export const ActivityEntityType: {
  AFFILIATES: 'AFFILIATES',
  STORES: 'STORES',
  PROGRAMS: 'PROGRAMS',
  COMMISSIONS: 'COMMISSIONS',
  DISCOUNTS: 'DISCOUNTS',
  PAYOUTS: 'PAYOUTS',
  ORDERS: 'ORDERS'
};

export type ActivityEntityType = (typeof ActivityEntityType)[keyof typeof ActivityEntityType]


export const MessageHistoryStatusType: {
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED'
};

export type MessageHistoryStatusType = (typeof MessageHistoryStatusType)[keyof typeof MessageHistoryStatusType]


export const AppSubscriptionType: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type AppSubscriptionType = (typeof AppSubscriptionType)[keyof typeof AppSubscriptionType]


export const IntegrationType: {
  KLAVIYO: 'KLAVIYO',
  ZAPIER: 'ZAPIER'
};

export type IntegrationType = (typeof IntegrationType)[keyof typeof IntegrationType]

}

export type StoreStatusType = $Enums.StoreStatusType

export const StoreStatusType: typeof $Enums.StoreStatusType

export type ProgramStatusType = $Enums.ProgramStatusType

export const ProgramStatusType: typeof $Enums.ProgramStatusType

export type TierType = $Enums.TierType

export const TierType: typeof $Enums.TierType

export type EarningType = $Enums.EarningType

export const EarningType: typeof $Enums.EarningType

export type CustomerDiscountType = $Enums.CustomerDiscountType

export const CustomerDiscountType: typeof $Enums.CustomerDiscountType

export type OrderAttributeType = $Enums.OrderAttributeType

export const OrderAttributeType: typeof $Enums.OrderAttributeType

export type OrderStatusType = $Enums.OrderStatusType

export const OrderStatusType: typeof $Enums.OrderStatusType

export type StatusType = $Enums.StatusType

export const StatusType: typeof $Enums.StatusType

export type ApprovalModeType = $Enums.ApprovalModeType

export const ApprovalModeType: typeof $Enums.ApprovalModeType

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type BonusType = $Enums.BonusType

export const BonusType: typeof $Enums.BonusType

export type GiftType = $Enums.GiftType

export const GiftType: typeof $Enums.GiftType

export type ShippingType = $Enums.ShippingType

export const ShippingType: typeof $Enums.ShippingType

export type TransactionReferenceType = $Enums.TransactionReferenceType

export const TransactionReferenceType: typeof $Enums.TransactionReferenceType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type CommissionCalculationType = $Enums.CommissionCalculationType

export const CommissionCalculationType: typeof $Enums.CommissionCalculationType

export type JobsStatusType = $Enums.JobsStatusType

export const JobsStatusType: typeof $Enums.JobsStatusType

export type JobType = $Enums.JobType

export const JobType: typeof $Enums.JobType

export type ContactType = $Enums.ContactType

export const ContactType: typeof $Enums.ContactType

export type AffiliateStatusType = $Enums.AffiliateStatusType

export const AffiliateStatusType: typeof $Enums.AffiliateStatusType

export type AffiliateSourceType = $Enums.AffiliateSourceType

export const AffiliateSourceType: typeof $Enums.AffiliateSourceType

export type ProgramHistoryStatusType = $Enums.ProgramHistoryStatusType

export const ProgramHistoryStatusType: typeof $Enums.ProgramHistoryStatusType

export type DiscountStatusType = $Enums.DiscountStatusType

export const DiscountStatusType: typeof $Enums.DiscountStatusType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationReceiverType = $Enums.NotificationReceiverType

export const NotificationReceiverType: typeof $Enums.NotificationReceiverType

export type NotificationStatusType = $Enums.NotificationStatusType

export const NotificationStatusType: typeof $Enums.NotificationStatusType

export type ActivityEntityType = $Enums.ActivityEntityType

export const ActivityEntityType: typeof $Enums.ActivityEntityType

export type MessageHistoryStatusType = $Enums.MessageHistoryStatusType

export const MessageHistoryStatusType: typeof $Enums.MessageHistoryStatusType

export type AppSubscriptionType = $Enums.AppSubscriptionType

export const AppSubscriptionType: typeof $Enums.AppSubscriptionType

export type IntegrationType = $Enums.IntegrationType

export const IntegrationType: typeof $Enums.IntegrationType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Stores
 * const stores = await prisma.stores.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Stores
   * const stores = await prisma.stores.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.stores`: Exposes CRUD operations for the **Stores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.stores.findMany()
    * ```
    */
  get stores(): Prisma.StoresDelegate<ExtArgs>;

  /**
   * `prisma.members`: Exposes CRUD operations for the **Members** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.members.findMany()
    * ```
    */
  get members(): Prisma.MembersDelegate<ExtArgs>;

  /**
   * `prisma.programs`: Exposes CRUD operations for the **Programs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.programs.findMany()
    * ```
    */
  get programs(): Prisma.ProgramsDelegate<ExtArgs>;

  /**
   * `prisma.tiers`: Exposes CRUD operations for the **Tiers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tiers
    * const tiers = await prisma.tiers.findMany()
    * ```
    */
  get tiers(): Prisma.TiersDelegate<ExtArgs>;

  /**
   * `prisma.customerDiscounts`: Exposes CRUD operations for the **CustomerDiscounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerDiscounts
    * const customerDiscounts = await prisma.customerDiscounts.findMany()
    * ```
    */
  get customerDiscounts(): Prisma.CustomerDiscountsDelegate<ExtArgs>;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **Orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): Prisma.OrdersDelegate<ExtArgs>;

  /**
   * `prisma.orderItems`: Exposes CRUD operations for the **OrderItems** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItems.findMany()
    * ```
    */
  get orderItems(): Prisma.OrderItemsDelegate<ExtArgs>;

  /**
   * `prisma.commissions`: Exposes CRUD operations for the **Commissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Commissions
    * const commissions = await prisma.commissions.findMany()
    * ```
    */
  get commissions(): Prisma.CommissionsDelegate<ExtArgs>;

  /**
   * `prisma.payouts`: Exposes CRUD operations for the **Payouts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payouts
    * const payouts = await prisma.payouts.findMany()
    * ```
    */
  get payouts(): Prisma.PayoutsDelegate<ExtArgs>;

  /**
   * `prisma.bonus`: Exposes CRUD operations for the **Bonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bonuses
    * const bonuses = await prisma.bonus.findMany()
    * ```
    */
  get bonus(): Prisma.BonusDelegate<ExtArgs>;

  /**
   * `prisma.gifts`: Exposes CRUD operations for the **Gifts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Gifts
    * const gifts = await prisma.gifts.findMany()
    * ```
    */
  get gifts(): Prisma.GiftsDelegate<ExtArgs>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **Transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.TransactionsDelegate<ExtArgs>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **Jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.JobsDelegate<ExtArgs>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **Customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): Prisma.CustomersDelegate<ExtArgs>;

  /**
   * `prisma.affiliates`: Exposes CRUD operations for the **Affiliates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Affiliates
    * const affiliates = await prisma.affiliates.findMany()
    * ```
    */
  get affiliates(): Prisma.AffiliatesDelegate<ExtArgs>;

  /**
   * `prisma.affiliatePrograms`: Exposes CRUD operations for the **AffiliatePrograms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliatePrograms
    * const affiliatePrograms = await prisma.affiliatePrograms.findMany()
    * ```
    */
  get affiliatePrograms(): Prisma.AffiliateProgramsDelegate<ExtArgs>;

  /**
   * `prisma.affiliateProgramHistory`: Exposes CRUD operations for the **AffiliateProgramHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateProgramHistories
    * const affiliateProgramHistories = await prisma.affiliateProgramHistory.findMany()
    * ```
    */
  get affiliateProgramHistory(): Prisma.AffiliateProgramHistoryDelegate<ExtArgs>;

  /**
   * `prisma.affiliateDiscounts`: Exposes CRUD operations for the **AffiliateDiscounts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateDiscounts
    * const affiliateDiscounts = await prisma.affiliateDiscounts.findMany()
    * ```
    */
  get affiliateDiscounts(): Prisma.AffiliateDiscountsDelegate<ExtArgs>;

  /**
   * `prisma.affiliateGifts`: Exposes CRUD operations for the **AffiliateGifts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateGifts
    * const affiliateGifts = await prisma.affiliateGifts.findMany()
    * ```
    */
  get affiliateGifts(): Prisma.AffiliateGiftsDelegate<ExtArgs>;

  /**
   * `prisma.affiliateBonus`: Exposes CRUD operations for the **AffiliateBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AffiliateBonuses
    * const affiliateBonuses = await prisma.affiliateBonus.findMany()
    * ```
    */
  get affiliateBonus(): Prisma.AffiliateBonusDelegate<ExtArgs>;

  /**
   * `prisma.programBonus`: Exposes CRUD operations for the **ProgramBonus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramBonuses
    * const programBonuses = await prisma.programBonus.findMany()
    * ```
    */
  get programBonus(): Prisma.ProgramBonusDelegate<ExtArgs>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **Notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.NotificationsDelegate<ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs>;

  /**
   * `prisma.messageHistory`: Exposes CRUD operations for the **MessageHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageHistories
    * const messageHistories = await prisma.messageHistory.findMany()
    * ```
    */
  get messageHistory(): Prisma.MessageHistoryDelegate<ExtArgs>;

  /**
   * `prisma.paymentGateway`: Exposes CRUD operations for the **PaymentGateway** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentGateways
    * const paymentGateways = await prisma.paymentGateway.findMany()
    * ```
    */
  get paymentGateway(): Prisma.PaymentGatewayDelegate<ExtArgs>;

  /**
   * `prisma.appSubscription`: Exposes CRUD operations for the **AppSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppSubscriptions
    * const appSubscriptions = await prisma.appSubscription.findMany()
    * ```
    */
  get appSubscription(): Prisma.AppSubscriptionDelegate<ExtArgs>;

  /**
   * `prisma.integrations`: Exposes CRUD operations for the **Integrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integrations.findMany()
    * ```
    */
  get integrations(): Prisma.IntegrationsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.16.1
   * Query Engine version: 34ace0eb2704183d2c05b60b52fba5c43c13f303
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Stores: 'Stores',
    Members: 'Members',
    Programs: 'Programs',
    Tiers: 'Tiers',
    CustomerDiscounts: 'CustomerDiscounts',
    Orders: 'Orders',
    OrderItems: 'OrderItems',
    Commissions: 'Commissions',
    Payouts: 'Payouts',
    Bonus: 'Bonus',
    Gifts: 'Gifts',
    Transactions: 'Transactions',
    Settings: 'Settings',
    Jobs: 'Jobs',
    Customers: 'Customers',
    Affiliates: 'Affiliates',
    AffiliatePrograms: 'AffiliatePrograms',
    AffiliateProgramHistory: 'AffiliateProgramHistory',
    AffiliateDiscounts: 'AffiliateDiscounts',
    AffiliateGifts: 'AffiliateGifts',
    AffiliateBonus: 'AffiliateBonus',
    ProgramBonus: 'ProgramBonus',
    Otp: 'Otp',
    Notifications: 'Notifications',
    ActivityLog: 'ActivityLog',
    MessageHistory: 'MessageHistory',
    PaymentGateway: 'PaymentGateway',
    AppSubscription: 'AppSubscription',
    Integrations: 'Integrations'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "stores" | "members" | "programs" | "tiers" | "customerDiscounts" | "orders" | "orderItems" | "commissions" | "payouts" | "bonus" | "gifts" | "transactions" | "settings" | "jobs" | "customers" | "affiliates" | "affiliatePrograms" | "affiliateProgramHistory" | "affiliateDiscounts" | "affiliateGifts" | "affiliateBonus" | "programBonus" | "otp" | "notifications" | "activityLog" | "messageHistory" | "paymentGateway" | "appSubscription" | "integrations"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Stores: {
        payload: Prisma.$StoresPayload<ExtArgs>
        fields: Prisma.StoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          findFirst: {
            args: Prisma.StoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          findMany: {
            args: Prisma.StoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>[]
          }
          create: {
            args: Prisma.StoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          createMany: {
            args: Prisma.StoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StoresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>[]
          }
          delete: {
            args: Prisma.StoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          update: {
            args: Prisma.StoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          deleteMany: {
            args: Prisma.StoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          aggregate: {
            args: Prisma.StoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStores>
          }
          groupBy: {
            args: Prisma.StoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoresCountArgs<ExtArgs>
            result: $Utils.Optional<StoresCountAggregateOutputType> | number
          }
        }
      }
      Members: {
        payload: Prisma.$MembersPayload<ExtArgs>
        fields: Prisma.MembersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MembersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MembersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          findFirst: {
            args: Prisma.MembersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MembersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          findMany: {
            args: Prisma.MembersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>[]
          }
          create: {
            args: Prisma.MembersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          createMany: {
            args: Prisma.MembersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MembersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>[]
          }
          delete: {
            args: Prisma.MembersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          update: {
            args: Prisma.MembersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          deleteMany: {
            args: Prisma.MembersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MembersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MembersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MembersPayload>
          }
          aggregate: {
            args: Prisma.MembersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembers>
          }
          groupBy: {
            args: Prisma.MembersGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembersGroupByOutputType>[]
          }
          count: {
            args: Prisma.MembersCountArgs<ExtArgs>
            result: $Utils.Optional<MembersCountAggregateOutputType> | number
          }
        }
      }
      Programs: {
        payload: Prisma.$ProgramsPayload<ExtArgs>
        fields: Prisma.ProgramsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload>
          }
          findFirst: {
            args: Prisma.ProgramsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload>
          }
          findMany: {
            args: Prisma.ProgramsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload>[]
          }
          create: {
            args: Prisma.ProgramsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload>
          }
          createMany: {
            args: Prisma.ProgramsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload>[]
          }
          delete: {
            args: Prisma.ProgramsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload>
          }
          update: {
            args: Prisma.ProgramsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload>
          }
          deleteMany: {
            args: Prisma.ProgramsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramsPayload>
          }
          aggregate: {
            args: Prisma.ProgramsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrograms>
          }
          groupBy: {
            args: Prisma.ProgramsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramsCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramsCountAggregateOutputType> | number
          }
        }
      }
      Tiers: {
        payload: Prisma.$TiersPayload<ExtArgs>
        fields: Prisma.TiersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TiersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TiersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload>
          }
          findFirst: {
            args: Prisma.TiersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TiersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload>
          }
          findMany: {
            args: Prisma.TiersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload>[]
          }
          create: {
            args: Prisma.TiersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload>
          }
          createMany: {
            args: Prisma.TiersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TiersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload>[]
          }
          delete: {
            args: Prisma.TiersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload>
          }
          update: {
            args: Prisma.TiersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload>
          }
          deleteMany: {
            args: Prisma.TiersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TiersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TiersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TiersPayload>
          }
          aggregate: {
            args: Prisma.TiersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTiers>
          }
          groupBy: {
            args: Prisma.TiersGroupByArgs<ExtArgs>
            result: $Utils.Optional<TiersGroupByOutputType>[]
          }
          count: {
            args: Prisma.TiersCountArgs<ExtArgs>
            result: $Utils.Optional<TiersCountAggregateOutputType> | number
          }
        }
      }
      CustomerDiscounts: {
        payload: Prisma.$CustomerDiscountsPayload<ExtArgs>
        fields: Prisma.CustomerDiscountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerDiscountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerDiscountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload>
          }
          findFirst: {
            args: Prisma.CustomerDiscountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerDiscountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload>
          }
          findMany: {
            args: Prisma.CustomerDiscountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload>[]
          }
          create: {
            args: Prisma.CustomerDiscountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload>
          }
          createMany: {
            args: Prisma.CustomerDiscountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerDiscountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload>[]
          }
          delete: {
            args: Prisma.CustomerDiscountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload>
          }
          update: {
            args: Prisma.CustomerDiscountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDiscountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerDiscountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerDiscountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerDiscountsPayload>
          }
          aggregate: {
            args: Prisma.CustomerDiscountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerDiscounts>
          }
          groupBy: {
            args: Prisma.CustomerDiscountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerDiscountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerDiscountsCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerDiscountsCountAggregateOutputType> | number
          }
        }
      }
      Orders: {
        payload: Prisma.$OrdersPayload<ExtArgs>
        fields: Prisma.OrdersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrdersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrdersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findFirst: {
            args: Prisma.OrdersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrdersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          findMany: {
            args: Prisma.OrdersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          create: {
            args: Prisma.OrdersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          createMany: {
            args: Prisma.OrdersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrdersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>[]
          }
          delete: {
            args: Prisma.OrdersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          update: {
            args: Prisma.OrdersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          deleteMany: {
            args: Prisma.OrdersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrdersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrdersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrdersPayload>
          }
          aggregate: {
            args: Prisma.OrdersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrders>
          }
          groupBy: {
            args: Prisma.OrdersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrdersGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrdersCountArgs<ExtArgs>
            result: $Utils.Optional<OrdersCountAggregateOutputType> | number
          }
        }
      }
      OrderItems: {
        payload: Prisma.$OrderItemsPayload<ExtArgs>
        fields: Prisma.OrderItemsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          findFirst: {
            args: Prisma.OrderItemsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          findMany: {
            args: Prisma.OrderItemsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>[]
          }
          create: {
            args: Prisma.OrderItemsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          createMany: {
            args: Prisma.OrderItemsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderItemsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>[]
          }
          delete: {
            args: Prisma.OrderItemsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          update: {
            args: Prisma.OrderItemsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemsPayload>
          }
          aggregate: {
            args: Prisma.OrderItemsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItems>
          }
          groupBy: {
            args: Prisma.OrderItemsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemsGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemsCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemsCountAggregateOutputType> | number
          }
        }
      }
      Commissions: {
        payload: Prisma.$CommissionsPayload<ExtArgs>
        fields: Prisma.CommissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload>
          }
          findFirst: {
            args: Prisma.CommissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload>
          }
          findMany: {
            args: Prisma.CommissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload>[]
          }
          create: {
            args: Prisma.CommissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload>
          }
          createMany: {
            args: Prisma.CommissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommissionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload>[]
          }
          delete: {
            args: Prisma.CommissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload>
          }
          update: {
            args: Prisma.CommissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload>
          }
          deleteMany: {
            args: Prisma.CommissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommissionsPayload>
          }
          aggregate: {
            args: Prisma.CommissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommissions>
          }
          groupBy: {
            args: Prisma.CommissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommissionsCountArgs<ExtArgs>
            result: $Utils.Optional<CommissionsCountAggregateOutputType> | number
          }
        }
      }
      Payouts: {
        payload: Prisma.$PayoutsPayload<ExtArgs>
        fields: Prisma.PayoutsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayoutsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayoutsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload>
          }
          findFirst: {
            args: Prisma.PayoutsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayoutsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload>
          }
          findMany: {
            args: Prisma.PayoutsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload>[]
          }
          create: {
            args: Prisma.PayoutsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload>
          }
          createMany: {
            args: Prisma.PayoutsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayoutsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload>[]
          }
          delete: {
            args: Prisma.PayoutsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload>
          }
          update: {
            args: Prisma.PayoutsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload>
          }
          deleteMany: {
            args: Prisma.PayoutsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayoutsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayoutsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayoutsPayload>
          }
          aggregate: {
            args: Prisma.PayoutsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayouts>
          }
          groupBy: {
            args: Prisma.PayoutsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayoutsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayoutsCountArgs<ExtArgs>
            result: $Utils.Optional<PayoutsCountAggregateOutputType> | number
          }
        }
      }
      Bonus: {
        payload: Prisma.$BonusPayload<ExtArgs>
        fields: Prisma.BonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          findFirst: {
            args: Prisma.BonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          findMany: {
            args: Prisma.BonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>[]
          }
          create: {
            args: Prisma.BonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          createMany: {
            args: Prisma.BonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>[]
          }
          delete: {
            args: Prisma.BonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          update: {
            args: Prisma.BonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          deleteMany: {
            args: Prisma.BonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BonusPayload>
          }
          aggregate: {
            args: Prisma.BonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBonus>
          }
          groupBy: {
            args: Prisma.BonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<BonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.BonusCountArgs<ExtArgs>
            result: $Utils.Optional<BonusCountAggregateOutputType> | number
          }
        }
      }
      Gifts: {
        payload: Prisma.$GiftsPayload<ExtArgs>
        fields: Prisma.GiftsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GiftsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GiftsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload>
          }
          findFirst: {
            args: Prisma.GiftsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GiftsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload>
          }
          findMany: {
            args: Prisma.GiftsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload>[]
          }
          create: {
            args: Prisma.GiftsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload>
          }
          createMany: {
            args: Prisma.GiftsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GiftsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload>[]
          }
          delete: {
            args: Prisma.GiftsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload>
          }
          update: {
            args: Prisma.GiftsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload>
          }
          deleteMany: {
            args: Prisma.GiftsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GiftsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GiftsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GiftsPayload>
          }
          aggregate: {
            args: Prisma.GiftsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGifts>
          }
          groupBy: {
            args: Prisma.GiftsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GiftsGroupByOutputType>[]
          }
          count: {
            args: Prisma.GiftsCountArgs<ExtArgs>
            result: $Utils.Optional<GiftsCountAggregateOutputType> | number
          }
        }
      }
      Transactions: {
        payload: Prisma.$TransactionsPayload<ExtArgs>
        fields: Prisma.TransactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findFirst: {
            args: Prisma.TransactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          findMany: {
            args: Prisma.TransactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          create: {
            args: Prisma.TransactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          createMany: {
            args: Prisma.TransactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>[]
          }
          delete: {
            args: Prisma.TransactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          update: {
            args: Prisma.TransactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          deleteMany: {
            args: Prisma.TransactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.TransactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      Jobs: {
        payload: Prisma.$JobsPayload<ExtArgs>
        fields: Prisma.JobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findFirst: {
            args: Prisma.JobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          findMany: {
            args: Prisma.JobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>[]
          }
          create: {
            args: Prisma.JobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          createMany: {
            args: Prisma.JobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>[]
          }
          delete: {
            args: Prisma.JobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          update: {
            args: Prisma.JobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          deleteMany: {
            args: Prisma.JobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.JobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      Customers: {
        payload: Prisma.$CustomersPayload<ExtArgs>
        fields: Prisma.CustomersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findFirst: {
            args: Prisma.CustomersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          findMany: {
            args: Prisma.CustomersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          create: {
            args: Prisma.CustomersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          createMany: {
            args: Prisma.CustomersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>[]
          }
          delete: {
            args: Prisma.CustomersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          update: {
            args: Prisma.CustomersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          deleteMany: {
            args: Prisma.CustomersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomersPayload>
          }
          aggregate: {
            args: Prisma.CustomersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomers>
          }
          groupBy: {
            args: Prisma.CustomersGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomersGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomersCountArgs<ExtArgs>
            result: $Utils.Optional<CustomersCountAggregateOutputType> | number
          }
        }
      }
      Affiliates: {
        payload: Prisma.$AffiliatesPayload<ExtArgs>
        fields: Prisma.AffiliatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          findFirst: {
            args: Prisma.AffiliatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          findMany: {
            args: Prisma.AffiliatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>[]
          }
          create: {
            args: Prisma.AffiliatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          createMany: {
            args: Prisma.AffiliatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>[]
          }
          delete: {
            args: Prisma.AffiliatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          update: {
            args: Prisma.AffiliatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          deleteMany: {
            args: Prisma.AffiliatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliatesPayload>
          }
          aggregate: {
            args: Prisma.AffiliatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliates>
          }
          groupBy: {
            args: Prisma.AffiliatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliatesCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliatesCountAggregateOutputType> | number
          }
        }
      }
      AffiliatePrograms: {
        payload: Prisma.$AffiliateProgramsPayload<ExtArgs>
        fields: Prisma.AffiliateProgramsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateProgramsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateProgramsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload>
          }
          findFirst: {
            args: Prisma.AffiliateProgramsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateProgramsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload>
          }
          findMany: {
            args: Prisma.AffiliateProgramsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload>[]
          }
          create: {
            args: Prisma.AffiliateProgramsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload>
          }
          createMany: {
            args: Prisma.AffiliateProgramsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateProgramsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload>[]
          }
          delete: {
            args: Prisma.AffiliateProgramsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload>
          }
          update: {
            args: Prisma.AffiliateProgramsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateProgramsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateProgramsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateProgramsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramsPayload>
          }
          aggregate: {
            args: Prisma.AffiliateProgramsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliatePrograms>
          }
          groupBy: {
            args: Prisma.AffiliateProgramsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProgramsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateProgramsCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProgramsCountAggregateOutputType> | number
          }
        }
      }
      AffiliateProgramHistory: {
        payload: Prisma.$AffiliateProgramHistoryPayload<ExtArgs>
        fields: Prisma.AffiliateProgramHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateProgramHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateProgramHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload>
          }
          findFirst: {
            args: Prisma.AffiliateProgramHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateProgramHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload>
          }
          findMany: {
            args: Prisma.AffiliateProgramHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload>[]
          }
          create: {
            args: Prisma.AffiliateProgramHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload>
          }
          createMany: {
            args: Prisma.AffiliateProgramHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateProgramHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload>[]
          }
          delete: {
            args: Prisma.AffiliateProgramHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload>
          }
          update: {
            args: Prisma.AffiliateProgramHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateProgramHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateProgramHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateProgramHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateProgramHistoryPayload>
          }
          aggregate: {
            args: Prisma.AffiliateProgramHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateProgramHistory>
          }
          groupBy: {
            args: Prisma.AffiliateProgramHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProgramHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateProgramHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateProgramHistoryCountAggregateOutputType> | number
          }
        }
      }
      AffiliateDiscounts: {
        payload: Prisma.$AffiliateDiscountsPayload<ExtArgs>
        fields: Prisma.AffiliateDiscountsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateDiscountsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateDiscountsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload>
          }
          findFirst: {
            args: Prisma.AffiliateDiscountsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateDiscountsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload>
          }
          findMany: {
            args: Prisma.AffiliateDiscountsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload>[]
          }
          create: {
            args: Prisma.AffiliateDiscountsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload>
          }
          createMany: {
            args: Prisma.AffiliateDiscountsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateDiscountsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload>[]
          }
          delete: {
            args: Prisma.AffiliateDiscountsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload>
          }
          update: {
            args: Prisma.AffiliateDiscountsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateDiscountsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateDiscountsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateDiscountsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateDiscountsPayload>
          }
          aggregate: {
            args: Prisma.AffiliateDiscountsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateDiscounts>
          }
          groupBy: {
            args: Prisma.AffiliateDiscountsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateDiscountsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateDiscountsCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateDiscountsCountAggregateOutputType> | number
          }
        }
      }
      AffiliateGifts: {
        payload: Prisma.$AffiliateGiftsPayload<ExtArgs>
        fields: Prisma.AffiliateGiftsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateGiftsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateGiftsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload>
          }
          findFirst: {
            args: Prisma.AffiliateGiftsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateGiftsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload>
          }
          findMany: {
            args: Prisma.AffiliateGiftsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload>[]
          }
          create: {
            args: Prisma.AffiliateGiftsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload>
          }
          createMany: {
            args: Prisma.AffiliateGiftsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateGiftsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload>[]
          }
          delete: {
            args: Prisma.AffiliateGiftsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload>
          }
          update: {
            args: Prisma.AffiliateGiftsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateGiftsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateGiftsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateGiftsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateGiftsPayload>
          }
          aggregate: {
            args: Prisma.AffiliateGiftsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateGifts>
          }
          groupBy: {
            args: Prisma.AffiliateGiftsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateGiftsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateGiftsCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateGiftsCountAggregateOutputType> | number
          }
        }
      }
      AffiliateBonus: {
        payload: Prisma.$AffiliateBonusPayload<ExtArgs>
        fields: Prisma.AffiliateBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AffiliateBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AffiliateBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload>
          }
          findFirst: {
            args: Prisma.AffiliateBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AffiliateBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload>
          }
          findMany: {
            args: Prisma.AffiliateBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload>[]
          }
          create: {
            args: Prisma.AffiliateBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload>
          }
          createMany: {
            args: Prisma.AffiliateBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AffiliateBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload>[]
          }
          delete: {
            args: Prisma.AffiliateBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload>
          }
          update: {
            args: Prisma.AffiliateBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload>
          }
          deleteMany: {
            args: Prisma.AffiliateBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AffiliateBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AffiliateBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AffiliateBonusPayload>
          }
          aggregate: {
            args: Prisma.AffiliateBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffiliateBonus>
          }
          groupBy: {
            args: Prisma.AffiliateBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffiliateBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.AffiliateBonusCountArgs<ExtArgs>
            result: $Utils.Optional<AffiliateBonusCountAggregateOutputType> | number
          }
        }
      }
      ProgramBonus: {
        payload: Prisma.$ProgramBonusPayload<ExtArgs>
        fields: Prisma.ProgramBonusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramBonusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramBonusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload>
          }
          findFirst: {
            args: Prisma.ProgramBonusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramBonusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload>
          }
          findMany: {
            args: Prisma.ProgramBonusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload>[]
          }
          create: {
            args: Prisma.ProgramBonusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload>
          }
          createMany: {
            args: Prisma.ProgramBonusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramBonusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload>[]
          }
          delete: {
            args: Prisma.ProgramBonusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload>
          }
          update: {
            args: Prisma.ProgramBonusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload>
          }
          deleteMany: {
            args: Prisma.ProgramBonusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramBonusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramBonusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramBonusPayload>
          }
          aggregate: {
            args: Prisma.ProgramBonusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramBonus>
          }
          groupBy: {
            args: Prisma.ProgramBonusGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramBonusGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramBonusCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramBonusCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      Notifications: {
        payload: Prisma.$NotificationsPayload<ExtArgs>
        fields: Prisma.NotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findFirst: {
            args: Prisma.NotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          findMany: {
            args: Prisma.NotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          create: {
            args: Prisma.NotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          createMany: {
            args: Prisma.NotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>[]
          }
          delete: {
            args: Prisma.NotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          update: {
            args: Prisma.NotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          deleteMany: {
            args: Prisma.NotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.NotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      MessageHistory: {
        payload: Prisma.$MessageHistoryPayload<ExtArgs>
        fields: Prisma.MessageHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload>
          }
          findFirst: {
            args: Prisma.MessageHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload>
          }
          findMany: {
            args: Prisma.MessageHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload>[]
          }
          create: {
            args: Prisma.MessageHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload>
          }
          createMany: {
            args: Prisma.MessageHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload>[]
          }
          delete: {
            args: Prisma.MessageHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload>
          }
          update: {
            args: Prisma.MessageHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload>
          }
          deleteMany: {
            args: Prisma.MessageHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MessageHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageHistoryPayload>
          }
          aggregate: {
            args: Prisma.MessageHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageHistory>
          }
          groupBy: {
            args: Prisma.MessageHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<MessageHistoryCountAggregateOutputType> | number
          }
        }
      }
      PaymentGateway: {
        payload: Prisma.$PaymentGatewayPayload<ExtArgs>
        fields: Prisma.PaymentGatewayFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentGatewayFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentGatewayFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload>
          }
          findFirst: {
            args: Prisma.PaymentGatewayFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentGatewayFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload>
          }
          findMany: {
            args: Prisma.PaymentGatewayFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload>[]
          }
          create: {
            args: Prisma.PaymentGatewayCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload>
          }
          createMany: {
            args: Prisma.PaymentGatewayCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentGatewayCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload>[]
          }
          delete: {
            args: Prisma.PaymentGatewayDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload>
          }
          update: {
            args: Prisma.PaymentGatewayUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload>
          }
          deleteMany: {
            args: Prisma.PaymentGatewayDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentGatewayUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentGatewayUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentGatewayPayload>
          }
          aggregate: {
            args: Prisma.PaymentGatewayAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentGateway>
          }
          groupBy: {
            args: Prisma.PaymentGatewayGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGatewayGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentGatewayCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentGatewayCountAggregateOutputType> | number
          }
        }
      }
      AppSubscription: {
        payload: Prisma.$AppSubscriptionPayload<ExtArgs>
        fields: Prisma.AppSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.AppSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload>
          }
          findMany: {
            args: Prisma.AppSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload>[]
          }
          create: {
            args: Prisma.AppSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload>
          }
          createMany: {
            args: Prisma.AppSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.AppSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload>
          }
          update: {
            args: Prisma.AppSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.AppSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.AppSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppSubscription>
          }
          groupBy: {
            args: Prisma.AppSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<AppSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Integrations: {
        payload: Prisma.$IntegrationsPayload<ExtArgs>
        fields: Prisma.IntegrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload>
          }
          findFirst: {
            args: Prisma.IntegrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload>
          }
          findMany: {
            args: Prisma.IntegrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload>[]
          }
          create: {
            args: Prisma.IntegrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload>
          }
          createMany: {
            args: Prisma.IntegrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload>[]
          }
          delete: {
            args: Prisma.IntegrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload>
          }
          update: {
            args: Prisma.IntegrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IntegrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationsPayload>
          }
          aggregate: {
            args: Prisma.IntegrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegrations>
          }
          groupBy: {
            args: Prisma.IntegrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationsCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StoresCountOutputType
   */

  export type StoresCountOutputType = {
    activity_log: number
    affiliate_bonus: number
    affiliate_discounts: number
    affiliate_gifts: number
    affiliate_program_history: number
    affiliate_programs: number
    affiliates: number
    bonus: number
    commissions: number
    customer_discounts: number
    customers: number
    gifts: number
    Integrations: number
    jobs: number
    messageHistory: number
    notifications: number
    orderItems: number
    orders: number
    PaymentGateway: number
    payouts: number
    program_bonus: number
    programs: number
    tiers: number
    transactions: number
  }

  export type StoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_log?: boolean | StoresCountOutputTypeCountActivity_logArgs
    affiliate_bonus?: boolean | StoresCountOutputTypeCountAffiliate_bonusArgs
    affiliate_discounts?: boolean | StoresCountOutputTypeCountAffiliate_discountsArgs
    affiliate_gifts?: boolean | StoresCountOutputTypeCountAffiliate_giftsArgs
    affiliate_program_history?: boolean | StoresCountOutputTypeCountAffiliate_program_historyArgs
    affiliate_programs?: boolean | StoresCountOutputTypeCountAffiliate_programsArgs
    affiliates?: boolean | StoresCountOutputTypeCountAffiliatesArgs
    bonus?: boolean | StoresCountOutputTypeCountBonusArgs
    commissions?: boolean | StoresCountOutputTypeCountCommissionsArgs
    customer_discounts?: boolean | StoresCountOutputTypeCountCustomer_discountsArgs
    customers?: boolean | StoresCountOutputTypeCountCustomersArgs
    gifts?: boolean | StoresCountOutputTypeCountGiftsArgs
    Integrations?: boolean | StoresCountOutputTypeCountIntegrationsArgs
    jobs?: boolean | StoresCountOutputTypeCountJobsArgs
    messageHistory?: boolean | StoresCountOutputTypeCountMessageHistoryArgs
    notifications?: boolean | StoresCountOutputTypeCountNotificationsArgs
    orderItems?: boolean | StoresCountOutputTypeCountOrderItemsArgs
    orders?: boolean | StoresCountOutputTypeCountOrdersArgs
    PaymentGateway?: boolean | StoresCountOutputTypeCountPaymentGatewayArgs
    payouts?: boolean | StoresCountOutputTypeCountPayoutsArgs
    program_bonus?: boolean | StoresCountOutputTypeCountProgram_bonusArgs
    programs?: boolean | StoresCountOutputTypeCountProgramsArgs
    tiers?: boolean | StoresCountOutputTypeCountTiersArgs
    transactions?: boolean | StoresCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoresCountOutputType
     */
    select?: StoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountActivity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountAffiliate_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateBonusWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountAffiliate_discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateDiscountsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountAffiliate_giftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateGiftsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountAffiliate_program_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProgramHistoryWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountAffiliate_programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProgramsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountAffiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliatesWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountBonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountCustomer_discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDiscountsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountGiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountMessageHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageHistoryWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountPaymentGatewayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentGatewayWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountProgram_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramBonusWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramsWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TiersWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }


  /**
   * Count Type MembersCountOutputType
   */

  export type MembersCountOutputType = {
    affiliates: number
  }

  export type MembersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | MembersCountOutputTypeCountAffiliatesArgs
  }

  // Custom InputTypes
  /**
   * MembersCountOutputType without action
   */
  export type MembersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembersCountOutputType
     */
    select?: MembersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MembersCountOutputType without action
   */
  export type MembersCountOutputTypeCountAffiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliatesWhereInput
  }


  /**
   * Count Type ProgramsCountOutputType
   */

  export type ProgramsCountOutputType = {
    affiliate_programs: number
    Orders: number
    program_bonus: number
    tiers: number
    activity_log: number
  }

  export type ProgramsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_programs?: boolean | ProgramsCountOutputTypeCountAffiliate_programsArgs
    Orders?: boolean | ProgramsCountOutputTypeCountOrdersArgs
    program_bonus?: boolean | ProgramsCountOutputTypeCountProgram_bonusArgs
    tiers?: boolean | ProgramsCountOutputTypeCountTiersArgs
    activity_log?: boolean | ProgramsCountOutputTypeCountActivity_logArgs
  }

  // Custom InputTypes
  /**
   * ProgramsCountOutputType without action
   */
  export type ProgramsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramsCountOutputType
     */
    select?: ProgramsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramsCountOutputType without action
   */
  export type ProgramsCountOutputTypeCountAffiliate_programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProgramsWhereInput
  }

  /**
   * ProgramsCountOutputType without action
   */
  export type ProgramsCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }

  /**
   * ProgramsCountOutputType without action
   */
  export type ProgramsCountOutputTypeCountProgram_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramBonusWhereInput
  }

  /**
   * ProgramsCountOutputType without action
   */
  export type ProgramsCountOutputTypeCountTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TiersWhereInput
  }

  /**
   * ProgramsCountOutputType without action
   */
  export type ProgramsCountOutputTypeCountActivity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Count Type OrdersCountOutputType
   */

  export type OrdersCountOutputType = {
    order_items: number
    activity_log: number
  }

  export type OrdersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_items?: boolean | OrdersCountOutputTypeCountOrder_itemsArgs
    activity_log?: boolean | OrdersCountOutputTypeCountActivity_logArgs
  }

  // Custom InputTypes
  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrdersCountOutputType
     */
    select?: OrdersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountOrder_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
  }

  /**
   * OrdersCountOutputType without action
   */
  export type OrdersCountOutputTypeCountActivity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Count Type PayoutsCountOutputType
   */

  export type PayoutsCountOutputType = {
    activity_log: number
  }

  export type PayoutsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_log?: boolean | PayoutsCountOutputTypeCountActivity_logArgs
  }

  // Custom InputTypes
  /**
   * PayoutsCountOutputType without action
   */
  export type PayoutsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayoutsCountOutputType
     */
    select?: PayoutsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayoutsCountOutputType without action
   */
  export type PayoutsCountOutputTypeCountActivity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Count Type BonusCountOutputType
   */

  export type BonusCountOutputType = {
    affiliate_bonus: number
    program_bonus: number
  }

  export type BonusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_bonus?: boolean | BonusCountOutputTypeCountAffiliate_bonusArgs
    program_bonus?: boolean | BonusCountOutputTypeCountProgram_bonusArgs
  }

  // Custom InputTypes
  /**
   * BonusCountOutputType without action
   */
  export type BonusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BonusCountOutputType
     */
    select?: BonusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BonusCountOutputType without action
   */
  export type BonusCountOutputTypeCountAffiliate_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateBonusWhereInput
  }

  /**
   * BonusCountOutputType without action
   */
  export type BonusCountOutputTypeCountProgram_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramBonusWhereInput
  }


  /**
   * Count Type GiftsCountOutputType
   */

  export type GiftsCountOutputType = {
    affiliate_gifts: number
  }

  export type GiftsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_gifts?: boolean | GiftsCountOutputTypeCountAffiliate_giftsArgs
  }

  // Custom InputTypes
  /**
   * GiftsCountOutputType without action
   */
  export type GiftsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GiftsCountOutputType
     */
    select?: GiftsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GiftsCountOutputType without action
   */
  export type GiftsCountOutputTypeCountAffiliate_giftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateGiftsWhereInput
  }


  /**
   * Count Type CustomersCountOutputType
   */

  export type CustomersCountOutputType = {
    order_items: number
    orders: number
  }

  export type CustomersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order_items?: boolean | CustomersCountOutputTypeCountOrder_itemsArgs
    orders?: boolean | CustomersCountOutputTypeCountOrdersArgs
  }

  // Custom InputTypes
  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomersCountOutputType
     */
    select?: CustomersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountOrder_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
  }

  /**
   * CustomersCountOutputType without action
   */
  export type CustomersCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }


  /**
   * Count Type AffiliatesCountOutputType
   */

  export type AffiliatesCountOutputType = {
    affiliate_bonus: number
    affiliate_discounts: number
    affiliate_gifts: number
    affiliate_program_history: number
    affiliate_programs: number
    commissions: number
    customers: number
    order_items: number
    orders: number
    payouts: number
    transactions: number
    activity_log: number
  }

  export type AffiliatesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_bonus?: boolean | AffiliatesCountOutputTypeCountAffiliate_bonusArgs
    affiliate_discounts?: boolean | AffiliatesCountOutputTypeCountAffiliate_discountsArgs
    affiliate_gifts?: boolean | AffiliatesCountOutputTypeCountAffiliate_giftsArgs
    affiliate_program_history?: boolean | AffiliatesCountOutputTypeCountAffiliate_program_historyArgs
    affiliate_programs?: boolean | AffiliatesCountOutputTypeCountAffiliate_programsArgs
    commissions?: boolean | AffiliatesCountOutputTypeCountCommissionsArgs
    customers?: boolean | AffiliatesCountOutputTypeCountCustomersArgs
    order_items?: boolean | AffiliatesCountOutputTypeCountOrder_itemsArgs
    orders?: boolean | AffiliatesCountOutputTypeCountOrdersArgs
    payouts?: boolean | AffiliatesCountOutputTypeCountPayoutsArgs
    transactions?: boolean | AffiliatesCountOutputTypeCountTransactionsArgs
    activity_log?: boolean | AffiliatesCountOutputTypeCountActivity_logArgs
  }

  // Custom InputTypes
  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatesCountOutputType
     */
    select?: AffiliatesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountAffiliate_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateBonusWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountAffiliate_discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateDiscountsWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountAffiliate_giftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateGiftsWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountAffiliate_program_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProgramHistoryWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountAffiliate_programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProgramsWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountCommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionsWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountOrder_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutsWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
  }

  /**
   * AffiliatesCountOutputType without action
   */
  export type AffiliatesCountOutputTypeCountActivity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Stores
   */

  export type AggregateStores = {
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  export type StoresAvgAggregateOutputType = {
    id: number | null
    created_at: number | null
    updated_at: number | null
    shopify_store_id: number | null
    landing_page_id: number | null
    portal_page_id: number | null
  }

  export type StoresSumAggregateOutputType = {
    id: number | null
    created_at: bigint | null
    updated_at: bigint | null
    shopify_store_id: bigint | null
    landing_page_id: bigint | null
    portal_page_id: bigint | null
  }

  export type StoresMinAggregateOutputType = {
    id: number | null
    store_id: string | null
    domain: string | null
    myshopify_domain: string | null
    email: string | null
    blacklisted: boolean | null
    currency_code: string | null
    country_code: string | null
    language: string | null
    status: $Enums.StoreStatusType | null
    admin_access_token: string | null
    storefront_access_token: string | null
    created_at: bigint | null
    updated_at: bigint | null
    shopify_store_id: bigint | null
    landing_page_id: bigint | null
    portal_page_id: bigint | null
    contact_email: string | null
    contact_name: string | null
    contact_phone: string | null
    webhook_registration_check: boolean | null
  }

  export type StoresMaxAggregateOutputType = {
    id: number | null
    store_id: string | null
    domain: string | null
    myshopify_domain: string | null
    email: string | null
    blacklisted: boolean | null
    currency_code: string | null
    country_code: string | null
    language: string | null
    status: $Enums.StoreStatusType | null
    admin_access_token: string | null
    storefront_access_token: string | null
    created_at: bigint | null
    updated_at: bigint | null
    shopify_store_id: bigint | null
    landing_page_id: bigint | null
    portal_page_id: bigint | null
    contact_email: string | null
    contact_name: string | null
    contact_phone: string | null
    webhook_registration_check: boolean | null
  }

  export type StoresCountAggregateOutputType = {
    id: number
    store_id: number
    domain: number
    myshopify_domain: number
    email: number
    blacklisted: number
    currency_code: number
    country_code: number
    language: number
    status: number
    store_details: number
    remote_details: number
    admin_access_token: number
    storefront_access_token: number
    created_at: number
    updated_at: number
    shopify_store_id: number
    landing_page_id: number
    portal_page_id: number
    contact_email: number
    contact_name: number
    contact_phone: number
    webhook_registration_check: number
    _all: number
  }


  export type StoresAvgAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    shopify_store_id?: true
    landing_page_id?: true
    portal_page_id?: true
  }

  export type StoresSumAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    shopify_store_id?: true
    landing_page_id?: true
    portal_page_id?: true
  }

  export type StoresMinAggregateInputType = {
    id?: true
    store_id?: true
    domain?: true
    myshopify_domain?: true
    email?: true
    blacklisted?: true
    currency_code?: true
    country_code?: true
    language?: true
    status?: true
    admin_access_token?: true
    storefront_access_token?: true
    created_at?: true
    updated_at?: true
    shopify_store_id?: true
    landing_page_id?: true
    portal_page_id?: true
    contact_email?: true
    contact_name?: true
    contact_phone?: true
    webhook_registration_check?: true
  }

  export type StoresMaxAggregateInputType = {
    id?: true
    store_id?: true
    domain?: true
    myshopify_domain?: true
    email?: true
    blacklisted?: true
    currency_code?: true
    country_code?: true
    language?: true
    status?: true
    admin_access_token?: true
    storefront_access_token?: true
    created_at?: true
    updated_at?: true
    shopify_store_id?: true
    landing_page_id?: true
    portal_page_id?: true
    contact_email?: true
    contact_name?: true
    contact_phone?: true
    webhook_registration_check?: true
  }

  export type StoresCountAggregateInputType = {
    id?: true
    store_id?: true
    domain?: true
    myshopify_domain?: true
    email?: true
    blacklisted?: true
    currency_code?: true
    country_code?: true
    language?: true
    status?: true
    store_details?: true
    remote_details?: true
    admin_access_token?: true
    storefront_access_token?: true
    created_at?: true
    updated_at?: true
    shopify_store_id?: true
    landing_page_id?: true
    portal_page_id?: true
    contact_email?: true
    contact_name?: true
    contact_phone?: true
    webhook_registration_check?: true
    _all?: true
  }

  export type StoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to aggregate.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoresMaxAggregateInputType
  }

  export type GetStoresAggregateType<T extends StoresAggregateArgs> = {
        [P in keyof T & keyof AggregateStores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStores[P]>
      : GetScalarType<T[P], AggregateStores[P]>
  }




  export type StoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoresWhereInput
    orderBy?: StoresOrderByWithAggregationInput | StoresOrderByWithAggregationInput[]
    by: StoresScalarFieldEnum[] | StoresScalarFieldEnum
    having?: StoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoresCountAggregateInputType | true
    _avg?: StoresAvgAggregateInputType
    _sum?: StoresSumAggregateInputType
    _min?: StoresMinAggregateInputType
    _max?: StoresMaxAggregateInputType
  }

  export type StoresGroupByOutputType = {
    id: number
    store_id: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonValue
    remote_details: JsonValue | null
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint
    updated_at: bigint
    shopify_store_id: bigint | null
    landing_page_id: bigint | null
    portal_page_id: bigint | null
    contact_email: string
    contact_name: string
    contact_phone: string | null
    webhook_registration_check: boolean | null
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  type GetStoresGroupByPayload<T extends StoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoresGroupByOutputType[P]>
            : GetScalarType<T[P], StoresGroupByOutputType[P]>
        }
      >
    >


  export type StoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    domain?: boolean
    myshopify_domain?: boolean
    email?: boolean
    blacklisted?: boolean
    currency_code?: boolean
    country_code?: boolean
    language?: boolean
    status?: boolean
    store_details?: boolean
    remote_details?: boolean
    admin_access_token?: boolean
    storefront_access_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    shopify_store_id?: boolean
    landing_page_id?: boolean
    portal_page_id?: boolean
    contact_email?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    webhook_registration_check?: boolean
    activity_log?: boolean | Stores$activity_logArgs<ExtArgs>
    affiliate_bonus?: boolean | Stores$affiliate_bonusArgs<ExtArgs>
    affiliate_discounts?: boolean | Stores$affiliate_discountsArgs<ExtArgs>
    affiliate_gifts?: boolean | Stores$affiliate_giftsArgs<ExtArgs>
    affiliate_program_history?: boolean | Stores$affiliate_program_historyArgs<ExtArgs>
    affiliate_programs?: boolean | Stores$affiliate_programsArgs<ExtArgs>
    affiliates?: boolean | Stores$affiliatesArgs<ExtArgs>
    AppSubscription?: boolean | Stores$AppSubscriptionArgs<ExtArgs>
    bonus?: boolean | Stores$bonusArgs<ExtArgs>
    commissions?: boolean | Stores$commissionsArgs<ExtArgs>
    customer_discounts?: boolean | Stores$customer_discountsArgs<ExtArgs>
    customers?: boolean | Stores$customersArgs<ExtArgs>
    gifts?: boolean | Stores$giftsArgs<ExtArgs>
    Integrations?: boolean | Stores$IntegrationsArgs<ExtArgs>
    jobs?: boolean | Stores$jobsArgs<ExtArgs>
    messageHistory?: boolean | Stores$messageHistoryArgs<ExtArgs>
    notifications?: boolean | Stores$notificationsArgs<ExtArgs>
    orderItems?: boolean | Stores$orderItemsArgs<ExtArgs>
    orders?: boolean | Stores$ordersArgs<ExtArgs>
    PaymentGateway?: boolean | Stores$PaymentGatewayArgs<ExtArgs>
    payouts?: boolean | Stores$payoutsArgs<ExtArgs>
    program_bonus?: boolean | Stores$program_bonusArgs<ExtArgs>
    programs?: boolean | Stores$programsArgs<ExtArgs>
    settings?: boolean | Stores$settingsArgs<ExtArgs>
    tiers?: boolean | Stores$tiersArgs<ExtArgs>
    transactions?: boolean | Stores$transactionsArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stores"]>

  export type StoresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    domain?: boolean
    myshopify_domain?: boolean
    email?: boolean
    blacklisted?: boolean
    currency_code?: boolean
    country_code?: boolean
    language?: boolean
    status?: boolean
    store_details?: boolean
    remote_details?: boolean
    admin_access_token?: boolean
    storefront_access_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    shopify_store_id?: boolean
    landing_page_id?: boolean
    portal_page_id?: boolean
    contact_email?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    webhook_registration_check?: boolean
  }, ExtArgs["result"]["stores"]>

  export type StoresSelectScalar = {
    id?: boolean
    store_id?: boolean
    domain?: boolean
    myshopify_domain?: boolean
    email?: boolean
    blacklisted?: boolean
    currency_code?: boolean
    country_code?: boolean
    language?: boolean
    status?: boolean
    store_details?: boolean
    remote_details?: boolean
    admin_access_token?: boolean
    storefront_access_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    shopify_store_id?: boolean
    landing_page_id?: boolean
    portal_page_id?: boolean
    contact_email?: boolean
    contact_name?: boolean
    contact_phone?: boolean
    webhook_registration_check?: boolean
  }

  export type StoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_log?: boolean | Stores$activity_logArgs<ExtArgs>
    affiliate_bonus?: boolean | Stores$affiliate_bonusArgs<ExtArgs>
    affiliate_discounts?: boolean | Stores$affiliate_discountsArgs<ExtArgs>
    affiliate_gifts?: boolean | Stores$affiliate_giftsArgs<ExtArgs>
    affiliate_program_history?: boolean | Stores$affiliate_program_historyArgs<ExtArgs>
    affiliate_programs?: boolean | Stores$affiliate_programsArgs<ExtArgs>
    affiliates?: boolean | Stores$affiliatesArgs<ExtArgs>
    AppSubscription?: boolean | Stores$AppSubscriptionArgs<ExtArgs>
    bonus?: boolean | Stores$bonusArgs<ExtArgs>
    commissions?: boolean | Stores$commissionsArgs<ExtArgs>
    customer_discounts?: boolean | Stores$customer_discountsArgs<ExtArgs>
    customers?: boolean | Stores$customersArgs<ExtArgs>
    gifts?: boolean | Stores$giftsArgs<ExtArgs>
    Integrations?: boolean | Stores$IntegrationsArgs<ExtArgs>
    jobs?: boolean | Stores$jobsArgs<ExtArgs>
    messageHistory?: boolean | Stores$messageHistoryArgs<ExtArgs>
    notifications?: boolean | Stores$notificationsArgs<ExtArgs>
    orderItems?: boolean | Stores$orderItemsArgs<ExtArgs>
    orders?: boolean | Stores$ordersArgs<ExtArgs>
    PaymentGateway?: boolean | Stores$PaymentGatewayArgs<ExtArgs>
    payouts?: boolean | Stores$payoutsArgs<ExtArgs>
    program_bonus?: boolean | Stores$program_bonusArgs<ExtArgs>
    programs?: boolean | Stores$programsArgs<ExtArgs>
    settings?: boolean | Stores$settingsArgs<ExtArgs>
    tiers?: boolean | Stores$tiersArgs<ExtArgs>
    transactions?: boolean | Stores$transactionsArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StoresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stores"
    objects: {
      activity_log: Prisma.$ActivityLogPayload<ExtArgs>[]
      affiliate_bonus: Prisma.$AffiliateBonusPayload<ExtArgs>[]
      affiliate_discounts: Prisma.$AffiliateDiscountsPayload<ExtArgs>[]
      affiliate_gifts: Prisma.$AffiliateGiftsPayload<ExtArgs>[]
      affiliate_program_history: Prisma.$AffiliateProgramHistoryPayload<ExtArgs>[]
      affiliate_programs: Prisma.$AffiliateProgramsPayload<ExtArgs>[]
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>[]
      AppSubscription: Prisma.$AppSubscriptionPayload<ExtArgs> | null
      bonus: Prisma.$BonusPayload<ExtArgs>[]
      commissions: Prisma.$CommissionsPayload<ExtArgs>[]
      customer_discounts: Prisma.$CustomerDiscountsPayload<ExtArgs>[]
      customers: Prisma.$CustomersPayload<ExtArgs>[]
      gifts: Prisma.$GiftsPayload<ExtArgs>[]
      Integrations: Prisma.$IntegrationsPayload<ExtArgs>[]
      jobs: Prisma.$JobsPayload<ExtArgs>[]
      messageHistory: Prisma.$MessageHistoryPayload<ExtArgs>[]
      notifications: Prisma.$NotificationsPayload<ExtArgs>[]
      orderItems: Prisma.$OrderItemsPayload<ExtArgs>[]
      orders: Prisma.$OrdersPayload<ExtArgs>[]
      PaymentGateway: Prisma.$PaymentGatewayPayload<ExtArgs>[]
      payouts: Prisma.$PayoutsPayload<ExtArgs>[]
      program_bonus: Prisma.$ProgramBonusPayload<ExtArgs>[]
      programs: Prisma.$ProgramsPayload<ExtArgs>[]
      settings: Prisma.$SettingsPayload<ExtArgs> | null
      tiers: Prisma.$TiersPayload<ExtArgs>[]
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: string
      domain: string
      myshopify_domain: string
      email: string
      blacklisted: boolean
      currency_code: string
      country_code: string
      language: string
      status: $Enums.StoreStatusType
      store_details: Prisma.JsonValue
      remote_details: Prisma.JsonValue | null
      admin_access_token: string
      storefront_access_token: string
      created_at: bigint
      updated_at: bigint
      shopify_store_id: bigint | null
      landing_page_id: bigint | null
      portal_page_id: bigint | null
      contact_email: string
      contact_name: string
      contact_phone: string | null
      webhook_registration_check: boolean | null
    }, ExtArgs["result"]["stores"]>
    composites: {}
  }

  type StoresGetPayload<S extends boolean | null | undefined | StoresDefaultArgs> = $Result.GetResult<Prisma.$StoresPayload, S>

  type StoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoresFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoresCountAggregateInputType | true
    }

  export interface StoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stores'], meta: { name: 'Stores' } }
    /**
     * Find zero or one Stores that matches the filter.
     * @param {StoresFindUniqueArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoresFindUniqueArgs>(args: SelectSubset<T, StoresFindUniqueArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stores that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoresFindUniqueOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoresFindUniqueOrThrowArgs>(args: SelectSubset<T, StoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindFirstArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoresFindFirstArgs>(args?: SelectSubset<T, StoresFindFirstArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindFirstOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoresFindFirstOrThrowArgs>(args?: SelectSubset<T, StoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.stores.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.stores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storesWithIdOnly = await prisma.stores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoresFindManyArgs>(args?: SelectSubset<T, StoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stores.
     * @param {StoresCreateArgs} args - Arguments to create a Stores.
     * @example
     * // Create one Stores
     * const Stores = await prisma.stores.create({
     *   data: {
     *     // ... data to create a Stores
     *   }
     * })
     * 
     */
    create<T extends StoresCreateArgs>(args: SelectSubset<T, StoresCreateArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stores.
     * @param {StoresCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const stores = await prisma.stores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoresCreateManyArgs>(args?: SelectSubset<T, StoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stores and returns the data saved in the database.
     * @param {StoresCreateManyAndReturnArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const stores = await prisma.stores.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stores and only return the `id`
     * const storesWithIdOnly = await prisma.stores.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StoresCreateManyAndReturnArgs>(args?: SelectSubset<T, StoresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Stores.
     * @param {StoresDeleteArgs} args - Arguments to delete one Stores.
     * @example
     * // Delete one Stores
     * const Stores = await prisma.stores.delete({
     *   where: {
     *     // ... filter to delete one Stores
     *   }
     * })
     * 
     */
    delete<T extends StoresDeleteArgs>(args: SelectSubset<T, StoresDeleteArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stores.
     * @param {StoresUpdateArgs} args - Arguments to update one Stores.
     * @example
     * // Update one Stores
     * const stores = await prisma.stores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoresUpdateArgs>(args: SelectSubset<T, StoresUpdateArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stores.
     * @param {StoresDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.stores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoresDeleteManyArgs>(args?: SelectSubset<T, StoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const stores = await prisma.stores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoresUpdateManyArgs>(args: SelectSubset<T, StoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stores.
     * @param {StoresUpsertArgs} args - Arguments to update or create a Stores.
     * @example
     * // Update or create a Stores
     * const stores = await prisma.stores.upsert({
     *   create: {
     *     // ... data to create a Stores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stores we want to update
     *   }
     * })
     */
    upsert<T extends StoresUpsertArgs>(args: SelectSubset<T, StoresUpsertArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.stores.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoresCountArgs>(
      args?: Subset<T, StoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoresAggregateArgs>(args: Subset<T, StoresAggregateArgs>): Prisma.PrismaPromise<GetStoresAggregateType<T>>

    /**
     * Group by Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoresGroupByArgs['orderBy'] }
        : { orderBy?: StoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stores model
   */
  readonly fields: StoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity_log<T extends Stores$activity_logArgs<ExtArgs> = {}>(args?: Subset<T, Stores$activity_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_bonus<T extends Stores$affiliate_bonusArgs<ExtArgs> = {}>(args?: Subset<T, Stores$affiliate_bonusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_discounts<T extends Stores$affiliate_discountsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$affiliate_discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_gifts<T extends Stores$affiliate_giftsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$affiliate_giftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_program_history<T extends Stores$affiliate_program_historyArgs<ExtArgs> = {}>(args?: Subset<T, Stores$affiliate_program_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_programs<T extends Stores$affiliate_programsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$affiliate_programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "findMany"> | Null>
    affiliates<T extends Stores$affiliatesArgs<ExtArgs> = {}>(args?: Subset<T, Stores$affiliatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findMany"> | Null>
    AppSubscription<T extends Stores$AppSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, Stores$AppSubscriptionArgs<ExtArgs>>): Prisma__AppSubscriptionClient<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    bonus<T extends Stores$bonusArgs<ExtArgs> = {}>(args?: Subset<T, Stores$bonusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findMany"> | Null>
    commissions<T extends Stores$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "findMany"> | Null>
    customer_discounts<T extends Stores$customer_discountsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$customer_discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "findMany"> | Null>
    customers<T extends Stores$customersArgs<ExtArgs> = {}>(args?: Subset<T, Stores$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany"> | Null>
    gifts<T extends Stores$giftsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$giftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "findMany"> | Null>
    Integrations<T extends Stores$IntegrationsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$IntegrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "findMany"> | Null>
    jobs<T extends Stores$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany"> | Null>
    messageHistory<T extends Stores$messageHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Stores$messageHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Stores$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany"> | Null>
    orderItems<T extends Stores$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Stores$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Stores$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany"> | Null>
    PaymentGateway<T extends Stores$PaymentGatewayArgs<ExtArgs> = {}>(args?: Subset<T, Stores$PaymentGatewayArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "findMany"> | Null>
    payouts<T extends Stores$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "findMany"> | Null>
    program_bonus<T extends Stores$program_bonusArgs<ExtArgs> = {}>(args?: Subset<T, Stores$program_bonusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "findMany"> | Null>
    programs<T extends Stores$programsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findMany"> | Null>
    settings<T extends Stores$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$settingsArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tiers<T extends Stores$tiersArgs<ExtArgs> = {}>(args?: Subset<T, Stores$tiersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Stores$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Stores$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stores model
   */ 
  interface StoresFieldRefs {
    readonly id: FieldRef<"Stores", 'Int'>
    readonly store_id: FieldRef<"Stores", 'String'>
    readonly domain: FieldRef<"Stores", 'String'>
    readonly myshopify_domain: FieldRef<"Stores", 'String'>
    readonly email: FieldRef<"Stores", 'String'>
    readonly blacklisted: FieldRef<"Stores", 'Boolean'>
    readonly currency_code: FieldRef<"Stores", 'String'>
    readonly country_code: FieldRef<"Stores", 'String'>
    readonly language: FieldRef<"Stores", 'String'>
    readonly status: FieldRef<"Stores", 'StoreStatusType'>
    readonly store_details: FieldRef<"Stores", 'Json'>
    readonly remote_details: FieldRef<"Stores", 'Json'>
    readonly admin_access_token: FieldRef<"Stores", 'String'>
    readonly storefront_access_token: FieldRef<"Stores", 'String'>
    readonly created_at: FieldRef<"Stores", 'BigInt'>
    readonly updated_at: FieldRef<"Stores", 'BigInt'>
    readonly shopify_store_id: FieldRef<"Stores", 'BigInt'>
    readonly landing_page_id: FieldRef<"Stores", 'BigInt'>
    readonly portal_page_id: FieldRef<"Stores", 'BigInt'>
    readonly contact_email: FieldRef<"Stores", 'String'>
    readonly contact_name: FieldRef<"Stores", 'String'>
    readonly contact_phone: FieldRef<"Stores", 'String'>
    readonly webhook_registration_check: FieldRef<"Stores", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Stores findUnique
   */
  export type StoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores findUniqueOrThrow
   */
  export type StoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores findFirst
   */
  export type StoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores findFirstOrThrow
   */
  export type StoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores findMany
   */
  export type StoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores create
   */
  export type StoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The data needed to create a Stores.
     */
    data: XOR<StoresCreateInput, StoresUncheckedCreateInput>
  }

  /**
   * Stores createMany
   */
  export type StoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoresCreateManyInput | StoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stores createManyAndReturn
   */
  export type StoresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stores.
     */
    data: StoresCreateManyInput | StoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stores update
   */
  export type StoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The data needed to update a Stores.
     */
    data: XOR<StoresUpdateInput, StoresUncheckedUpdateInput>
    /**
     * Choose, which Stores to update.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores updateMany
   */
  export type StoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoresUpdateManyMutationInput, StoresUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoresWhereInput
  }

  /**
   * Stores upsert
   */
  export type StoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The filter to search for the Stores to update in case it exists.
     */
    where: StoresWhereUniqueInput
    /**
     * In case the Stores found by the `where` argument doesn't exist, create a new Stores with this data.
     */
    create: XOR<StoresCreateInput, StoresUncheckedCreateInput>
    /**
     * In case the Stores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoresUpdateInput, StoresUncheckedUpdateInput>
  }

  /**
   * Stores delete
   */
  export type StoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter which Stores to delete.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores deleteMany
   */
  export type StoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoresWhereInput
  }

  /**
   * Stores.activity_log
   */
  export type Stores$activity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Stores.affiliate_bonus
   */
  export type Stores$affiliate_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    where?: AffiliateBonusWhereInput
    orderBy?: AffiliateBonusOrderByWithRelationInput | AffiliateBonusOrderByWithRelationInput[]
    cursor?: AffiliateBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateBonusScalarFieldEnum | AffiliateBonusScalarFieldEnum[]
  }

  /**
   * Stores.affiliate_discounts
   */
  export type Stores$affiliate_discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    where?: AffiliateDiscountsWhereInput
    orderBy?: AffiliateDiscountsOrderByWithRelationInput | AffiliateDiscountsOrderByWithRelationInput[]
    cursor?: AffiliateDiscountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateDiscountsScalarFieldEnum | AffiliateDiscountsScalarFieldEnum[]
  }

  /**
   * Stores.affiliate_gifts
   */
  export type Stores$affiliate_giftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    where?: AffiliateGiftsWhereInput
    orderBy?: AffiliateGiftsOrderByWithRelationInput | AffiliateGiftsOrderByWithRelationInput[]
    cursor?: AffiliateGiftsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateGiftsScalarFieldEnum | AffiliateGiftsScalarFieldEnum[]
  }

  /**
   * Stores.affiliate_program_history
   */
  export type Stores$affiliate_program_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    where?: AffiliateProgramHistoryWhereInput
    orderBy?: AffiliateProgramHistoryOrderByWithRelationInput | AffiliateProgramHistoryOrderByWithRelationInput[]
    cursor?: AffiliateProgramHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateProgramHistoryScalarFieldEnum | AffiliateProgramHistoryScalarFieldEnum[]
  }

  /**
   * Stores.affiliate_programs
   */
  export type Stores$affiliate_programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    where?: AffiliateProgramsWhereInput
    orderBy?: AffiliateProgramsOrderByWithRelationInput | AffiliateProgramsOrderByWithRelationInput[]
    cursor?: AffiliateProgramsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateProgramsScalarFieldEnum | AffiliateProgramsScalarFieldEnum[]
  }

  /**
   * Stores.affiliates
   */
  export type Stores$affiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    where?: AffiliatesWhereInput
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    cursor?: AffiliatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliatesScalarFieldEnum | AffiliatesScalarFieldEnum[]
  }

  /**
   * Stores.AppSubscription
   */
  export type Stores$AppSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    where?: AppSubscriptionWhereInput
  }

  /**
   * Stores.bonus
   */
  export type Stores$bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    where?: BonusWhereInput
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    cursor?: BonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Stores.commissions
   */
  export type Stores$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    where?: CommissionsWhereInput
    orderBy?: CommissionsOrderByWithRelationInput | CommissionsOrderByWithRelationInput[]
    cursor?: CommissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionsScalarFieldEnum | CommissionsScalarFieldEnum[]
  }

  /**
   * Stores.customer_discounts
   */
  export type Stores$customer_discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    where?: CustomerDiscountsWhereInput
    orderBy?: CustomerDiscountsOrderByWithRelationInput | CustomerDiscountsOrderByWithRelationInput[]
    cursor?: CustomerDiscountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerDiscountsScalarFieldEnum | CustomerDiscountsScalarFieldEnum[]
  }

  /**
   * Stores.customers
   */
  export type Stores$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    cursor?: CustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Stores.gifts
   */
  export type Stores$giftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    where?: GiftsWhereInput
    orderBy?: GiftsOrderByWithRelationInput | GiftsOrderByWithRelationInput[]
    cursor?: GiftsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GiftsScalarFieldEnum | GiftsScalarFieldEnum[]
  }

  /**
   * Stores.Integrations
   */
  export type Stores$IntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    where?: IntegrationsWhereInput
    orderBy?: IntegrationsOrderByWithRelationInput | IntegrationsOrderByWithRelationInput[]
    cursor?: IntegrationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationsScalarFieldEnum | IntegrationsScalarFieldEnum[]
  }

  /**
   * Stores.jobs
   */
  export type Stores$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    cursor?: JobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Stores.messageHistory
   */
  export type Stores$messageHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    where?: MessageHistoryWhereInput
    orderBy?: MessageHistoryOrderByWithRelationInput | MessageHistoryOrderByWithRelationInput[]
    cursor?: MessageHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageHistoryScalarFieldEnum | MessageHistoryScalarFieldEnum[]
  }

  /**
   * Stores.notifications
   */
  export type Stores$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    cursor?: NotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Stores.orderItems
   */
  export type Stores$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    cursor?: OrderItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * Stores.orders
   */
  export type Stores$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Stores.PaymentGateway
   */
  export type Stores$PaymentGatewayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    where?: PaymentGatewayWhereInput
    orderBy?: PaymentGatewayOrderByWithRelationInput | PaymentGatewayOrderByWithRelationInput[]
    cursor?: PaymentGatewayWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentGatewayScalarFieldEnum | PaymentGatewayScalarFieldEnum[]
  }

  /**
   * Stores.payouts
   */
  export type Stores$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    where?: PayoutsWhereInput
    orderBy?: PayoutsOrderByWithRelationInput | PayoutsOrderByWithRelationInput[]
    cursor?: PayoutsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayoutsScalarFieldEnum | PayoutsScalarFieldEnum[]
  }

  /**
   * Stores.program_bonus
   */
  export type Stores$program_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    where?: ProgramBonusWhereInput
    orderBy?: ProgramBonusOrderByWithRelationInput | ProgramBonusOrderByWithRelationInput[]
    cursor?: ProgramBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramBonusScalarFieldEnum | ProgramBonusScalarFieldEnum[]
  }

  /**
   * Stores.programs
   */
  export type Stores$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    where?: ProgramsWhereInput
    orderBy?: ProgramsOrderByWithRelationInput | ProgramsOrderByWithRelationInput[]
    cursor?: ProgramsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramsScalarFieldEnum | ProgramsScalarFieldEnum[]
  }

  /**
   * Stores.settings
   */
  export type Stores$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    where?: SettingsWhereInput
  }

  /**
   * Stores.tiers
   */
  export type Stores$tiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    where?: TiersWhereInput
    orderBy?: TiersOrderByWithRelationInput | TiersOrderByWithRelationInput[]
    cursor?: TiersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TiersScalarFieldEnum | TiersScalarFieldEnum[]
  }

  /**
   * Stores.transactions
   */
  export type Stores$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Stores without action
   */
  export type StoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
  }


  /**
   * Model Members
   */

  export type AggregateMembers = {
    _count: MembersCountAggregateOutputType | null
    _avg: MembersAvgAggregateOutputType | null
    _sum: MembersSumAggregateOutputType | null
    _min: MembersMinAggregateOutputType | null
    _max: MembersMaxAggregateOutputType | null
  }

  export type MembersAvgAggregateOutputType = {
    id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type MembersSumAggregateOutputType = {
    id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type MembersMinAggregateOutputType = {
    id: number | null
    member_id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone: string | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type MembersMaxAggregateOutputType = {
    id: number | null
    member_id: string | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone: string | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type MembersCountAggregateOutputType = {
    id: number
    member_id: number
    first_name: number
    last_name: number
    email: number
    phone: number
    member_details: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MembersAvgAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type MembersSumAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type MembersMinAggregateInputType = {
    id?: true
    member_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type MembersMaxAggregateInputType = {
    id?: true
    member_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type MembersCountAggregateInputType = {
    id?: true
    member_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone?: true
    member_details?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MembersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to aggregate.
     */
    where?: MembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Members
    **/
    _count?: true | MembersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembersMaxAggregateInputType
  }

  export type GetMembersAggregateType<T extends MembersAggregateArgs> = {
        [P in keyof T & keyof AggregateMembers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembers[P]>
      : GetScalarType<T[P], AggregateMembers[P]>
  }




  export type MembersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MembersWhereInput
    orderBy?: MembersOrderByWithAggregationInput | MembersOrderByWithAggregationInput[]
    by: MembersScalarFieldEnum[] | MembersScalarFieldEnum
    having?: MembersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembersCountAggregateInputType | true
    _avg?: MembersAvgAggregateInputType
    _sum?: MembersSumAggregateInputType
    _min?: MembersMinAggregateInputType
    _max?: MembersMaxAggregateInputType
  }

  export type MembersGroupByOutputType = {
    id: number
    member_id: string
    first_name: string
    last_name: string
    email: string
    phone: string | null
    member_details: JsonValue
    created_at: bigint
    updated_at: bigint
    _count: MembersCountAggregateOutputType | null
    _avg: MembersAvgAggregateOutputType | null
    _sum: MembersSumAggregateOutputType | null
    _min: MembersMinAggregateOutputType | null
    _max: MembersMaxAggregateOutputType | null
  }

  type GetMembersGroupByPayload<T extends MembersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembersGroupByOutputType[P]>
            : GetScalarType<T[P], MembersGroupByOutputType[P]>
        }
      >
    >


  export type MembersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    member_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    member_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | Members$affiliatesArgs<ExtArgs>
    _count?: boolean | MembersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["members"]>

  export type MembersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    member_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    member_details?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["members"]>

  export type MembersSelectScalar = {
    id?: boolean
    member_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone?: boolean
    member_details?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MembersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | Members$affiliatesArgs<ExtArgs>
    _count?: boolean | MembersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MembersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MembersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Members"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      member_id: string
      first_name: string
      last_name: string
      email: string
      phone: string | null
      member_details: Prisma.JsonValue
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["members"]>
    composites: {}
  }

  type MembersGetPayload<S extends boolean | null | undefined | MembersDefaultArgs> = $Result.GetResult<Prisma.$MembersPayload, S>

  type MembersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MembersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MembersCountAggregateInputType | true
    }

  export interface MembersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Members'], meta: { name: 'Members' } }
    /**
     * Find zero or one Members that matches the filter.
     * @param {MembersFindUniqueArgs} args - Arguments to find a Members
     * @example
     * // Get one Members
     * const members = await prisma.members.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MembersFindUniqueArgs>(args: SelectSubset<T, MembersFindUniqueArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Members that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MembersFindUniqueOrThrowArgs} args - Arguments to find a Members
     * @example
     * // Get one Members
     * const members = await prisma.members.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MembersFindUniqueOrThrowArgs>(args: SelectSubset<T, MembersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersFindFirstArgs} args - Arguments to find a Members
     * @example
     * // Get one Members
     * const members = await prisma.members.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MembersFindFirstArgs>(args?: SelectSubset<T, MembersFindFirstArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Members that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersFindFirstOrThrowArgs} args - Arguments to find a Members
     * @example
     * // Get one Members
     * const members = await prisma.members.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MembersFindFirstOrThrowArgs>(args?: SelectSubset<T, MembersFindFirstOrThrowArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.members.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.members.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membersWithIdOnly = await prisma.members.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MembersFindManyArgs>(args?: SelectSubset<T, MembersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Members.
     * @param {MembersCreateArgs} args - Arguments to create a Members.
     * @example
     * // Create one Members
     * const Members = await prisma.members.create({
     *   data: {
     *     // ... data to create a Members
     *   }
     * })
     * 
     */
    create<T extends MembersCreateArgs>(args: SelectSubset<T, MembersCreateArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Members.
     * @param {MembersCreateManyArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const members = await prisma.members.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MembersCreateManyArgs>(args?: SelectSubset<T, MembersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Members and returns the data saved in the database.
     * @param {MembersCreateManyAndReturnArgs} args - Arguments to create many Members.
     * @example
     * // Create many Members
     * const members = await prisma.members.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Members and only return the `id`
     * const membersWithIdOnly = await prisma.members.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MembersCreateManyAndReturnArgs>(args?: SelectSubset<T, MembersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Members.
     * @param {MembersDeleteArgs} args - Arguments to delete one Members.
     * @example
     * // Delete one Members
     * const Members = await prisma.members.delete({
     *   where: {
     *     // ... filter to delete one Members
     *   }
     * })
     * 
     */
    delete<T extends MembersDeleteArgs>(args: SelectSubset<T, MembersDeleteArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Members.
     * @param {MembersUpdateArgs} args - Arguments to update one Members.
     * @example
     * // Update one Members
     * const members = await prisma.members.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MembersUpdateArgs>(args: SelectSubset<T, MembersUpdateArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Members.
     * @param {MembersDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.members.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MembersDeleteManyArgs>(args?: SelectSubset<T, MembersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const members = await prisma.members.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MembersUpdateManyArgs>(args: SelectSubset<T, MembersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Members.
     * @param {MembersUpsertArgs} args - Arguments to update or create a Members.
     * @example
     * // Update or create a Members
     * const members = await prisma.members.upsert({
     *   create: {
     *     // ... data to create a Members
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Members we want to update
     *   }
     * })
     */
    upsert<T extends MembersUpsertArgs>(args: SelectSubset<T, MembersUpsertArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.members.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends MembersCountArgs>(
      args?: Subset<T, MembersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembersAggregateArgs>(args: Subset<T, MembersAggregateArgs>): Prisma.PrismaPromise<GetMembersAggregateType<T>>

    /**
     * Group by Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MembersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MembersGroupByArgs['orderBy'] }
        : { orderBy?: MembersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MembersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Members model
   */
  readonly fields: MembersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Members.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MembersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends Members$affiliatesArgs<ExtArgs> = {}>(args?: Subset<T, Members$affiliatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Members model
   */ 
  interface MembersFieldRefs {
    readonly id: FieldRef<"Members", 'Int'>
    readonly member_id: FieldRef<"Members", 'String'>
    readonly first_name: FieldRef<"Members", 'String'>
    readonly last_name: FieldRef<"Members", 'String'>
    readonly email: FieldRef<"Members", 'String'>
    readonly phone: FieldRef<"Members", 'String'>
    readonly member_details: FieldRef<"Members", 'Json'>
    readonly created_at: FieldRef<"Members", 'BigInt'>
    readonly updated_at: FieldRef<"Members", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Members findUnique
   */
  export type MembersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where: MembersWhereUniqueInput
  }

  /**
   * Members findUniqueOrThrow
   */
  export type MembersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where: MembersWhereUniqueInput
  }

  /**
   * Members findFirst
   */
  export type MembersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MembersScalarFieldEnum | MembersScalarFieldEnum[]
  }

  /**
   * Members findFirstOrThrow
   */
  export type MembersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Members.
     */
    cursor?: MembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Members.
     */
    distinct?: MembersScalarFieldEnum | MembersScalarFieldEnum[]
  }

  /**
   * Members findMany
   */
  export type MembersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter, which Members to fetch.
     */
    where?: MembersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Members to fetch.
     */
    orderBy?: MembersOrderByWithRelationInput | MembersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Members.
     */
    cursor?: MembersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Members.
     */
    skip?: number
    distinct?: MembersScalarFieldEnum | MembersScalarFieldEnum[]
  }

  /**
   * Members create
   */
  export type MembersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * The data needed to create a Members.
     */
    data: XOR<MembersCreateInput, MembersUncheckedCreateInput>
  }

  /**
   * Members createMany
   */
  export type MembersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Members.
     */
    data: MembersCreateManyInput | MembersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Members createManyAndReturn
   */
  export type MembersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Members.
     */
    data: MembersCreateManyInput | MembersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Members update
   */
  export type MembersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * The data needed to update a Members.
     */
    data: XOR<MembersUpdateInput, MembersUncheckedUpdateInput>
    /**
     * Choose, which Members to update.
     */
    where: MembersWhereUniqueInput
  }

  /**
   * Members updateMany
   */
  export type MembersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Members.
     */
    data: XOR<MembersUpdateManyMutationInput, MembersUncheckedUpdateManyInput>
    /**
     * Filter which Members to update
     */
    where?: MembersWhereInput
  }

  /**
   * Members upsert
   */
  export type MembersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * The filter to search for the Members to update in case it exists.
     */
    where: MembersWhereUniqueInput
    /**
     * In case the Members found by the `where` argument doesn't exist, create a new Members with this data.
     */
    create: XOR<MembersCreateInput, MembersUncheckedCreateInput>
    /**
     * In case the Members was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MembersUpdateInput, MembersUncheckedUpdateInput>
  }

  /**
   * Members delete
   */
  export type MembersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
    /**
     * Filter which Members to delete.
     */
    where: MembersWhereUniqueInput
  }

  /**
   * Members deleteMany
   */
  export type MembersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Members to delete
     */
    where?: MembersWhereInput
  }

  /**
   * Members.affiliates
   */
  export type Members$affiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    where?: AffiliatesWhereInput
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    cursor?: AffiliatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliatesScalarFieldEnum | AffiliatesScalarFieldEnum[]
  }

  /**
   * Members without action
   */
  export type MembersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Members
     */
    select?: MembersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MembersInclude<ExtArgs> | null
  }


  /**
   * Model Programs
   */

  export type AggregatePrograms = {
    _count: ProgramsCountAggregateOutputType | null
    _avg: ProgramsAvgAggregateOutputType | null
    _sum: ProgramsSumAggregateOutputType | null
    _min: ProgramsMinAggregateOutputType | null
    _max: ProgramsMaxAggregateOutputType | null
  }

  export type ProgramsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type ProgramsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type ProgramsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    title: string | null
    description: string | null
    currency_code: string | null
    status: $Enums.ProgramStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type ProgramsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    title: string | null
    description: string | null
    currency_code: string | null
    status: $Enums.ProgramStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type ProgramsCountAggregateOutputType = {
    id: number
    store_id: number
    title: number
    description: number
    currency_code: number
    program_details: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProgramsAvgAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProgramsSumAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProgramsMinAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    currency_code?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ProgramsMaxAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    currency_code?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type ProgramsCountAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    currency_code?: true
    program_details?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProgramsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to aggregate.
     */
    where?: ProgramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramsOrderByWithRelationInput | ProgramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramsMaxAggregateInputType
  }

  export type GetProgramsAggregateType<T extends ProgramsAggregateArgs> = {
        [P in keyof T & keyof AggregatePrograms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrograms[P]>
      : GetScalarType<T[P], AggregatePrograms[P]>
  }




  export type ProgramsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramsWhereInput
    orderBy?: ProgramsOrderByWithAggregationInput | ProgramsOrderByWithAggregationInput[]
    by: ProgramsScalarFieldEnum[] | ProgramsScalarFieldEnum
    having?: ProgramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramsCountAggregateInputType | true
    _avg?: ProgramsAvgAggregateInputType
    _sum?: ProgramsSumAggregateInputType
    _min?: ProgramsMinAggregateInputType
    _max?: ProgramsMaxAggregateInputType
  }

  export type ProgramsGroupByOutputType = {
    id: number
    store_id: number
    title: string
    description: string
    currency_code: string
    program_details: JsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint
    updated_at: bigint
    _count: ProgramsCountAggregateOutputType | null
    _avg: ProgramsAvgAggregateOutputType | null
    _sum: ProgramsSumAggregateOutputType | null
    _min: ProgramsMinAggregateOutputType | null
    _max: ProgramsMaxAggregateOutputType | null
  }

  type GetProgramsGroupByPayload<T extends ProgramsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramsGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramsGroupByOutputType[P]>
        }
      >
    >


  export type ProgramsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    currency_code?: boolean
    program_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate_programs?: boolean | Programs$affiliate_programsArgs<ExtArgs>
    customer_discounts?: boolean | Programs$customer_discountsArgs<ExtArgs>
    Orders?: boolean | Programs$OrdersArgs<ExtArgs>
    program_bonus?: boolean | Programs$program_bonusArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    tiers?: boolean | Programs$tiersArgs<ExtArgs>
    activity_log?: boolean | Programs$activity_logArgs<ExtArgs>
    _count?: boolean | ProgramsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programs"]>

  export type ProgramsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    currency_code?: boolean
    program_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programs"]>

  export type ProgramsSelectScalar = {
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    currency_code?: boolean
    program_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProgramsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_programs?: boolean | Programs$affiliate_programsArgs<ExtArgs>
    customer_discounts?: boolean | Programs$customer_discountsArgs<ExtArgs>
    Orders?: boolean | Programs$OrdersArgs<ExtArgs>
    program_bonus?: boolean | Programs$program_bonusArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    tiers?: boolean | Programs$tiersArgs<ExtArgs>
    activity_log?: boolean | Programs$activity_logArgs<ExtArgs>
    _count?: boolean | ProgramsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $ProgramsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Programs"
    objects: {
      affiliate_programs: Prisma.$AffiliateProgramsPayload<ExtArgs>[]
      customer_discounts: Prisma.$CustomerDiscountsPayload<ExtArgs> | null
      Orders: Prisma.$OrdersPayload<ExtArgs>[]
      program_bonus: Prisma.$ProgramBonusPayload<ExtArgs>[]
      stores: Prisma.$StoresPayload<ExtArgs>
      tiers: Prisma.$TiersPayload<ExtArgs>[]
      activity_log: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      title: string
      description: string
      currency_code: string
      program_details: Prisma.JsonValue
      status: $Enums.ProgramStatusType
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["programs"]>
    composites: {}
  }

  type ProgramsGetPayload<S extends boolean | null | undefined | ProgramsDefaultArgs> = $Result.GetResult<Prisma.$ProgramsPayload, S>

  type ProgramsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramsCountAggregateInputType | true
    }

  export interface ProgramsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Programs'], meta: { name: 'Programs' } }
    /**
     * Find zero or one Programs that matches the filter.
     * @param {ProgramsFindUniqueArgs} args - Arguments to find a Programs
     * @example
     * // Get one Programs
     * const programs = await prisma.programs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramsFindUniqueArgs>(args: SelectSubset<T, ProgramsFindUniqueArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Programs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramsFindUniqueOrThrowArgs} args - Arguments to find a Programs
     * @example
     * // Get one Programs
     * const programs = await prisma.programs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramsFindFirstArgs} args - Arguments to find a Programs
     * @example
     * // Get one Programs
     * const programs = await prisma.programs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramsFindFirstArgs>(args?: SelectSubset<T, ProgramsFindFirstArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Programs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramsFindFirstOrThrowArgs} args - Arguments to find a Programs
     * @example
     * // Get one Programs
     * const programs = await prisma.programs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.programs.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.programs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programsWithIdOnly = await prisma.programs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramsFindManyArgs>(args?: SelectSubset<T, ProgramsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Programs.
     * @param {ProgramsCreateArgs} args - Arguments to create a Programs.
     * @example
     * // Create one Programs
     * const Programs = await prisma.programs.create({
     *   data: {
     *     // ... data to create a Programs
     *   }
     * })
     * 
     */
    create<T extends ProgramsCreateArgs>(args: SelectSubset<T, ProgramsCreateArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Programs.
     * @param {ProgramsCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const programs = await prisma.programs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramsCreateManyArgs>(args?: SelectSubset<T, ProgramsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramsCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const programs = await prisma.programs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programsWithIdOnly = await prisma.programs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Programs.
     * @param {ProgramsDeleteArgs} args - Arguments to delete one Programs.
     * @example
     * // Delete one Programs
     * const Programs = await prisma.programs.delete({
     *   where: {
     *     // ... filter to delete one Programs
     *   }
     * })
     * 
     */
    delete<T extends ProgramsDeleteArgs>(args: SelectSubset<T, ProgramsDeleteArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Programs.
     * @param {ProgramsUpdateArgs} args - Arguments to update one Programs.
     * @example
     * // Update one Programs
     * const programs = await prisma.programs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramsUpdateArgs>(args: SelectSubset<T, ProgramsUpdateArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Programs.
     * @param {ProgramsDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.programs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramsDeleteManyArgs>(args?: SelectSubset<T, ProgramsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const programs = await prisma.programs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramsUpdateManyArgs>(args: SelectSubset<T, ProgramsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Programs.
     * @param {ProgramsUpsertArgs} args - Arguments to update or create a Programs.
     * @example
     * // Update or create a Programs
     * const programs = await prisma.programs.upsert({
     *   create: {
     *     // ... data to create a Programs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Programs we want to update
     *   }
     * })
     */
    upsert<T extends ProgramsUpsertArgs>(args: SelectSubset<T, ProgramsUpsertArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramsCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.programs.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramsCountArgs>(
      args?: Subset<T, ProgramsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramsAggregateArgs>(args: Subset<T, ProgramsAggregateArgs>): Prisma.PrismaPromise<GetProgramsAggregateType<T>>

    /**
     * Group by Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramsGroupByArgs['orderBy'] }
        : { orderBy?: ProgramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Programs model
   */
  readonly fields: ProgramsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Programs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate_programs<T extends Programs$affiliate_programsArgs<ExtArgs> = {}>(args?: Subset<T, Programs$affiliate_programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "findMany"> | Null>
    customer_discounts<T extends Programs$customer_discountsArgs<ExtArgs> = {}>(args?: Subset<T, Programs$customer_discountsArgs<ExtArgs>>): Prisma__CustomerDiscountsClient<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Orders<T extends Programs$OrdersArgs<ExtArgs> = {}>(args?: Subset<T, Programs$OrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany"> | Null>
    program_bonus<T extends Programs$program_bonusArgs<ExtArgs> = {}>(args?: Subset<T, Programs$program_bonusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "findMany"> | Null>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tiers<T extends Programs$tiersArgs<ExtArgs> = {}>(args?: Subset<T, Programs$tiersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "findMany"> | Null>
    activity_log<T extends Programs$activity_logArgs<ExtArgs> = {}>(args?: Subset<T, Programs$activity_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Programs model
   */ 
  interface ProgramsFieldRefs {
    readonly id: FieldRef<"Programs", 'Int'>
    readonly store_id: FieldRef<"Programs", 'Int'>
    readonly title: FieldRef<"Programs", 'String'>
    readonly description: FieldRef<"Programs", 'String'>
    readonly currency_code: FieldRef<"Programs", 'String'>
    readonly program_details: FieldRef<"Programs", 'Json'>
    readonly status: FieldRef<"Programs", 'ProgramStatusType'>
    readonly created_at: FieldRef<"Programs", 'BigInt'>
    readonly updated_at: FieldRef<"Programs", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Programs findUnique
   */
  export type ProgramsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where: ProgramsWhereUniqueInput
  }

  /**
   * Programs findUniqueOrThrow
   */
  export type ProgramsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where: ProgramsWhereUniqueInput
  }

  /**
   * Programs findFirst
   */
  export type ProgramsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramsOrderByWithRelationInput | ProgramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramsScalarFieldEnum | ProgramsScalarFieldEnum[]
  }

  /**
   * Programs findFirstOrThrow
   */
  export type ProgramsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramsOrderByWithRelationInput | ProgramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramsScalarFieldEnum | ProgramsScalarFieldEnum[]
  }

  /**
   * Programs findMany
   */
  export type ProgramsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramsOrderByWithRelationInput | ProgramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramsScalarFieldEnum | ProgramsScalarFieldEnum[]
  }

  /**
   * Programs create
   */
  export type ProgramsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    /**
     * The data needed to create a Programs.
     */
    data: XOR<ProgramsCreateInput, ProgramsUncheckedCreateInput>
  }

  /**
   * Programs createMany
   */
  export type ProgramsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramsCreateManyInput | ProgramsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Programs createManyAndReturn
   */
  export type ProgramsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramsCreateManyInput | ProgramsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Programs update
   */
  export type ProgramsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    /**
     * The data needed to update a Programs.
     */
    data: XOR<ProgramsUpdateInput, ProgramsUncheckedUpdateInput>
    /**
     * Choose, which Programs to update.
     */
    where: ProgramsWhereUniqueInput
  }

  /**
   * Programs updateMany
   */
  export type ProgramsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramsUpdateManyMutationInput, ProgramsUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramsWhereInput
  }

  /**
   * Programs upsert
   */
  export type ProgramsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    /**
     * The filter to search for the Programs to update in case it exists.
     */
    where: ProgramsWhereUniqueInput
    /**
     * In case the Programs found by the `where` argument doesn't exist, create a new Programs with this data.
     */
    create: XOR<ProgramsCreateInput, ProgramsUncheckedCreateInput>
    /**
     * In case the Programs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramsUpdateInput, ProgramsUncheckedUpdateInput>
  }

  /**
   * Programs delete
   */
  export type ProgramsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    /**
     * Filter which Programs to delete.
     */
    where: ProgramsWhereUniqueInput
  }

  /**
   * Programs deleteMany
   */
  export type ProgramsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramsWhereInput
  }

  /**
   * Programs.affiliate_programs
   */
  export type Programs$affiliate_programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    where?: AffiliateProgramsWhereInput
    orderBy?: AffiliateProgramsOrderByWithRelationInput | AffiliateProgramsOrderByWithRelationInput[]
    cursor?: AffiliateProgramsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateProgramsScalarFieldEnum | AffiliateProgramsScalarFieldEnum[]
  }

  /**
   * Programs.customer_discounts
   */
  export type Programs$customer_discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    where?: CustomerDiscountsWhereInput
  }

  /**
   * Programs.Orders
   */
  export type Programs$OrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Programs.program_bonus
   */
  export type Programs$program_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    where?: ProgramBonusWhereInput
    orderBy?: ProgramBonusOrderByWithRelationInput | ProgramBonusOrderByWithRelationInput[]
    cursor?: ProgramBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramBonusScalarFieldEnum | ProgramBonusScalarFieldEnum[]
  }

  /**
   * Programs.tiers
   */
  export type Programs$tiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    where?: TiersWhereInput
    orderBy?: TiersOrderByWithRelationInput | TiersOrderByWithRelationInput[]
    cursor?: TiersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TiersScalarFieldEnum | TiersScalarFieldEnum[]
  }

  /**
   * Programs.activity_log
   */
  export type Programs$activity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Programs without action
   */
  export type ProgramsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
  }


  /**
   * Model Tiers
   */

  export type AggregateTiers = {
    _count: TiersCountAggregateOutputType | null
    _avg: TiersAvgAggregateOutputType | null
    _sum: TiersSumAggregateOutputType | null
    _min: TiersMinAggregateOutputType | null
    _max: TiersMaxAggregateOutputType | null
  }

  export type TiersAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    min_value: number | null
    max_value: number | null
    commission_rate: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type TiersSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    min_value: number | null
    max_value: number | null
    commission_rate: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type TiersMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    tier_type: $Enums.TierType | null
    min_value: number | null
    max_value: number | null
    commission_type: $Enums.EarningType | null
    commission_rate: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type TiersMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    tier_type: $Enums.TierType | null
    min_value: number | null
    max_value: number | null
    commission_type: $Enums.EarningType | null
    commission_rate: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type TiersCountAggregateOutputType = {
    id: number
    store_id: number
    program_id: number
    tier_type: number
    min_value: number
    max_value: number
    commission_type: number
    commission_rate: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TiersAvgAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    min_value?: true
    max_value?: true
    commission_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type TiersSumAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    min_value?: true
    max_value?: true
    commission_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type TiersMinAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    tier_type?: true
    min_value?: true
    max_value?: true
    commission_type?: true
    commission_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type TiersMaxAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    tier_type?: true
    min_value?: true
    max_value?: true
    commission_type?: true
    commission_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type TiersCountAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    tier_type?: true
    min_value?: true
    max_value?: true
    commission_type?: true
    commission_rate?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TiersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tiers to aggregate.
     */
    where?: TiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tiers to fetch.
     */
    orderBy?: TiersOrderByWithRelationInput | TiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tiers
    **/
    _count?: true | TiersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TiersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TiersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TiersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TiersMaxAggregateInputType
  }

  export type GetTiersAggregateType<T extends TiersAggregateArgs> = {
        [P in keyof T & keyof AggregateTiers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTiers[P]>
      : GetScalarType<T[P], AggregateTiers[P]>
  }




  export type TiersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TiersWhereInput
    orderBy?: TiersOrderByWithAggregationInput | TiersOrderByWithAggregationInput[]
    by: TiersScalarFieldEnum[] | TiersScalarFieldEnum
    having?: TiersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TiersCountAggregateInputType | true
    _avg?: TiersAvgAggregateInputType
    _sum?: TiersSumAggregateInputType
    _min?: TiersMinAggregateInputType
    _max?: TiersMaxAggregateInputType
  }

  export type TiersGroupByOutputType = {
    id: number
    store_id: number
    program_id: number
    tier_type: $Enums.TierType
    min_value: number
    max_value: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint
    updated_at: bigint
    _count: TiersCountAggregateOutputType | null
    _avg: TiersAvgAggregateOutputType | null
    _sum: TiersSumAggregateOutputType | null
    _min: TiersMinAggregateOutputType | null
    _max: TiersMaxAggregateOutputType | null
  }

  type GetTiersGroupByPayload<T extends TiersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TiersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TiersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TiersGroupByOutputType[P]>
            : GetScalarType<T[P], TiersGroupByOutputType[P]>
        }
      >
    >


  export type TiersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    program_id?: boolean
    tier_type?: boolean
    min_value?: boolean
    max_value?: boolean
    commission_type?: boolean
    commission_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tiers"]>

  export type TiersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    program_id?: boolean
    tier_type?: boolean
    min_value?: boolean
    max_value?: boolean
    commission_type?: boolean
    commission_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tiers"]>

  export type TiersSelectScalar = {
    id?: boolean
    store_id?: boolean
    program_id?: boolean
    tier_type?: boolean
    min_value?: boolean
    max_value?: boolean
    commission_type?: boolean
    commission_rate?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TiersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type TiersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $TiersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tiers"
    objects: {
      programs: Prisma.$ProgramsPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      program_id: number
      tier_type: $Enums.TierType
      min_value: number
      max_value: number | null
      commission_type: $Enums.EarningType
      commission_rate: number
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["tiers"]>
    composites: {}
  }

  type TiersGetPayload<S extends boolean | null | undefined | TiersDefaultArgs> = $Result.GetResult<Prisma.$TiersPayload, S>

  type TiersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TiersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TiersCountAggregateInputType | true
    }

  export interface TiersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tiers'], meta: { name: 'Tiers' } }
    /**
     * Find zero or one Tiers that matches the filter.
     * @param {TiersFindUniqueArgs} args - Arguments to find a Tiers
     * @example
     * // Get one Tiers
     * const tiers = await prisma.tiers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TiersFindUniqueArgs>(args: SelectSubset<T, TiersFindUniqueArgs<ExtArgs>>): Prisma__TiersClient<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tiers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TiersFindUniqueOrThrowArgs} args - Arguments to find a Tiers
     * @example
     * // Get one Tiers
     * const tiers = await prisma.tiers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TiersFindUniqueOrThrowArgs>(args: SelectSubset<T, TiersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TiersClient<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiersFindFirstArgs} args - Arguments to find a Tiers
     * @example
     * // Get one Tiers
     * const tiers = await prisma.tiers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TiersFindFirstArgs>(args?: SelectSubset<T, TiersFindFirstArgs<ExtArgs>>): Prisma__TiersClient<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tiers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiersFindFirstOrThrowArgs} args - Arguments to find a Tiers
     * @example
     * // Get one Tiers
     * const tiers = await prisma.tiers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TiersFindFirstOrThrowArgs>(args?: SelectSubset<T, TiersFindFirstOrThrowArgs<ExtArgs>>): Prisma__TiersClient<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tiers
     * const tiers = await prisma.tiers.findMany()
     * 
     * // Get first 10 Tiers
     * const tiers = await prisma.tiers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tiersWithIdOnly = await prisma.tiers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TiersFindManyArgs>(args?: SelectSubset<T, TiersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tiers.
     * @param {TiersCreateArgs} args - Arguments to create a Tiers.
     * @example
     * // Create one Tiers
     * const Tiers = await prisma.tiers.create({
     *   data: {
     *     // ... data to create a Tiers
     *   }
     * })
     * 
     */
    create<T extends TiersCreateArgs>(args: SelectSubset<T, TiersCreateArgs<ExtArgs>>): Prisma__TiersClient<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tiers.
     * @param {TiersCreateManyArgs} args - Arguments to create many Tiers.
     * @example
     * // Create many Tiers
     * const tiers = await prisma.tiers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TiersCreateManyArgs>(args?: SelectSubset<T, TiersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tiers and returns the data saved in the database.
     * @param {TiersCreateManyAndReturnArgs} args - Arguments to create many Tiers.
     * @example
     * // Create many Tiers
     * const tiers = await prisma.tiers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tiers and only return the `id`
     * const tiersWithIdOnly = await prisma.tiers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TiersCreateManyAndReturnArgs>(args?: SelectSubset<T, TiersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tiers.
     * @param {TiersDeleteArgs} args - Arguments to delete one Tiers.
     * @example
     * // Delete one Tiers
     * const Tiers = await prisma.tiers.delete({
     *   where: {
     *     // ... filter to delete one Tiers
     *   }
     * })
     * 
     */
    delete<T extends TiersDeleteArgs>(args: SelectSubset<T, TiersDeleteArgs<ExtArgs>>): Prisma__TiersClient<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tiers.
     * @param {TiersUpdateArgs} args - Arguments to update one Tiers.
     * @example
     * // Update one Tiers
     * const tiers = await prisma.tiers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TiersUpdateArgs>(args: SelectSubset<T, TiersUpdateArgs<ExtArgs>>): Prisma__TiersClient<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tiers.
     * @param {TiersDeleteManyArgs} args - Arguments to filter Tiers to delete.
     * @example
     * // Delete a few Tiers
     * const { count } = await prisma.tiers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TiersDeleteManyArgs>(args?: SelectSubset<T, TiersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tiers
     * const tiers = await prisma.tiers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TiersUpdateManyArgs>(args: SelectSubset<T, TiersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tiers.
     * @param {TiersUpsertArgs} args - Arguments to update or create a Tiers.
     * @example
     * // Update or create a Tiers
     * const tiers = await prisma.tiers.upsert({
     *   create: {
     *     // ... data to create a Tiers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tiers we want to update
     *   }
     * })
     */
    upsert<T extends TiersUpsertArgs>(args: SelectSubset<T, TiersUpsertArgs<ExtArgs>>): Prisma__TiersClient<$Result.GetResult<Prisma.$TiersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiersCountArgs} args - Arguments to filter Tiers to count.
     * @example
     * // Count the number of Tiers
     * const count = await prisma.tiers.count({
     *   where: {
     *     // ... the filter for the Tiers we want to count
     *   }
     * })
    **/
    count<T extends TiersCountArgs>(
      args?: Subset<T, TiersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TiersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TiersAggregateArgs>(args: Subset<T, TiersAggregateArgs>): Prisma.PrismaPromise<GetTiersAggregateType<T>>

    /**
     * Group by Tiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TiersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TiersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TiersGroupByArgs['orderBy'] }
        : { orderBy?: TiersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TiersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTiersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tiers model
   */
  readonly fields: TiersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tiers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TiersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programs<T extends ProgramsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramsDefaultArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tiers model
   */ 
  interface TiersFieldRefs {
    readonly id: FieldRef<"Tiers", 'Int'>
    readonly store_id: FieldRef<"Tiers", 'Int'>
    readonly program_id: FieldRef<"Tiers", 'Int'>
    readonly tier_type: FieldRef<"Tiers", 'TierType'>
    readonly min_value: FieldRef<"Tiers", 'Float'>
    readonly max_value: FieldRef<"Tiers", 'Float'>
    readonly commission_type: FieldRef<"Tiers", 'EarningType'>
    readonly commission_rate: FieldRef<"Tiers", 'Float'>
    readonly created_at: FieldRef<"Tiers", 'BigInt'>
    readonly updated_at: FieldRef<"Tiers", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Tiers findUnique
   */
  export type TiersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    /**
     * Filter, which Tiers to fetch.
     */
    where: TiersWhereUniqueInput
  }

  /**
   * Tiers findUniqueOrThrow
   */
  export type TiersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    /**
     * Filter, which Tiers to fetch.
     */
    where: TiersWhereUniqueInput
  }

  /**
   * Tiers findFirst
   */
  export type TiersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    /**
     * Filter, which Tiers to fetch.
     */
    where?: TiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tiers to fetch.
     */
    orderBy?: TiersOrderByWithRelationInput | TiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tiers.
     */
    cursor?: TiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tiers.
     */
    distinct?: TiersScalarFieldEnum | TiersScalarFieldEnum[]
  }

  /**
   * Tiers findFirstOrThrow
   */
  export type TiersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    /**
     * Filter, which Tiers to fetch.
     */
    where?: TiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tiers to fetch.
     */
    orderBy?: TiersOrderByWithRelationInput | TiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tiers.
     */
    cursor?: TiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tiers.
     */
    distinct?: TiersScalarFieldEnum | TiersScalarFieldEnum[]
  }

  /**
   * Tiers findMany
   */
  export type TiersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    /**
     * Filter, which Tiers to fetch.
     */
    where?: TiersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tiers to fetch.
     */
    orderBy?: TiersOrderByWithRelationInput | TiersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tiers.
     */
    cursor?: TiersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tiers.
     */
    skip?: number
    distinct?: TiersScalarFieldEnum | TiersScalarFieldEnum[]
  }

  /**
   * Tiers create
   */
  export type TiersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    /**
     * The data needed to create a Tiers.
     */
    data: XOR<TiersCreateInput, TiersUncheckedCreateInput>
  }

  /**
   * Tiers createMany
   */
  export type TiersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tiers.
     */
    data: TiersCreateManyInput | TiersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tiers createManyAndReturn
   */
  export type TiersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tiers.
     */
    data: TiersCreateManyInput | TiersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tiers update
   */
  export type TiersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    /**
     * The data needed to update a Tiers.
     */
    data: XOR<TiersUpdateInput, TiersUncheckedUpdateInput>
    /**
     * Choose, which Tiers to update.
     */
    where: TiersWhereUniqueInput
  }

  /**
   * Tiers updateMany
   */
  export type TiersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tiers.
     */
    data: XOR<TiersUpdateManyMutationInput, TiersUncheckedUpdateManyInput>
    /**
     * Filter which Tiers to update
     */
    where?: TiersWhereInput
  }

  /**
   * Tiers upsert
   */
  export type TiersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    /**
     * The filter to search for the Tiers to update in case it exists.
     */
    where: TiersWhereUniqueInput
    /**
     * In case the Tiers found by the `where` argument doesn't exist, create a new Tiers with this data.
     */
    create: XOR<TiersCreateInput, TiersUncheckedCreateInput>
    /**
     * In case the Tiers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TiersUpdateInput, TiersUncheckedUpdateInput>
  }

  /**
   * Tiers delete
   */
  export type TiersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
    /**
     * Filter which Tiers to delete.
     */
    where: TiersWhereUniqueInput
  }

  /**
   * Tiers deleteMany
   */
  export type TiersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tiers to delete
     */
    where?: TiersWhereInput
  }

  /**
   * Tiers without action
   */
  export type TiersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tiers
     */
    select?: TiersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TiersInclude<ExtArgs> | null
  }


  /**
   * Model CustomerDiscounts
   */

  export type AggregateCustomerDiscounts = {
    _count: CustomerDiscountsCountAggregateOutputType | null
    _avg: CustomerDiscountsAvgAggregateOutputType | null
    _sum: CustomerDiscountsSumAggregateOutputType | null
    _min: CustomerDiscountsMinAggregateOutputType | null
    _max: CustomerDiscountsMaxAggregateOutputType | null
  }

  export type CustomerDiscountsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    discount_rate: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type CustomerDiscountsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    discount_rate: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type CustomerDiscountsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    discount_rate: number | null
    created_at: bigint | null
    updated_at: bigint | null
    discount_type: $Enums.CustomerDiscountType | null
  }

  export type CustomerDiscountsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    discount_rate: number | null
    created_at: bigint | null
    updated_at: bigint | null
    discount_type: $Enums.CustomerDiscountType | null
  }

  export type CustomerDiscountsCountAggregateOutputType = {
    id: number
    store_id: number
    program_id: number
    discount_rate: number
    discount_options: number
    created_at: number
    updated_at: number
    discount_type: number
    _all: number
  }


  export type CustomerDiscountsAvgAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    discount_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerDiscountsSumAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    discount_rate?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomerDiscountsMinAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    discount_rate?: true
    created_at?: true
    updated_at?: true
    discount_type?: true
  }

  export type CustomerDiscountsMaxAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    discount_rate?: true
    created_at?: true
    updated_at?: true
    discount_type?: true
  }

  export type CustomerDiscountsCountAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    discount_rate?: true
    discount_options?: true
    created_at?: true
    updated_at?: true
    discount_type?: true
    _all?: true
  }

  export type CustomerDiscountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDiscounts to aggregate.
     */
    where?: CustomerDiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountsOrderByWithRelationInput | CustomerDiscountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerDiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerDiscounts
    **/
    _count?: true | CustomerDiscountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerDiscountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerDiscountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerDiscountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerDiscountsMaxAggregateInputType
  }

  export type GetCustomerDiscountsAggregateType<T extends CustomerDiscountsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerDiscounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerDiscounts[P]>
      : GetScalarType<T[P], AggregateCustomerDiscounts[P]>
  }




  export type CustomerDiscountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerDiscountsWhereInput
    orderBy?: CustomerDiscountsOrderByWithAggregationInput | CustomerDiscountsOrderByWithAggregationInput[]
    by: CustomerDiscountsScalarFieldEnum[] | CustomerDiscountsScalarFieldEnum
    having?: CustomerDiscountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerDiscountsCountAggregateInputType | true
    _avg?: CustomerDiscountsAvgAggregateInputType
    _sum?: CustomerDiscountsSumAggregateInputType
    _min?: CustomerDiscountsMinAggregateInputType
    _max?: CustomerDiscountsMaxAggregateInputType
  }

  export type CustomerDiscountsGroupByOutputType = {
    id: number
    store_id: number
    program_id: number
    discount_rate: number
    discount_options: JsonValue
    created_at: bigint
    updated_at: bigint
    discount_type: $Enums.CustomerDiscountType
    _count: CustomerDiscountsCountAggregateOutputType | null
    _avg: CustomerDiscountsAvgAggregateOutputType | null
    _sum: CustomerDiscountsSumAggregateOutputType | null
    _min: CustomerDiscountsMinAggregateOutputType | null
    _max: CustomerDiscountsMaxAggregateOutputType | null
  }

  type GetCustomerDiscountsGroupByPayload<T extends CustomerDiscountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerDiscountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerDiscountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerDiscountsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerDiscountsGroupByOutputType[P]>
        }
      >
    >


  export type CustomerDiscountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    program_id?: boolean
    discount_rate?: boolean
    discount_options?: boolean
    created_at?: boolean
    updated_at?: boolean
    discount_type?: boolean
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDiscounts"]>

  export type CustomerDiscountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    program_id?: boolean
    discount_rate?: boolean
    discount_options?: boolean
    created_at?: boolean
    updated_at?: boolean
    discount_type?: boolean
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerDiscounts"]>

  export type CustomerDiscountsSelectScalar = {
    id?: boolean
    store_id?: boolean
    program_id?: boolean
    discount_rate?: boolean
    discount_options?: boolean
    created_at?: boolean
    updated_at?: boolean
    discount_type?: boolean
  }

  export type CustomerDiscountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type CustomerDiscountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $CustomerDiscountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerDiscounts"
    objects: {
      programs: Prisma.$ProgramsPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      program_id: number
      discount_rate: number
      discount_options: Prisma.JsonValue
      created_at: bigint
      updated_at: bigint
      discount_type: $Enums.CustomerDiscountType
    }, ExtArgs["result"]["customerDiscounts"]>
    composites: {}
  }

  type CustomerDiscountsGetPayload<S extends boolean | null | undefined | CustomerDiscountsDefaultArgs> = $Result.GetResult<Prisma.$CustomerDiscountsPayload, S>

  type CustomerDiscountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerDiscountsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerDiscountsCountAggregateInputType | true
    }

  export interface CustomerDiscountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerDiscounts'], meta: { name: 'CustomerDiscounts' } }
    /**
     * Find zero or one CustomerDiscounts that matches the filter.
     * @param {CustomerDiscountsFindUniqueArgs} args - Arguments to find a CustomerDiscounts
     * @example
     * // Get one CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerDiscountsFindUniqueArgs>(args: SelectSubset<T, CustomerDiscountsFindUniqueArgs<ExtArgs>>): Prisma__CustomerDiscountsClient<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CustomerDiscounts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerDiscountsFindUniqueOrThrowArgs} args - Arguments to find a CustomerDiscounts
     * @example
     * // Get one CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerDiscountsFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerDiscountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerDiscountsClient<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CustomerDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountsFindFirstArgs} args - Arguments to find a CustomerDiscounts
     * @example
     * // Get one CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerDiscountsFindFirstArgs>(args?: SelectSubset<T, CustomerDiscountsFindFirstArgs<ExtArgs>>): Prisma__CustomerDiscountsClient<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CustomerDiscounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountsFindFirstOrThrowArgs} args - Arguments to find a CustomerDiscounts
     * @example
     * // Get one CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerDiscountsFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerDiscountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerDiscountsClient<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CustomerDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.findMany()
     * 
     * // Get first 10 CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerDiscountsWithIdOnly = await prisma.customerDiscounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerDiscountsFindManyArgs>(args?: SelectSubset<T, CustomerDiscountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CustomerDiscounts.
     * @param {CustomerDiscountsCreateArgs} args - Arguments to create a CustomerDiscounts.
     * @example
     * // Create one CustomerDiscounts
     * const CustomerDiscounts = await prisma.customerDiscounts.create({
     *   data: {
     *     // ... data to create a CustomerDiscounts
     *   }
     * })
     * 
     */
    create<T extends CustomerDiscountsCreateArgs>(args: SelectSubset<T, CustomerDiscountsCreateArgs<ExtArgs>>): Prisma__CustomerDiscountsClient<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CustomerDiscounts.
     * @param {CustomerDiscountsCreateManyArgs} args - Arguments to create many CustomerDiscounts.
     * @example
     * // Create many CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerDiscountsCreateManyArgs>(args?: SelectSubset<T, CustomerDiscountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerDiscounts and returns the data saved in the database.
     * @param {CustomerDiscountsCreateManyAndReturnArgs} args - Arguments to create many CustomerDiscounts.
     * @example
     * // Create many CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerDiscounts and only return the `id`
     * const customerDiscountsWithIdOnly = await prisma.customerDiscounts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerDiscountsCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerDiscountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CustomerDiscounts.
     * @param {CustomerDiscountsDeleteArgs} args - Arguments to delete one CustomerDiscounts.
     * @example
     * // Delete one CustomerDiscounts
     * const CustomerDiscounts = await prisma.customerDiscounts.delete({
     *   where: {
     *     // ... filter to delete one CustomerDiscounts
     *   }
     * })
     * 
     */
    delete<T extends CustomerDiscountsDeleteArgs>(args: SelectSubset<T, CustomerDiscountsDeleteArgs<ExtArgs>>): Prisma__CustomerDiscountsClient<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CustomerDiscounts.
     * @param {CustomerDiscountsUpdateArgs} args - Arguments to update one CustomerDiscounts.
     * @example
     * // Update one CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerDiscountsUpdateArgs>(args: SelectSubset<T, CustomerDiscountsUpdateArgs<ExtArgs>>): Prisma__CustomerDiscountsClient<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CustomerDiscounts.
     * @param {CustomerDiscountsDeleteManyArgs} args - Arguments to filter CustomerDiscounts to delete.
     * @example
     * // Delete a few CustomerDiscounts
     * const { count } = await prisma.customerDiscounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDiscountsDeleteManyArgs>(args?: SelectSubset<T, CustomerDiscountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerDiscountsUpdateManyArgs>(args: SelectSubset<T, CustomerDiscountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CustomerDiscounts.
     * @param {CustomerDiscountsUpsertArgs} args - Arguments to update or create a CustomerDiscounts.
     * @example
     * // Update or create a CustomerDiscounts
     * const customerDiscounts = await prisma.customerDiscounts.upsert({
     *   create: {
     *     // ... data to create a CustomerDiscounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerDiscounts we want to update
     *   }
     * })
     */
    upsert<T extends CustomerDiscountsUpsertArgs>(args: SelectSubset<T, CustomerDiscountsUpsertArgs<ExtArgs>>): Prisma__CustomerDiscountsClient<$Result.GetResult<Prisma.$CustomerDiscountsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CustomerDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountsCountArgs} args - Arguments to filter CustomerDiscounts to count.
     * @example
     * // Count the number of CustomerDiscounts
     * const count = await prisma.customerDiscounts.count({
     *   where: {
     *     // ... the filter for the CustomerDiscounts we want to count
     *   }
     * })
    **/
    count<T extends CustomerDiscountsCountArgs>(
      args?: Subset<T, CustomerDiscountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerDiscountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerDiscountsAggregateArgs>(args: Subset<T, CustomerDiscountsAggregateArgs>): Prisma.PrismaPromise<GetCustomerDiscountsAggregateType<T>>

    /**
     * Group by CustomerDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerDiscountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerDiscountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerDiscountsGroupByArgs['orderBy'] }
        : { orderBy?: CustomerDiscountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerDiscountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerDiscountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerDiscounts model
   */
  readonly fields: CustomerDiscountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerDiscounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerDiscountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programs<T extends ProgramsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramsDefaultArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerDiscounts model
   */ 
  interface CustomerDiscountsFieldRefs {
    readonly id: FieldRef<"CustomerDiscounts", 'Int'>
    readonly store_id: FieldRef<"CustomerDiscounts", 'Int'>
    readonly program_id: FieldRef<"CustomerDiscounts", 'Int'>
    readonly discount_rate: FieldRef<"CustomerDiscounts", 'Float'>
    readonly discount_options: FieldRef<"CustomerDiscounts", 'Json'>
    readonly created_at: FieldRef<"CustomerDiscounts", 'BigInt'>
    readonly updated_at: FieldRef<"CustomerDiscounts", 'BigInt'>
    readonly discount_type: FieldRef<"CustomerDiscounts", 'CustomerDiscountType'>
  }
    

  // Custom InputTypes
  /**
   * CustomerDiscounts findUnique
   */
  export type CustomerDiscountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscounts to fetch.
     */
    where: CustomerDiscountsWhereUniqueInput
  }

  /**
   * CustomerDiscounts findUniqueOrThrow
   */
  export type CustomerDiscountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscounts to fetch.
     */
    where: CustomerDiscountsWhereUniqueInput
  }

  /**
   * CustomerDiscounts findFirst
   */
  export type CustomerDiscountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscounts to fetch.
     */
    where?: CustomerDiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountsOrderByWithRelationInput | CustomerDiscountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDiscounts.
     */
    cursor?: CustomerDiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDiscounts.
     */
    distinct?: CustomerDiscountsScalarFieldEnum | CustomerDiscountsScalarFieldEnum[]
  }

  /**
   * CustomerDiscounts findFirstOrThrow
   */
  export type CustomerDiscountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscounts to fetch.
     */
    where?: CustomerDiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountsOrderByWithRelationInput | CustomerDiscountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerDiscounts.
     */
    cursor?: CustomerDiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerDiscounts.
     */
    distinct?: CustomerDiscountsScalarFieldEnum | CustomerDiscountsScalarFieldEnum[]
  }

  /**
   * CustomerDiscounts findMany
   */
  export type CustomerDiscountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which CustomerDiscounts to fetch.
     */
    where?: CustomerDiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerDiscounts to fetch.
     */
    orderBy?: CustomerDiscountsOrderByWithRelationInput | CustomerDiscountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerDiscounts.
     */
    cursor?: CustomerDiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerDiscounts.
     */
    skip?: number
    distinct?: CustomerDiscountsScalarFieldEnum | CustomerDiscountsScalarFieldEnum[]
  }

  /**
   * CustomerDiscounts create
   */
  export type CustomerDiscountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerDiscounts.
     */
    data: XOR<CustomerDiscountsCreateInput, CustomerDiscountsUncheckedCreateInput>
  }

  /**
   * CustomerDiscounts createMany
   */
  export type CustomerDiscountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerDiscounts.
     */
    data: CustomerDiscountsCreateManyInput | CustomerDiscountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerDiscounts createManyAndReturn
   */
  export type CustomerDiscountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CustomerDiscounts.
     */
    data: CustomerDiscountsCreateManyInput | CustomerDiscountsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerDiscounts update
   */
  export type CustomerDiscountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerDiscounts.
     */
    data: XOR<CustomerDiscountsUpdateInput, CustomerDiscountsUncheckedUpdateInput>
    /**
     * Choose, which CustomerDiscounts to update.
     */
    where: CustomerDiscountsWhereUniqueInput
  }

  /**
   * CustomerDiscounts updateMany
   */
  export type CustomerDiscountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerDiscounts.
     */
    data: XOR<CustomerDiscountsUpdateManyMutationInput, CustomerDiscountsUncheckedUpdateManyInput>
    /**
     * Filter which CustomerDiscounts to update
     */
    where?: CustomerDiscountsWhereInput
  }

  /**
   * CustomerDiscounts upsert
   */
  export type CustomerDiscountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerDiscounts to update in case it exists.
     */
    where: CustomerDiscountsWhereUniqueInput
    /**
     * In case the CustomerDiscounts found by the `where` argument doesn't exist, create a new CustomerDiscounts with this data.
     */
    create: XOR<CustomerDiscountsCreateInput, CustomerDiscountsUncheckedCreateInput>
    /**
     * In case the CustomerDiscounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerDiscountsUpdateInput, CustomerDiscountsUncheckedUpdateInput>
  }

  /**
   * CustomerDiscounts delete
   */
  export type CustomerDiscountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
    /**
     * Filter which CustomerDiscounts to delete.
     */
    where: CustomerDiscountsWhereUniqueInput
  }

  /**
   * CustomerDiscounts deleteMany
   */
  export type CustomerDiscountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerDiscounts to delete
     */
    where?: CustomerDiscountsWhereInput
  }

  /**
   * CustomerDiscounts without action
   */
  export type CustomerDiscountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerDiscounts
     */
    select?: CustomerDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerDiscountsInclude<ExtArgs> | null
  }


  /**
   * Model Orders
   */

  export type AggregateOrders = {
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  export type OrdersAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    customer_id: number | null
    order_id: number | null
    shopify_order_number: number | null
    shop_order_amount: number | null
    customer_order_amount: number | null
    created_at: number | null
    updated_at: number | null
    program_id: number | null
  }

  export type OrdersSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    customer_id: number | null
    order_id: bigint | null
    shopify_order_number: number | null
    shop_order_amount: number | null
    customer_order_amount: number | null
    created_at: bigint | null
    updated_at: bigint | null
    program_id: number | null
  }

  export type OrdersMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    customer_id: number | null
    order_id: bigint | null
    shopify_order_number: number | null
    shop_order_currency_code: string | null
    shop_order_amount: number | null
    customer_order_currency_code: string | null
    customer_order_amount: number | null
    financial_status: string | null
    attribute_type: $Enums.OrderAttributeType | null
    status: $Enums.OrderStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
    program_id: number | null
  }

  export type OrdersMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    customer_id: number | null
    order_id: bigint | null
    shopify_order_number: number | null
    shop_order_currency_code: string | null
    shop_order_amount: number | null
    customer_order_currency_code: string | null
    customer_order_amount: number | null
    financial_status: string | null
    attribute_type: $Enums.OrderAttributeType | null
    status: $Enums.OrderStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
    program_id: number | null
  }

  export type OrdersCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: number
    shopify_order_number: number
    shop_order_currency_code: number
    shop_order_amount: number
    customer_order_currency_code: number
    customer_order_amount: number
    financial_status: number
    order_details: number
    attribute_type: number
    status: number
    created_at: number
    updated_at: number
    program_id: number
    _all: number
  }


  export type OrdersAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    shopify_order_number?: true
    shop_order_amount?: true
    customer_order_amount?: true
    created_at?: true
    updated_at?: true
    program_id?: true
  }

  export type OrdersSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    shopify_order_number?: true
    shop_order_amount?: true
    customer_order_amount?: true
    created_at?: true
    updated_at?: true
    program_id?: true
  }

  export type OrdersMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    shopify_order_number?: true
    shop_order_currency_code?: true
    shop_order_amount?: true
    customer_order_currency_code?: true
    customer_order_amount?: true
    financial_status?: true
    attribute_type?: true
    status?: true
    created_at?: true
    updated_at?: true
    program_id?: true
  }

  export type OrdersMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    shopify_order_number?: true
    shop_order_currency_code?: true
    shop_order_amount?: true
    customer_order_currency_code?: true
    customer_order_amount?: true
    financial_status?: true
    attribute_type?: true
    status?: true
    created_at?: true
    updated_at?: true
    program_id?: true
  }

  export type OrdersCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    shopify_order_number?: true
    shop_order_currency_code?: true
    shop_order_amount?: true
    customer_order_currency_code?: true
    customer_order_amount?: true
    financial_status?: true
    order_details?: true
    attribute_type?: true
    status?: true
    created_at?: true
    updated_at?: true
    program_id?: true
    _all?: true
  }

  export type OrdersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to aggregate.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrdersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrdersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrdersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrdersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrdersMaxAggregateInputType
  }

  export type GetOrdersAggregateType<T extends OrdersAggregateArgs> = {
        [P in keyof T & keyof AggregateOrders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrders[P]>
      : GetScalarType<T[P], AggregateOrders[P]>
  }




  export type OrdersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithAggregationInput | OrdersOrderByWithAggregationInput[]
    by: OrdersScalarFieldEnum[] | OrdersScalarFieldEnum
    having?: OrdersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrdersCountAggregateInputType | true
    _avg?: OrdersAvgAggregateInputType
    _sum?: OrdersSumAggregateInputType
    _min?: OrdersMinAggregateInputType
    _max?: OrdersMaxAggregateInputType
  }

  export type OrdersGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: bigint
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonValue
    attribute_type: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint
    updated_at: bigint
    program_id: number | null
    _count: OrdersCountAggregateOutputType | null
    _avg: OrdersAvgAggregateOutputType | null
    _sum: OrdersSumAggregateOutputType | null
    _min: OrdersMinAggregateOutputType | null
    _max: OrdersMaxAggregateOutputType | null
  }

  type GetOrdersGroupByPayload<T extends OrdersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrdersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrdersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrdersGroupByOutputType[P]>
            : GetScalarType<T[P], OrdersGroupByOutputType[P]>
        }
      >
    >


  export type OrdersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    customer_id?: boolean
    order_id?: boolean
    shopify_order_number?: boolean
    shop_order_currency_code?: boolean
    shop_order_amount?: boolean
    customer_order_currency_code?: boolean
    customer_order_amount?: boolean
    financial_status?: boolean
    order_details?: boolean
    attribute_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    program_id?: boolean
    commissions?: boolean | Orders$commissionsArgs<ExtArgs>
    order_items?: boolean | Orders$order_itemsArgs<ExtArgs>
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    customers?: boolean | CustomersDefaultArgs<ExtArgs>
    programs?: boolean | Orders$programsArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    activity_log?: boolean | Orders$activity_logArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type OrdersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    customer_id?: boolean
    order_id?: boolean
    shopify_order_number?: boolean
    shop_order_currency_code?: boolean
    shop_order_amount?: boolean
    customer_order_currency_code?: boolean
    customer_order_amount?: boolean
    financial_status?: boolean
    order_details?: boolean
    attribute_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    program_id?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    customers?: boolean | CustomersDefaultArgs<ExtArgs>
    programs?: boolean | Orders$programsArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orders"]>

  export type OrdersSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    customer_id?: boolean
    order_id?: boolean
    shopify_order_number?: boolean
    shop_order_currency_code?: boolean
    shop_order_amount?: boolean
    customer_order_currency_code?: boolean
    customer_order_amount?: boolean
    financial_status?: boolean
    order_details?: boolean
    attribute_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    program_id?: boolean
  }

  export type OrdersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    commissions?: boolean | Orders$commissionsArgs<ExtArgs>
    order_items?: boolean | Orders$order_itemsArgs<ExtArgs>
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    customers?: boolean | CustomersDefaultArgs<ExtArgs>
    programs?: boolean | Orders$programsArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    activity_log?: boolean | Orders$activity_logArgs<ExtArgs>
    _count?: boolean | OrdersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrdersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    customers?: boolean | CustomersDefaultArgs<ExtArgs>
    programs?: boolean | Orders$programsArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $OrdersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Orders"
    objects: {
      commissions: Prisma.$CommissionsPayload<ExtArgs> | null
      order_items: Prisma.$OrderItemsPayload<ExtArgs>[]
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      customers: Prisma.$CustomersPayload<ExtArgs>
      programs: Prisma.$ProgramsPayload<ExtArgs> | null
      stores: Prisma.$StoresPayload<ExtArgs>
      activity_log: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      customer_id: number
      order_id: bigint
      shopify_order_number: number
      shop_order_currency_code: string
      shop_order_amount: number
      customer_order_currency_code: string
      customer_order_amount: number
      financial_status: string
      order_details: Prisma.JsonValue
      attribute_type: $Enums.OrderAttributeType
      status: $Enums.OrderStatusType
      created_at: bigint
      updated_at: bigint
      program_id: number | null
    }, ExtArgs["result"]["orders"]>
    composites: {}
  }

  type OrdersGetPayload<S extends boolean | null | undefined | OrdersDefaultArgs> = $Result.GetResult<Prisma.$OrdersPayload, S>

  type OrdersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrdersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrdersCountAggregateInputType | true
    }

  export interface OrdersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Orders'], meta: { name: 'Orders' } }
    /**
     * Find zero or one Orders that matches the filter.
     * @param {OrdersFindUniqueArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrdersFindUniqueArgs>(args: SelectSubset<T, OrdersFindUniqueArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Orders that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrdersFindUniqueOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrdersFindUniqueOrThrowArgs>(args: SelectSubset<T, OrdersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrdersFindFirstArgs>(args?: SelectSubset<T, OrdersFindFirstArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Orders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindFirstOrThrowArgs} args - Arguments to find a Orders
     * @example
     * // Get one Orders
     * const orders = await prisma.orders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrdersFindFirstOrThrowArgs>(args?: SelectSubset<T, OrdersFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.orders.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.orders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ordersWithIdOnly = await prisma.orders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrdersFindManyArgs>(args?: SelectSubset<T, OrdersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Orders.
     * @param {OrdersCreateArgs} args - Arguments to create a Orders.
     * @example
     * // Create one Orders
     * const Orders = await prisma.orders.create({
     *   data: {
     *     // ... data to create a Orders
     *   }
     * })
     * 
     */
    create<T extends OrdersCreateArgs>(args: SelectSubset<T, OrdersCreateArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Orders.
     * @param {OrdersCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrdersCreateManyArgs>(args?: SelectSubset<T, OrdersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrdersCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const orders = await prisma.orders.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const ordersWithIdOnly = await prisma.orders.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrdersCreateManyAndReturnArgs>(args?: SelectSubset<T, OrdersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Orders.
     * @param {OrdersDeleteArgs} args - Arguments to delete one Orders.
     * @example
     * // Delete one Orders
     * const Orders = await prisma.orders.delete({
     *   where: {
     *     // ... filter to delete one Orders
     *   }
     * })
     * 
     */
    delete<T extends OrdersDeleteArgs>(args: SelectSubset<T, OrdersDeleteArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Orders.
     * @param {OrdersUpdateArgs} args - Arguments to update one Orders.
     * @example
     * // Update one Orders
     * const orders = await prisma.orders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrdersUpdateArgs>(args: SelectSubset<T, OrdersUpdateArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Orders.
     * @param {OrdersDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.orders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrdersDeleteManyArgs>(args?: SelectSubset<T, OrdersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const orders = await prisma.orders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrdersUpdateManyArgs>(args: SelectSubset<T, OrdersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Orders.
     * @param {OrdersUpsertArgs} args - Arguments to update or create a Orders.
     * @example
     * // Update or create a Orders
     * const orders = await prisma.orders.upsert({
     *   create: {
     *     // ... data to create a Orders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Orders we want to update
     *   }
     * })
     */
    upsert<T extends OrdersUpsertArgs>(args: SelectSubset<T, OrdersUpsertArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.orders.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrdersCountArgs>(
      args?: Subset<T, OrdersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrdersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrdersAggregateArgs>(args: Subset<T, OrdersAggregateArgs>): Prisma.PrismaPromise<GetOrdersAggregateType<T>>

    /**
     * Group by Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrdersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrdersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrdersGroupByArgs['orderBy'] }
        : { orderBy?: OrdersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrdersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrdersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Orders model
   */
  readonly fields: OrdersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Orders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrdersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    commissions<T extends Orders$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, Orders$commissionsArgs<ExtArgs>>): Prisma__CommissionsClient<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order_items<T extends Orders$order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Orders$order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany"> | Null>
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customers<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    programs<T extends Orders$programsArgs<ExtArgs> = {}>(args?: Subset<T, Orders$programsArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activity_log<T extends Orders$activity_logArgs<ExtArgs> = {}>(args?: Subset<T, Orders$activity_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Orders model
   */ 
  interface OrdersFieldRefs {
    readonly id: FieldRef<"Orders", 'Int'>
    readonly store_id: FieldRef<"Orders", 'Int'>
    readonly affiliate_id: FieldRef<"Orders", 'Int'>
    readonly customer_id: FieldRef<"Orders", 'Int'>
    readonly order_id: FieldRef<"Orders", 'BigInt'>
    readonly shopify_order_number: FieldRef<"Orders", 'Int'>
    readonly shop_order_currency_code: FieldRef<"Orders", 'String'>
    readonly shop_order_amount: FieldRef<"Orders", 'Float'>
    readonly customer_order_currency_code: FieldRef<"Orders", 'String'>
    readonly customer_order_amount: FieldRef<"Orders", 'Float'>
    readonly financial_status: FieldRef<"Orders", 'String'>
    readonly order_details: FieldRef<"Orders", 'Json'>
    readonly attribute_type: FieldRef<"Orders", 'OrderAttributeType'>
    readonly status: FieldRef<"Orders", 'OrderStatusType'>
    readonly created_at: FieldRef<"Orders", 'BigInt'>
    readonly updated_at: FieldRef<"Orders", 'BigInt'>
    readonly program_id: FieldRef<"Orders", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Orders findUnique
   */
  export type OrdersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders findUniqueOrThrow
   */
  export type OrdersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders findFirst
   */
  export type OrdersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders findFirstOrThrow
   */
  export type OrdersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders findMany
   */
  export type OrdersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrdersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrdersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Orders create
   */
  export type OrdersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to create a Orders.
     */
    data: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
  }

  /**
   * Orders createMany
   */
  export type OrdersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrdersCreateManyInput | OrdersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Orders createManyAndReturn
   */
  export type OrdersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrdersCreateManyInput | OrdersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Orders update
   */
  export type OrdersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The data needed to update a Orders.
     */
    data: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
    /**
     * Choose, which Orders to update.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders updateMany
   */
  export type OrdersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrdersWhereInput
  }

  /**
   * Orders upsert
   */
  export type OrdersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * The filter to search for the Orders to update in case it exists.
     */
    where: OrdersWhereUniqueInput
    /**
     * In case the Orders found by the `where` argument doesn't exist, create a new Orders with this data.
     */
    create: XOR<OrdersCreateInput, OrdersUncheckedCreateInput>
    /**
     * In case the Orders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrdersUpdateInput, OrdersUncheckedUpdateInput>
  }

  /**
   * Orders delete
   */
  export type OrdersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    /**
     * Filter which Orders to delete.
     */
    where: OrdersWhereUniqueInput
  }

  /**
   * Orders deleteMany
   */
  export type OrdersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrdersWhereInput
  }

  /**
   * Orders.commissions
   */
  export type Orders$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    where?: CommissionsWhereInput
  }

  /**
   * Orders.order_items
   */
  export type Orders$order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    cursor?: OrderItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * Orders.programs
   */
  export type Orders$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    where?: ProgramsWhereInput
  }

  /**
   * Orders.activity_log
   */
  export type Orders$activity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Orders without action
   */
  export type OrdersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
  }


  /**
   * Model OrderItems
   */

  export type AggregateOrderItems = {
    _count: OrderItemsCountAggregateOutputType | null
    _avg: OrderItemsAvgAggregateOutputType | null
    _sum: OrderItemsSumAggregateOutputType | null
    _min: OrderItemsMinAggregateOutputType | null
    _max: OrderItemsMaxAggregateOutputType | null
  }

  export type OrderItemsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    customer_id: number | null
    order_id: number | null
    item_id: number | null
    product_id: number | null
    variant_id: number | null
    quantity: number | null
    shop_item_amount: number | null
    customer_item_amount: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type OrderItemsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    customer_id: number | null
    order_id: number | null
    item_id: bigint | null
    product_id: bigint | null
    variant_id: bigint | null
    quantity: number | null
    shop_item_amount: number | null
    customer_item_amount: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type OrderItemsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    customer_id: number | null
    order_id: number | null
    item_id: bigint | null
    product_id: bigint | null
    variant_id: bigint | null
    product_title: string | null
    variant_title: string | null
    quantity: number | null
    shop_item_currency_code: string | null
    shop_item_amount: number | null
    customer_item_currency_code: string | null
    customer_item_amount: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type OrderItemsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    customer_id: number | null
    order_id: number | null
    item_id: bigint | null
    product_id: bigint | null
    variant_id: bigint | null
    product_title: string | null
    variant_title: string | null
    quantity: number | null
    shop_item_currency_code: string | null
    shop_item_amount: number | null
    customer_item_currency_code: string | null
    customer_item_amount: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type OrderItemsCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: number
    item_id: number
    product_id: number
    variant_id: number
    product_title: number
    variant_title: number
    quantity: number
    shop_item_currency_code: number
    shop_item_amount: number
    customer_item_currency_code: number
    customer_item_amount: number
    item_details: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OrderItemsAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    item_id?: true
    product_id?: true
    variant_id?: true
    quantity?: true
    shop_item_amount?: true
    customer_item_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderItemsSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    item_id?: true
    product_id?: true
    variant_id?: true
    quantity?: true
    shop_item_amount?: true
    customer_item_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderItemsMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    item_id?: true
    product_id?: true
    variant_id?: true
    product_title?: true
    variant_title?: true
    quantity?: true
    shop_item_currency_code?: true
    shop_item_amount?: true
    customer_item_currency_code?: true
    customer_item_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderItemsMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    item_id?: true
    product_id?: true
    variant_id?: true
    product_title?: true
    variant_title?: true
    quantity?: true
    shop_item_currency_code?: true
    shop_item_amount?: true
    customer_item_currency_code?: true
    customer_item_amount?: true
    created_at?: true
    updated_at?: true
  }

  export type OrderItemsCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    customer_id?: true
    order_id?: true
    item_id?: true
    product_id?: true
    variant_id?: true
    product_title?: true
    variant_title?: true
    quantity?: true
    shop_item_currency_code?: true
    shop_item_amount?: true
    customer_item_currency_code?: true
    customer_item_amount?: true
    item_details?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OrderItemsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to aggregate.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemsMaxAggregateInputType
  }

  export type GetOrderItemsAggregateType<T extends OrderItemsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItems]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItems[P]>
      : GetScalarType<T[P], AggregateOrderItems[P]>
  }




  export type OrderItemsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithAggregationInput | OrderItemsOrderByWithAggregationInput[]
    by: OrderItemsScalarFieldEnum[] | OrderItemsScalarFieldEnum
    having?: OrderItemsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemsCountAggregateInputType | true
    _avg?: OrderItemsAvgAggregateInputType
    _sum?: OrderItemsSumAggregateInputType
    _min?: OrderItemsMinAggregateInputType
    _max?: OrderItemsMaxAggregateInputType
  }

  export type OrderItemsGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: number
    item_id: bigint
    product_id: bigint
    variant_id: bigint
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonValue
    created_at: bigint
    updated_at: bigint
    _count: OrderItemsCountAggregateOutputType | null
    _avg: OrderItemsAvgAggregateOutputType | null
    _sum: OrderItemsSumAggregateOutputType | null
    _min: OrderItemsMinAggregateOutputType | null
    _max: OrderItemsMaxAggregateOutputType | null
  }

  type GetOrderItemsGroupByPayload<T extends OrderItemsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemsGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemsGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    customer_id?: boolean
    order_id?: boolean
    item_id?: boolean
    product_id?: boolean
    variant_id?: boolean
    product_title?: boolean
    variant_title?: boolean
    quantity?: boolean
    shop_item_currency_code?: boolean
    shop_item_amount?: boolean
    customer_item_currency_code?: boolean
    customer_item_amount?: boolean
    item_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    customers?: boolean | CustomersDefaultArgs<ExtArgs>
    orders?: boolean | OrdersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItems"]>

  export type OrderItemsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    customer_id?: boolean
    order_id?: boolean
    item_id?: boolean
    product_id?: boolean
    variant_id?: boolean
    product_title?: boolean
    variant_title?: boolean
    quantity?: boolean
    shop_item_currency_code?: boolean
    shop_item_amount?: boolean
    customer_item_currency_code?: boolean
    customer_item_amount?: boolean
    item_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    customers?: boolean | CustomersDefaultArgs<ExtArgs>
    orders?: boolean | OrdersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItems"]>

  export type OrderItemsSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    customer_id?: boolean
    order_id?: boolean
    item_id?: boolean
    product_id?: boolean
    variant_id?: boolean
    product_title?: boolean
    variant_title?: boolean
    quantity?: boolean
    shop_item_currency_code?: boolean
    shop_item_amount?: boolean
    customer_item_currency_code?: boolean
    customer_item_amount?: boolean
    item_details?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type OrderItemsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    customers?: boolean | CustomersDefaultArgs<ExtArgs>
    orders?: boolean | OrdersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type OrderItemsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    customers?: boolean | CustomersDefaultArgs<ExtArgs>
    orders?: boolean | OrdersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $OrderItemsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItems"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      customers: Prisma.$CustomersPayload<ExtArgs>
      orders: Prisma.$OrdersPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      customer_id: number
      order_id: number
      item_id: bigint
      product_id: bigint
      variant_id: bigint
      product_title: string
      variant_title: string
      quantity: number
      shop_item_currency_code: string
      shop_item_amount: number
      customer_item_currency_code: string
      customer_item_amount: number
      item_details: Prisma.JsonValue
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["orderItems"]>
    composites: {}
  }

  type OrderItemsGetPayload<S extends boolean | null | undefined | OrderItemsDefaultArgs> = $Result.GetResult<Prisma.$OrderItemsPayload, S>

  type OrderItemsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemsCountAggregateInputType | true
    }

  export interface OrderItemsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItems'], meta: { name: 'OrderItems' } }
    /**
     * Find zero or one OrderItems that matches the filter.
     * @param {OrderItemsFindUniqueArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemsFindUniqueArgs>(args: SelectSubset<T, OrderItemsFindUniqueArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItems that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemsFindUniqueOrThrowArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemsFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindFirstArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemsFindFirstArgs>(args?: SelectSubset<T, OrderItemsFindFirstArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItems that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindFirstOrThrowArgs} args - Arguments to find a OrderItems
     * @example
     * // Get one OrderItems
     * const orderItems = await prisma.orderItems.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemsFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemsFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItems.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItems.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemsWithIdOnly = await prisma.orderItems.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemsFindManyArgs>(args?: SelectSubset<T, OrderItemsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItems.
     * @param {OrderItemsCreateArgs} args - Arguments to create a OrderItems.
     * @example
     * // Create one OrderItems
     * const OrderItems = await prisma.orderItems.create({
     *   data: {
     *     // ... data to create a OrderItems
     *   }
     * })
     * 
     */
    create<T extends OrderItemsCreateArgs>(args: SelectSubset<T, OrderItemsCreateArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemsCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItems = await prisma.orderItems.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemsCreateManyArgs>(args?: SelectSubset<T, OrderItemsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderItems and returns the data saved in the database.
     * @param {OrderItemsCreateManyAndReturnArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItems = await prisma.orderItems.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderItems and only return the `id`
     * const orderItemsWithIdOnly = await prisma.orderItems.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderItemsCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderItemsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a OrderItems.
     * @param {OrderItemsDeleteArgs} args - Arguments to delete one OrderItems.
     * @example
     * // Delete one OrderItems
     * const OrderItems = await prisma.orderItems.delete({
     *   where: {
     *     // ... filter to delete one OrderItems
     *   }
     * })
     * 
     */
    delete<T extends OrderItemsDeleteArgs>(args: SelectSubset<T, OrderItemsDeleteArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItems.
     * @param {OrderItemsUpdateArgs} args - Arguments to update one OrderItems.
     * @example
     * // Update one OrderItems
     * const orderItems = await prisma.orderItems.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemsUpdateArgs>(args: SelectSubset<T, OrderItemsUpdateArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemsDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItems.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemsDeleteManyArgs>(args?: SelectSubset<T, OrderItemsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItems = await prisma.orderItems.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemsUpdateManyArgs>(args: SelectSubset<T, OrderItemsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItems.
     * @param {OrderItemsUpsertArgs} args - Arguments to update or create a OrderItems.
     * @example
     * // Update or create a OrderItems
     * const orderItems = await prisma.orderItems.upsert({
     *   create: {
     *     // ... data to create a OrderItems
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItems we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemsUpsertArgs>(args: SelectSubset<T, OrderItemsUpsertArgs<ExtArgs>>): Prisma__OrderItemsClient<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItems.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemsCountArgs>(
      args?: Subset<T, OrderItemsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemsAggregateArgs>(args: Subset<T, OrderItemsAggregateArgs>): Prisma.PrismaPromise<GetOrderItemsAggregateType<T>>

    /**
     * Group by OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemsGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItems model
   */
  readonly fields: OrderItemsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItems.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customers<T extends CustomersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomersDefaultArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    orders<T extends OrdersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdersDefaultArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItems model
   */ 
  interface OrderItemsFieldRefs {
    readonly id: FieldRef<"OrderItems", 'Int'>
    readonly store_id: FieldRef<"OrderItems", 'Int'>
    readonly affiliate_id: FieldRef<"OrderItems", 'Int'>
    readonly customer_id: FieldRef<"OrderItems", 'Int'>
    readonly order_id: FieldRef<"OrderItems", 'Int'>
    readonly item_id: FieldRef<"OrderItems", 'BigInt'>
    readonly product_id: FieldRef<"OrderItems", 'BigInt'>
    readonly variant_id: FieldRef<"OrderItems", 'BigInt'>
    readonly product_title: FieldRef<"OrderItems", 'String'>
    readonly variant_title: FieldRef<"OrderItems", 'String'>
    readonly quantity: FieldRef<"OrderItems", 'Int'>
    readonly shop_item_currency_code: FieldRef<"OrderItems", 'String'>
    readonly shop_item_amount: FieldRef<"OrderItems", 'Float'>
    readonly customer_item_currency_code: FieldRef<"OrderItems", 'String'>
    readonly customer_item_amount: FieldRef<"OrderItems", 'Float'>
    readonly item_details: FieldRef<"OrderItems", 'Json'>
    readonly created_at: FieldRef<"OrderItems", 'BigInt'>
    readonly updated_at: FieldRef<"OrderItems", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * OrderItems findUnique
   */
  export type OrderItemsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems findUniqueOrThrow
   */
  export type OrderItemsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems findFirst
   */
  export type OrderItemsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * OrderItems findFirstOrThrow
   */
  export type OrderItemsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * OrderItems findMany
   */
  export type OrderItemsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * OrderItems create
   */
  export type OrderItemsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItems.
     */
    data: XOR<OrderItemsCreateInput, OrderItemsUncheckedCreateInput>
  }

  /**
   * OrderItems createMany
   */
  export type OrderItemsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemsCreateManyInput | OrderItemsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItems createManyAndReturn
   */
  export type OrderItemsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemsCreateManyInput | OrderItemsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderItems update
   */
  export type OrderItemsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItems.
     */
    data: XOR<OrderItemsUpdateInput, OrderItemsUncheckedUpdateInput>
    /**
     * Choose, which OrderItems to update.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems updateMany
   */
  export type OrderItemsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemsWhereInput
  }

  /**
   * OrderItems upsert
   */
  export type OrderItemsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItems to update in case it exists.
     */
    where: OrderItemsWhereUniqueInput
    /**
     * In case the OrderItems found by the `where` argument doesn't exist, create a new OrderItems with this data.
     */
    create: XOR<OrderItemsCreateInput, OrderItemsUncheckedCreateInput>
    /**
     * In case the OrderItems was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemsUpdateInput, OrderItemsUncheckedUpdateInput>
  }

  /**
   * OrderItems delete
   */
  export type OrderItemsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    /**
     * Filter which OrderItems to delete.
     */
    where: OrderItemsWhereUniqueInput
  }

  /**
   * OrderItems deleteMany
   */
  export type OrderItemsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemsWhereInput
  }

  /**
   * OrderItems without action
   */
  export type OrderItemsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
  }


  /**
   * Model Commissions
   */

  export type AggregateCommissions = {
    _count: CommissionsCountAggregateOutputType | null
    _avg: CommissionsAvgAggregateOutputType | null
    _sum: CommissionsSumAggregateOutputType | null
    _min: CommissionsMinAggregateOutputType | null
    _max: CommissionsMaxAggregateOutputType | null
  }

  export type CommissionsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    order_id: number | null
    amount: number | null
    review_on: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type CommissionsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    order_id: number | null
    amount: number | null
    review_on: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type CommissionsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    order_id: number | null
    currency_code: string | null
    amount: number | null
    status: $Enums.StatusType | null
    approval_mode: $Enums.ApprovalModeType | null
    review_on: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type CommissionsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    order_id: number | null
    currency_code: string | null
    amount: number | null
    status: $Enums.StatusType | null
    approval_mode: $Enums.ApprovalModeType | null
    review_on: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type CommissionsCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    order_id: number
    currency_code: number
    amount: number
    status: number
    approval_mode: number
    review_on: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CommissionsAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    order_id?: true
    amount?: true
    review_on?: true
    created_at?: true
    updated_at?: true
  }

  export type CommissionsSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    order_id?: true
    amount?: true
    review_on?: true
    created_at?: true
    updated_at?: true
  }

  export type CommissionsMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    order_id?: true
    currency_code?: true
    amount?: true
    status?: true
    approval_mode?: true
    review_on?: true
    created_at?: true
    updated_at?: true
  }

  export type CommissionsMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    order_id?: true
    currency_code?: true
    amount?: true
    status?: true
    approval_mode?: true
    review_on?: true
    created_at?: true
    updated_at?: true
  }

  export type CommissionsCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    order_id?: true
    currency_code?: true
    amount?: true
    status?: true
    approval_mode?: true
    review_on?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CommissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commissions to aggregate.
     */
    where?: CommissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionsOrderByWithRelationInput | CommissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Commissions
    **/
    _count?: true | CommissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommissionsMaxAggregateInputType
  }

  export type GetCommissionsAggregateType<T extends CommissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCommissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommissions[P]>
      : GetScalarType<T[P], AggregateCommissions[P]>
  }




  export type CommissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommissionsWhereInput
    orderBy?: CommissionsOrderByWithAggregationInput | CommissionsOrderByWithAggregationInput[]
    by: CommissionsScalarFieldEnum[] | CommissionsScalarFieldEnum
    having?: CommissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommissionsCountAggregateInputType | true
    _avg?: CommissionsAvgAggregateInputType
    _sum?: CommissionsSumAggregateInputType
    _min?: CommissionsMinAggregateInputType
    _max?: CommissionsMaxAggregateInputType
  }

  export type CommissionsGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    order_id: number
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode: $Enums.ApprovalModeType | null
    review_on: bigint | null
    created_at: bigint
    updated_at: bigint
    _count: CommissionsCountAggregateOutputType | null
    _avg: CommissionsAvgAggregateOutputType | null
    _sum: CommissionsSumAggregateOutputType | null
    _min: CommissionsMinAggregateOutputType | null
    _max: CommissionsMaxAggregateOutputType | null
  }

  type GetCommissionsGroupByPayload<T extends CommissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommissionsGroupByOutputType[P]>
            : GetScalarType<T[P], CommissionsGroupByOutputType[P]>
        }
      >
    >


  export type CommissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    order_id?: boolean
    currency_code?: boolean
    amount?: boolean
    status?: boolean
    approval_mode?: boolean
    review_on?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    orders?: boolean | OrdersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissions"]>

  export type CommissionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    order_id?: boolean
    currency_code?: boolean
    amount?: boolean
    status?: boolean
    approval_mode?: boolean
    review_on?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    orders?: boolean | OrdersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commissions"]>

  export type CommissionsSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    order_id?: boolean
    currency_code?: boolean
    amount?: boolean
    status?: boolean
    approval_mode?: boolean
    review_on?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CommissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    orders?: boolean | OrdersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type CommissionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    orders?: boolean | OrdersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $CommissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Commissions"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      orders: Prisma.$OrdersPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      order_id: number
      currency_code: string
      amount: number
      status: $Enums.StatusType
      approval_mode: $Enums.ApprovalModeType | null
      review_on: bigint | null
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["commissions"]>
    composites: {}
  }

  type CommissionsGetPayload<S extends boolean | null | undefined | CommissionsDefaultArgs> = $Result.GetResult<Prisma.$CommissionsPayload, S>

  type CommissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommissionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommissionsCountAggregateInputType | true
    }

  export interface CommissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Commissions'], meta: { name: 'Commissions' } }
    /**
     * Find zero or one Commissions that matches the filter.
     * @param {CommissionsFindUniqueArgs} args - Arguments to find a Commissions
     * @example
     * // Get one Commissions
     * const commissions = await prisma.commissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommissionsFindUniqueArgs>(args: SelectSubset<T, CommissionsFindUniqueArgs<ExtArgs>>): Prisma__CommissionsClient<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Commissions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommissionsFindUniqueOrThrowArgs} args - Arguments to find a Commissions
     * @example
     * // Get one Commissions
     * const commissions = await prisma.commissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, CommissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommissionsClient<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Commissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionsFindFirstArgs} args - Arguments to find a Commissions
     * @example
     * // Get one Commissions
     * const commissions = await prisma.commissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommissionsFindFirstArgs>(args?: SelectSubset<T, CommissionsFindFirstArgs<ExtArgs>>): Prisma__CommissionsClient<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Commissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionsFindFirstOrThrowArgs} args - Arguments to find a Commissions
     * @example
     * // Get one Commissions
     * const commissions = await prisma.commissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, CommissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommissionsClient<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Commissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Commissions
     * const commissions = await prisma.commissions.findMany()
     * 
     * // Get first 10 Commissions
     * const commissions = await prisma.commissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commissionsWithIdOnly = await prisma.commissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommissionsFindManyArgs>(args?: SelectSubset<T, CommissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Commissions.
     * @param {CommissionsCreateArgs} args - Arguments to create a Commissions.
     * @example
     * // Create one Commissions
     * const Commissions = await prisma.commissions.create({
     *   data: {
     *     // ... data to create a Commissions
     *   }
     * })
     * 
     */
    create<T extends CommissionsCreateArgs>(args: SelectSubset<T, CommissionsCreateArgs<ExtArgs>>): Prisma__CommissionsClient<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Commissions.
     * @param {CommissionsCreateManyArgs} args - Arguments to create many Commissions.
     * @example
     * // Create many Commissions
     * const commissions = await prisma.commissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommissionsCreateManyArgs>(args?: SelectSubset<T, CommissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Commissions and returns the data saved in the database.
     * @param {CommissionsCreateManyAndReturnArgs} args - Arguments to create many Commissions.
     * @example
     * // Create many Commissions
     * const commissions = await prisma.commissions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Commissions and only return the `id`
     * const commissionsWithIdOnly = await prisma.commissions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommissionsCreateManyAndReturnArgs>(args?: SelectSubset<T, CommissionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Commissions.
     * @param {CommissionsDeleteArgs} args - Arguments to delete one Commissions.
     * @example
     * // Delete one Commissions
     * const Commissions = await prisma.commissions.delete({
     *   where: {
     *     // ... filter to delete one Commissions
     *   }
     * })
     * 
     */
    delete<T extends CommissionsDeleteArgs>(args: SelectSubset<T, CommissionsDeleteArgs<ExtArgs>>): Prisma__CommissionsClient<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Commissions.
     * @param {CommissionsUpdateArgs} args - Arguments to update one Commissions.
     * @example
     * // Update one Commissions
     * const commissions = await prisma.commissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommissionsUpdateArgs>(args: SelectSubset<T, CommissionsUpdateArgs<ExtArgs>>): Prisma__CommissionsClient<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Commissions.
     * @param {CommissionsDeleteManyArgs} args - Arguments to filter Commissions to delete.
     * @example
     * // Delete a few Commissions
     * const { count } = await prisma.commissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommissionsDeleteManyArgs>(args?: SelectSubset<T, CommissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Commissions
     * const commissions = await prisma.commissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommissionsUpdateManyArgs>(args: SelectSubset<T, CommissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Commissions.
     * @param {CommissionsUpsertArgs} args - Arguments to update or create a Commissions.
     * @example
     * // Update or create a Commissions
     * const commissions = await prisma.commissions.upsert({
     *   create: {
     *     // ... data to create a Commissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Commissions we want to update
     *   }
     * })
     */
    upsert<T extends CommissionsUpsertArgs>(args: SelectSubset<T, CommissionsUpsertArgs<ExtArgs>>): Prisma__CommissionsClient<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionsCountArgs} args - Arguments to filter Commissions to count.
     * @example
     * // Count the number of Commissions
     * const count = await prisma.commissions.count({
     *   where: {
     *     // ... the filter for the Commissions we want to count
     *   }
     * })
    **/
    count<T extends CommissionsCountArgs>(
      args?: Subset<T, CommissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommissionsAggregateArgs>(args: Subset<T, CommissionsAggregateArgs>): Prisma.PrismaPromise<GetCommissionsAggregateType<T>>

    /**
     * Group by Commissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommissionsGroupByArgs['orderBy'] }
        : { orderBy?: CommissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Commissions model
   */
  readonly fields: CommissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Commissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    orders<T extends OrdersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrdersDefaultArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Commissions model
   */ 
  interface CommissionsFieldRefs {
    readonly id: FieldRef<"Commissions", 'Int'>
    readonly store_id: FieldRef<"Commissions", 'Int'>
    readonly affiliate_id: FieldRef<"Commissions", 'Int'>
    readonly order_id: FieldRef<"Commissions", 'Int'>
    readonly currency_code: FieldRef<"Commissions", 'String'>
    readonly amount: FieldRef<"Commissions", 'Float'>
    readonly status: FieldRef<"Commissions", 'StatusType'>
    readonly approval_mode: FieldRef<"Commissions", 'ApprovalModeType'>
    readonly review_on: FieldRef<"Commissions", 'BigInt'>
    readonly created_at: FieldRef<"Commissions", 'BigInt'>
    readonly updated_at: FieldRef<"Commissions", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Commissions findUnique
   */
  export type CommissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    /**
     * Filter, which Commissions to fetch.
     */
    where: CommissionsWhereUniqueInput
  }

  /**
   * Commissions findUniqueOrThrow
   */
  export type CommissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    /**
     * Filter, which Commissions to fetch.
     */
    where: CommissionsWhereUniqueInput
  }

  /**
   * Commissions findFirst
   */
  export type CommissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    /**
     * Filter, which Commissions to fetch.
     */
    where?: CommissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionsOrderByWithRelationInput | CommissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commissions.
     */
    cursor?: CommissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commissions.
     */
    distinct?: CommissionsScalarFieldEnum | CommissionsScalarFieldEnum[]
  }

  /**
   * Commissions findFirstOrThrow
   */
  export type CommissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    /**
     * Filter, which Commissions to fetch.
     */
    where?: CommissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionsOrderByWithRelationInput | CommissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Commissions.
     */
    cursor?: CommissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Commissions.
     */
    distinct?: CommissionsScalarFieldEnum | CommissionsScalarFieldEnum[]
  }

  /**
   * Commissions findMany
   */
  export type CommissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    /**
     * Filter, which Commissions to fetch.
     */
    where?: CommissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Commissions to fetch.
     */
    orderBy?: CommissionsOrderByWithRelationInput | CommissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Commissions.
     */
    cursor?: CommissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Commissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Commissions.
     */
    skip?: number
    distinct?: CommissionsScalarFieldEnum | CommissionsScalarFieldEnum[]
  }

  /**
   * Commissions create
   */
  export type CommissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Commissions.
     */
    data: XOR<CommissionsCreateInput, CommissionsUncheckedCreateInput>
  }

  /**
   * Commissions createMany
   */
  export type CommissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Commissions.
     */
    data: CommissionsCreateManyInput | CommissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Commissions createManyAndReturn
   */
  export type CommissionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Commissions.
     */
    data: CommissionsCreateManyInput | CommissionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Commissions update
   */
  export type CommissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Commissions.
     */
    data: XOR<CommissionsUpdateInput, CommissionsUncheckedUpdateInput>
    /**
     * Choose, which Commissions to update.
     */
    where: CommissionsWhereUniqueInput
  }

  /**
   * Commissions updateMany
   */
  export type CommissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Commissions.
     */
    data: XOR<CommissionsUpdateManyMutationInput, CommissionsUncheckedUpdateManyInput>
    /**
     * Filter which Commissions to update
     */
    where?: CommissionsWhereInput
  }

  /**
   * Commissions upsert
   */
  export type CommissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Commissions to update in case it exists.
     */
    where: CommissionsWhereUniqueInput
    /**
     * In case the Commissions found by the `where` argument doesn't exist, create a new Commissions with this data.
     */
    create: XOR<CommissionsCreateInput, CommissionsUncheckedCreateInput>
    /**
     * In case the Commissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommissionsUpdateInput, CommissionsUncheckedUpdateInput>
  }

  /**
   * Commissions delete
   */
  export type CommissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    /**
     * Filter which Commissions to delete.
     */
    where: CommissionsWhereUniqueInput
  }

  /**
   * Commissions deleteMany
   */
  export type CommissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Commissions to delete
     */
    where?: CommissionsWhereInput
  }

  /**
   * Commissions without action
   */
  export type CommissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
  }


  /**
   * Model Payouts
   */

  export type AggregatePayouts = {
    _count: PayoutsCountAggregateOutputType | null
    _avg: PayoutsAvgAggregateOutputType | null
    _sum: PayoutsSumAggregateOutputType | null
    _min: PayoutsMinAggregateOutputType | null
    _max: PayoutsMaxAggregateOutputType | null
  }

  export type PayoutsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    amount: number | null
    created_at: number | null
    updated_at: number | null
    user_id: number | null
    job_id: number | null
  }

  export type PayoutsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    amount: number | null
    created_at: bigint | null
    updated_at: bigint | null
    user_id: bigint | null
    job_id: number | null
  }

  export type PayoutsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    transaction_id: string | null
    currency_code: string | null
    amount: number | null
    notes: string | null
    payment_method: $Enums.PaymentType | null
    status: $Enums.StatusType | null
    created_at: bigint | null
    updated_at: bigint | null
    user_id: bigint | null
    job_id: number | null
  }

  export type PayoutsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    transaction_id: string | null
    currency_code: string | null
    amount: number | null
    notes: string | null
    payment_method: $Enums.PaymentType | null
    status: $Enums.StatusType | null
    created_at: bigint | null
    updated_at: bigint | null
    user_id: bigint | null
    job_id: number | null
  }

  export type PayoutsCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    transaction_id: number
    currency_code: number
    amount: number
    notes: number
    payment_method: number
    payment_details: number
    status: number
    created_at: number
    updated_at: number
    user_id: number
    job_id: number
    _all: number
  }


  export type PayoutsAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    amount?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    job_id?: true
  }

  export type PayoutsSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    amount?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    job_id?: true
  }

  export type PayoutsMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    transaction_id?: true
    currency_code?: true
    amount?: true
    notes?: true
    payment_method?: true
    status?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    job_id?: true
  }

  export type PayoutsMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    transaction_id?: true
    currency_code?: true
    amount?: true
    notes?: true
    payment_method?: true
    status?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    job_id?: true
  }

  export type PayoutsCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    transaction_id?: true
    currency_code?: true
    amount?: true
    notes?: true
    payment_method?: true
    payment_details?: true
    status?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    job_id?: true
    _all?: true
  }

  export type PayoutsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payouts to aggregate.
     */
    where?: PayoutsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutsOrderByWithRelationInput | PayoutsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayoutsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payouts
    **/
    _count?: true | PayoutsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayoutsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayoutsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayoutsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayoutsMaxAggregateInputType
  }

  export type GetPayoutsAggregateType<T extends PayoutsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayouts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayouts[P]>
      : GetScalarType<T[P], AggregatePayouts[P]>
  }




  export type PayoutsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayoutsWhereInput
    orderBy?: PayoutsOrderByWithAggregationInput | PayoutsOrderByWithAggregationInput[]
    by: PayoutsScalarFieldEnum[] | PayoutsScalarFieldEnum
    having?: PayoutsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayoutsCountAggregateInputType | true
    _avg?: PayoutsAvgAggregateInputType
    _sum?: PayoutsSumAggregateInputType
    _min?: PayoutsMinAggregateInputType
    _max?: PayoutsMaxAggregateInputType
  }

  export type PayoutsGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    transaction_id: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonValue
    status: $Enums.StatusType
    created_at: bigint
    updated_at: bigint
    user_id: bigint | null
    job_id: number
    _count: PayoutsCountAggregateOutputType | null
    _avg: PayoutsAvgAggregateOutputType | null
    _sum: PayoutsSumAggregateOutputType | null
    _min: PayoutsMinAggregateOutputType | null
    _max: PayoutsMaxAggregateOutputType | null
  }

  type GetPayoutsGroupByPayload<T extends PayoutsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayoutsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayoutsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayoutsGroupByOutputType[P]>
            : GetScalarType<T[P], PayoutsGroupByOutputType[P]>
        }
      >
    >


  export type PayoutsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    transaction_id?: boolean
    currency_code?: boolean
    amount?: boolean
    notes?: boolean
    payment_method?: boolean
    payment_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    job_id?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    jobs?: boolean | JobsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    activity_log?: boolean | Payouts$activity_logArgs<ExtArgs>
    _count?: boolean | PayoutsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payouts"]>

  export type PayoutsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    transaction_id?: boolean
    currency_code?: boolean
    amount?: boolean
    notes?: boolean
    payment_method?: boolean
    payment_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    job_id?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    jobs?: boolean | JobsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payouts"]>

  export type PayoutsSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    transaction_id?: boolean
    currency_code?: boolean
    amount?: boolean
    notes?: boolean
    payment_method?: boolean
    payment_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    job_id?: boolean
  }

  export type PayoutsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    jobs?: boolean | JobsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    activity_log?: boolean | Payouts$activity_logArgs<ExtArgs>
    _count?: boolean | PayoutsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayoutsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    jobs?: boolean | JobsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $PayoutsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payouts"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      jobs: Prisma.$JobsPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
      activity_log: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      transaction_id: string
      currency_code: string
      amount: number
      notes: string
      payment_method: $Enums.PaymentType
      payment_details: Prisma.JsonValue
      status: $Enums.StatusType
      created_at: bigint
      updated_at: bigint
      user_id: bigint | null
      job_id: number
    }, ExtArgs["result"]["payouts"]>
    composites: {}
  }

  type PayoutsGetPayload<S extends boolean | null | undefined | PayoutsDefaultArgs> = $Result.GetResult<Prisma.$PayoutsPayload, S>

  type PayoutsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PayoutsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PayoutsCountAggregateInputType | true
    }

  export interface PayoutsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payouts'], meta: { name: 'Payouts' } }
    /**
     * Find zero or one Payouts that matches the filter.
     * @param {PayoutsFindUniqueArgs} args - Arguments to find a Payouts
     * @example
     * // Get one Payouts
     * const payouts = await prisma.payouts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayoutsFindUniqueArgs>(args: SelectSubset<T, PayoutsFindUniqueArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payouts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PayoutsFindUniqueOrThrowArgs} args - Arguments to find a Payouts
     * @example
     * // Get one Payouts
     * const payouts = await prisma.payouts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayoutsFindUniqueOrThrowArgs>(args: SelectSubset<T, PayoutsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutsFindFirstArgs} args - Arguments to find a Payouts
     * @example
     * // Get one Payouts
     * const payouts = await prisma.payouts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayoutsFindFirstArgs>(args?: SelectSubset<T, PayoutsFindFirstArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payouts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutsFindFirstOrThrowArgs} args - Arguments to find a Payouts
     * @example
     * // Get one Payouts
     * const payouts = await prisma.payouts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayoutsFindFirstOrThrowArgs>(args?: SelectSubset<T, PayoutsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payouts
     * const payouts = await prisma.payouts.findMany()
     * 
     * // Get first 10 Payouts
     * const payouts = await prisma.payouts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payoutsWithIdOnly = await prisma.payouts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayoutsFindManyArgs>(args?: SelectSubset<T, PayoutsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payouts.
     * @param {PayoutsCreateArgs} args - Arguments to create a Payouts.
     * @example
     * // Create one Payouts
     * const Payouts = await prisma.payouts.create({
     *   data: {
     *     // ... data to create a Payouts
     *   }
     * })
     * 
     */
    create<T extends PayoutsCreateArgs>(args: SelectSubset<T, PayoutsCreateArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payouts.
     * @param {PayoutsCreateManyArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payouts = await prisma.payouts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayoutsCreateManyArgs>(args?: SelectSubset<T, PayoutsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payouts and returns the data saved in the database.
     * @param {PayoutsCreateManyAndReturnArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payouts = await prisma.payouts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payouts and only return the `id`
     * const payoutsWithIdOnly = await prisma.payouts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayoutsCreateManyAndReturnArgs>(args?: SelectSubset<T, PayoutsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payouts.
     * @param {PayoutsDeleteArgs} args - Arguments to delete one Payouts.
     * @example
     * // Delete one Payouts
     * const Payouts = await prisma.payouts.delete({
     *   where: {
     *     // ... filter to delete one Payouts
     *   }
     * })
     * 
     */
    delete<T extends PayoutsDeleteArgs>(args: SelectSubset<T, PayoutsDeleteArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payouts.
     * @param {PayoutsUpdateArgs} args - Arguments to update one Payouts.
     * @example
     * // Update one Payouts
     * const payouts = await prisma.payouts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayoutsUpdateArgs>(args: SelectSubset<T, PayoutsUpdateArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payouts.
     * @param {PayoutsDeleteManyArgs} args - Arguments to filter Payouts to delete.
     * @example
     * // Delete a few Payouts
     * const { count } = await prisma.payouts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayoutsDeleteManyArgs>(args?: SelectSubset<T, PayoutsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payouts
     * const payouts = await prisma.payouts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayoutsUpdateManyArgs>(args: SelectSubset<T, PayoutsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payouts.
     * @param {PayoutsUpsertArgs} args - Arguments to update or create a Payouts.
     * @example
     * // Update or create a Payouts
     * const payouts = await prisma.payouts.upsert({
     *   create: {
     *     // ... data to create a Payouts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payouts we want to update
     *   }
     * })
     */
    upsert<T extends PayoutsUpsertArgs>(args: SelectSubset<T, PayoutsUpsertArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutsCountArgs} args - Arguments to filter Payouts to count.
     * @example
     * // Count the number of Payouts
     * const count = await prisma.payouts.count({
     *   where: {
     *     // ... the filter for the Payouts we want to count
     *   }
     * })
    **/
    count<T extends PayoutsCountArgs>(
      args?: Subset<T, PayoutsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayoutsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayoutsAggregateArgs>(args: Subset<T, PayoutsAggregateArgs>): Prisma.PrismaPromise<GetPayoutsAggregateType<T>>

    /**
     * Group by Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayoutsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayoutsGroupByArgs['orderBy'] }
        : { orderBy?: PayoutsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayoutsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayoutsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payouts model
   */
  readonly fields: PayoutsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payouts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayoutsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    jobs<T extends JobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobsDefaultArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activity_log<T extends Payouts$activity_logArgs<ExtArgs> = {}>(args?: Subset<T, Payouts$activity_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payouts model
   */ 
  interface PayoutsFieldRefs {
    readonly id: FieldRef<"Payouts", 'Int'>
    readonly store_id: FieldRef<"Payouts", 'Int'>
    readonly affiliate_id: FieldRef<"Payouts", 'Int'>
    readonly transaction_id: FieldRef<"Payouts", 'String'>
    readonly currency_code: FieldRef<"Payouts", 'String'>
    readonly amount: FieldRef<"Payouts", 'Float'>
    readonly notes: FieldRef<"Payouts", 'String'>
    readonly payment_method: FieldRef<"Payouts", 'PaymentType'>
    readonly payment_details: FieldRef<"Payouts", 'Json'>
    readonly status: FieldRef<"Payouts", 'StatusType'>
    readonly created_at: FieldRef<"Payouts", 'BigInt'>
    readonly updated_at: FieldRef<"Payouts", 'BigInt'>
    readonly user_id: FieldRef<"Payouts", 'BigInt'>
    readonly job_id: FieldRef<"Payouts", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Payouts findUnique
   */
  export type PayoutsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where: PayoutsWhereUniqueInput
  }

  /**
   * Payouts findUniqueOrThrow
   */
  export type PayoutsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where: PayoutsWhereUniqueInput
  }

  /**
   * Payouts findFirst
   */
  export type PayoutsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where?: PayoutsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutsOrderByWithRelationInput | PayoutsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutsScalarFieldEnum | PayoutsScalarFieldEnum[]
  }

  /**
   * Payouts findFirstOrThrow
   */
  export type PayoutsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where?: PayoutsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutsOrderByWithRelationInput | PayoutsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payouts.
     */
    cursor?: PayoutsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payouts.
     */
    distinct?: PayoutsScalarFieldEnum | PayoutsScalarFieldEnum[]
  }

  /**
   * Payouts findMany
   */
  export type PayoutsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    /**
     * Filter, which Payouts to fetch.
     */
    where?: PayoutsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payouts to fetch.
     */
    orderBy?: PayoutsOrderByWithRelationInput | PayoutsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payouts.
     */
    cursor?: PayoutsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payouts.
     */
    skip?: number
    distinct?: PayoutsScalarFieldEnum | PayoutsScalarFieldEnum[]
  }

  /**
   * Payouts create
   */
  export type PayoutsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    /**
     * The data needed to create a Payouts.
     */
    data: XOR<PayoutsCreateInput, PayoutsUncheckedCreateInput>
  }

  /**
   * Payouts createMany
   */
  export type PayoutsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payouts.
     */
    data: PayoutsCreateManyInput | PayoutsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payouts createManyAndReturn
   */
  export type PayoutsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payouts.
     */
    data: PayoutsCreateManyInput | PayoutsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payouts update
   */
  export type PayoutsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    /**
     * The data needed to update a Payouts.
     */
    data: XOR<PayoutsUpdateInput, PayoutsUncheckedUpdateInput>
    /**
     * Choose, which Payouts to update.
     */
    where: PayoutsWhereUniqueInput
  }

  /**
   * Payouts updateMany
   */
  export type PayoutsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payouts.
     */
    data: XOR<PayoutsUpdateManyMutationInput, PayoutsUncheckedUpdateManyInput>
    /**
     * Filter which Payouts to update
     */
    where?: PayoutsWhereInput
  }

  /**
   * Payouts upsert
   */
  export type PayoutsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    /**
     * The filter to search for the Payouts to update in case it exists.
     */
    where: PayoutsWhereUniqueInput
    /**
     * In case the Payouts found by the `where` argument doesn't exist, create a new Payouts with this data.
     */
    create: XOR<PayoutsCreateInput, PayoutsUncheckedCreateInput>
    /**
     * In case the Payouts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayoutsUpdateInput, PayoutsUncheckedUpdateInput>
  }

  /**
   * Payouts delete
   */
  export type PayoutsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    /**
     * Filter which Payouts to delete.
     */
    where: PayoutsWhereUniqueInput
  }

  /**
   * Payouts deleteMany
   */
  export type PayoutsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payouts to delete
     */
    where?: PayoutsWhereInput
  }

  /**
   * Payouts.activity_log
   */
  export type Payouts$activity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Payouts without action
   */
  export type PayoutsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
  }


  /**
   * Model Bonus
   */

  export type AggregateBonus = {
    _count: BonusCountAggregateOutputType | null
    _avg: BonusAvgAggregateOutputType | null
    _sum: BonusSumAggregateOutputType | null
    _min: BonusMinAggregateOutputType | null
    _max: BonusMaxAggregateOutputType | null
  }

  export type BonusAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    target_goal: number | null
    bonus_rate: number | null
    begin_datetime: number | null
    expire_datetime: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type BonusSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    target_goal: number | null
    bonus_rate: number | null
    begin_datetime: bigint | null
    expire_datetime: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type BonusMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    title: string | null
    description: string | null
    bonus_associate: $Enums.BonusType | null
    target_type: $Enums.TierType | null
    target_goal: number | null
    bonus_type: $Enums.EarningType | null
    bonus_rate: number | null
    status: $Enums.StatusType | null
    begin_datetime: bigint | null
    expire_datetime: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type BonusMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    title: string | null
    description: string | null
    bonus_associate: $Enums.BonusType | null
    target_type: $Enums.TierType | null
    target_goal: number | null
    bonus_type: $Enums.EarningType | null
    bonus_rate: number | null
    status: $Enums.StatusType | null
    begin_datetime: bigint | null
    expire_datetime: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type BonusCountAggregateOutputType = {
    id: number
    store_id: number
    title: number
    description: number
    bonus_associate: number
    target_type: number
    target_goal: number
    bonus_type: number
    bonus_rate: number
    status: number
    begin_datetime: number
    expire_datetime: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BonusAvgAggregateInputType = {
    id?: true
    store_id?: true
    target_goal?: true
    bonus_rate?: true
    begin_datetime?: true
    expire_datetime?: true
    created_at?: true
    updated_at?: true
  }

  export type BonusSumAggregateInputType = {
    id?: true
    store_id?: true
    target_goal?: true
    bonus_rate?: true
    begin_datetime?: true
    expire_datetime?: true
    created_at?: true
    updated_at?: true
  }

  export type BonusMinAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    bonus_associate?: true
    target_type?: true
    target_goal?: true
    bonus_type?: true
    bonus_rate?: true
    status?: true
    begin_datetime?: true
    expire_datetime?: true
    created_at?: true
    updated_at?: true
  }

  export type BonusMaxAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    bonus_associate?: true
    target_type?: true
    target_goal?: true
    bonus_type?: true
    bonus_rate?: true
    status?: true
    begin_datetime?: true
    expire_datetime?: true
    created_at?: true
    updated_at?: true
  }

  export type BonusCountAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    bonus_associate?: true
    target_type?: true
    target_goal?: true
    bonus_type?: true
    bonus_rate?: true
    status?: true
    begin_datetime?: true
    expire_datetime?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonus to aggregate.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bonuses
    **/
    _count?: true | BonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BonusMaxAggregateInputType
  }

  export type GetBonusAggregateType<T extends BonusAggregateArgs> = {
        [P in keyof T & keyof AggregateBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBonus[P]>
      : GetScalarType<T[P], AggregateBonus[P]>
  }




  export type BonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BonusWhereInput
    orderBy?: BonusOrderByWithAggregationInput | BonusOrderByWithAggregationInput[]
    by: BonusScalarFieldEnum[] | BonusScalarFieldEnum
    having?: BonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BonusCountAggregateInputType | true
    _avg?: BonusAvgAggregateInputType
    _sum?: BonusSumAggregateInputType
    _min?: BonusMinAggregateInputType
    _max?: BonusMaxAggregateInputType
  }

  export type BonusGroupByOutputType = {
    id: number
    store_id: number
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint
    expire_datetime: bigint
    created_at: bigint
    updated_at: bigint
    _count: BonusCountAggregateOutputType | null
    _avg: BonusAvgAggregateOutputType | null
    _sum: BonusSumAggregateOutputType | null
    _min: BonusMinAggregateOutputType | null
    _max: BonusMaxAggregateOutputType | null
  }

  type GetBonusGroupByPayload<T extends BonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BonusGroupByOutputType[P]>
            : GetScalarType<T[P], BonusGroupByOutputType[P]>
        }
      >
    >


  export type BonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    bonus_associate?: boolean
    target_type?: boolean
    target_goal?: boolean
    bonus_type?: boolean
    bonus_rate?: boolean
    status?: boolean
    begin_datetime?: boolean
    expire_datetime?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate_bonus?: boolean | Bonus$affiliate_bonusArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    program_bonus?: boolean | Bonus$program_bonusArgs<ExtArgs>
    _count?: boolean | BonusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bonus"]>

  export type BonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    bonus_associate?: boolean
    target_type?: boolean
    target_goal?: boolean
    bonus_type?: boolean
    bonus_rate?: boolean
    status?: boolean
    begin_datetime?: boolean
    expire_datetime?: boolean
    created_at?: boolean
    updated_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bonus"]>

  export type BonusSelectScalar = {
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    bonus_associate?: boolean
    target_type?: boolean
    target_goal?: boolean
    bonus_type?: boolean
    bonus_rate?: boolean
    status?: boolean
    begin_datetime?: boolean
    expire_datetime?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_bonus?: boolean | Bonus$affiliate_bonusArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    program_bonus?: boolean | Bonus$program_bonusArgs<ExtArgs>
    _count?: boolean | BonusCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $BonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bonus"
    objects: {
      affiliate_bonus: Prisma.$AffiliateBonusPayload<ExtArgs>[]
      stores: Prisma.$StoresPayload<ExtArgs>
      program_bonus: Prisma.$ProgramBonusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      title: string
      description: string
      bonus_associate: $Enums.BonusType
      target_type: $Enums.TierType
      target_goal: number
      bonus_type: $Enums.EarningType
      bonus_rate: number
      status: $Enums.StatusType
      begin_datetime: bigint
      expire_datetime: bigint
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["bonus"]>
    composites: {}
  }

  type BonusGetPayload<S extends boolean | null | undefined | BonusDefaultArgs> = $Result.GetResult<Prisma.$BonusPayload, S>

  type BonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BonusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BonusCountAggregateInputType | true
    }

  export interface BonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bonus'], meta: { name: 'Bonus' } }
    /**
     * Find zero or one Bonus that matches the filter.
     * @param {BonusFindUniqueArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BonusFindUniqueArgs>(args: SelectSubset<T, BonusFindUniqueArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bonus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BonusFindUniqueOrThrowArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BonusFindUniqueOrThrowArgs>(args: SelectSubset<T, BonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindFirstArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BonusFindFirstArgs>(args?: SelectSubset<T, BonusFindFirstArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindFirstOrThrowArgs} args - Arguments to find a Bonus
     * @example
     * // Get one Bonus
     * const bonus = await prisma.bonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BonusFindFirstOrThrowArgs>(args?: SelectSubset<T, BonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bonuses
     * const bonuses = await prisma.bonus.findMany()
     * 
     * // Get first 10 Bonuses
     * const bonuses = await prisma.bonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bonusWithIdOnly = await prisma.bonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BonusFindManyArgs>(args?: SelectSubset<T, BonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bonus.
     * @param {BonusCreateArgs} args - Arguments to create a Bonus.
     * @example
     * // Create one Bonus
     * const Bonus = await prisma.bonus.create({
     *   data: {
     *     // ... data to create a Bonus
     *   }
     * })
     * 
     */
    create<T extends BonusCreateArgs>(args: SelectSubset<T, BonusCreateArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bonuses.
     * @param {BonusCreateManyArgs} args - Arguments to create many Bonuses.
     * @example
     * // Create many Bonuses
     * const bonus = await prisma.bonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BonusCreateManyArgs>(args?: SelectSubset<T, BonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bonuses and returns the data saved in the database.
     * @param {BonusCreateManyAndReturnArgs} args - Arguments to create many Bonuses.
     * @example
     * // Create many Bonuses
     * const bonus = await prisma.bonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bonuses and only return the `id`
     * const bonusWithIdOnly = await prisma.bonus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BonusCreateManyAndReturnArgs>(args?: SelectSubset<T, BonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bonus.
     * @param {BonusDeleteArgs} args - Arguments to delete one Bonus.
     * @example
     * // Delete one Bonus
     * const Bonus = await prisma.bonus.delete({
     *   where: {
     *     // ... filter to delete one Bonus
     *   }
     * })
     * 
     */
    delete<T extends BonusDeleteArgs>(args: SelectSubset<T, BonusDeleteArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bonus.
     * @param {BonusUpdateArgs} args - Arguments to update one Bonus.
     * @example
     * // Update one Bonus
     * const bonus = await prisma.bonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BonusUpdateArgs>(args: SelectSubset<T, BonusUpdateArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bonuses.
     * @param {BonusDeleteManyArgs} args - Arguments to filter Bonuses to delete.
     * @example
     * // Delete a few Bonuses
     * const { count } = await prisma.bonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BonusDeleteManyArgs>(args?: SelectSubset<T, BonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bonuses
     * const bonus = await prisma.bonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BonusUpdateManyArgs>(args: SelectSubset<T, BonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bonus.
     * @param {BonusUpsertArgs} args - Arguments to update or create a Bonus.
     * @example
     * // Update or create a Bonus
     * const bonus = await prisma.bonus.upsert({
     *   create: {
     *     // ... data to create a Bonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bonus we want to update
     *   }
     * })
     */
    upsert<T extends BonusUpsertArgs>(args: SelectSubset<T, BonusUpsertArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusCountArgs} args - Arguments to filter Bonuses to count.
     * @example
     * // Count the number of Bonuses
     * const count = await prisma.bonus.count({
     *   where: {
     *     // ... the filter for the Bonuses we want to count
     *   }
     * })
    **/
    count<T extends BonusCountArgs>(
      args?: Subset<T, BonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BonusAggregateArgs>(args: Subset<T, BonusAggregateArgs>): Prisma.PrismaPromise<GetBonusAggregateType<T>>

    /**
     * Group by Bonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BonusGroupByArgs['orderBy'] }
        : { orderBy?: BonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bonus model
   */
  readonly fields: BonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate_bonus<T extends Bonus$affiliate_bonusArgs<ExtArgs> = {}>(args?: Subset<T, Bonus$affiliate_bonusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "findMany"> | Null>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    program_bonus<T extends Bonus$program_bonusArgs<ExtArgs> = {}>(args?: Subset<T, Bonus$program_bonusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bonus model
   */ 
  interface BonusFieldRefs {
    readonly id: FieldRef<"Bonus", 'Int'>
    readonly store_id: FieldRef<"Bonus", 'Int'>
    readonly title: FieldRef<"Bonus", 'String'>
    readonly description: FieldRef<"Bonus", 'String'>
    readonly bonus_associate: FieldRef<"Bonus", 'BonusType'>
    readonly target_type: FieldRef<"Bonus", 'TierType'>
    readonly target_goal: FieldRef<"Bonus", 'Float'>
    readonly bonus_type: FieldRef<"Bonus", 'EarningType'>
    readonly bonus_rate: FieldRef<"Bonus", 'Float'>
    readonly status: FieldRef<"Bonus", 'StatusType'>
    readonly begin_datetime: FieldRef<"Bonus", 'BigInt'>
    readonly expire_datetime: FieldRef<"Bonus", 'BigInt'>
    readonly created_at: FieldRef<"Bonus", 'BigInt'>
    readonly updated_at: FieldRef<"Bonus", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Bonus findUnique
   */
  export type BonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus findUniqueOrThrow
   */
  export type BonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus findFirst
   */
  export type BonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonuses.
     */
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus findFirstOrThrow
   */
  export type BonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonus to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bonuses.
     */
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus findMany
   */
  export type BonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter, which Bonuses to fetch.
     */
    where?: BonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bonuses to fetch.
     */
    orderBy?: BonusOrderByWithRelationInput | BonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bonuses.
     */
    cursor?: BonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bonuses.
     */
    skip?: number
    distinct?: BonusScalarFieldEnum | BonusScalarFieldEnum[]
  }

  /**
   * Bonus create
   */
  export type BonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The data needed to create a Bonus.
     */
    data: XOR<BonusCreateInput, BonusUncheckedCreateInput>
  }

  /**
   * Bonus createMany
   */
  export type BonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bonuses.
     */
    data: BonusCreateManyInput | BonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bonus createManyAndReturn
   */
  export type BonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bonuses.
     */
    data: BonusCreateManyInput | BonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bonus update
   */
  export type BonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The data needed to update a Bonus.
     */
    data: XOR<BonusUpdateInput, BonusUncheckedUpdateInput>
    /**
     * Choose, which Bonus to update.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus updateMany
   */
  export type BonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bonuses.
     */
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyInput>
    /**
     * Filter which Bonuses to update
     */
    where?: BonusWhereInput
  }

  /**
   * Bonus upsert
   */
  export type BonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * The filter to search for the Bonus to update in case it exists.
     */
    where: BonusWhereUniqueInput
    /**
     * In case the Bonus found by the `where` argument doesn't exist, create a new Bonus with this data.
     */
    create: XOR<BonusCreateInput, BonusUncheckedCreateInput>
    /**
     * In case the Bonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BonusUpdateInput, BonusUncheckedUpdateInput>
  }

  /**
   * Bonus delete
   */
  export type BonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
    /**
     * Filter which Bonus to delete.
     */
    where: BonusWhereUniqueInput
  }

  /**
   * Bonus deleteMany
   */
  export type BonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bonuses to delete
     */
    where?: BonusWhereInput
  }

  /**
   * Bonus.affiliate_bonus
   */
  export type Bonus$affiliate_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    where?: AffiliateBonusWhereInput
    orderBy?: AffiliateBonusOrderByWithRelationInput | AffiliateBonusOrderByWithRelationInput[]
    cursor?: AffiliateBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateBonusScalarFieldEnum | AffiliateBonusScalarFieldEnum[]
  }

  /**
   * Bonus.program_bonus
   */
  export type Bonus$program_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    where?: ProgramBonusWhereInput
    orderBy?: ProgramBonusOrderByWithRelationInput | ProgramBonusOrderByWithRelationInput[]
    cursor?: ProgramBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramBonusScalarFieldEnum | ProgramBonusScalarFieldEnum[]
  }

  /**
   * Bonus without action
   */
  export type BonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bonus
     */
    select?: BonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BonusInclude<ExtArgs> | null
  }


  /**
   * Model Gifts
   */

  export type AggregateGifts = {
    _count: GiftsCountAggregateOutputType | null
    _avg: GiftsAvgAggregateOutputType | null
    _sum: GiftsSumAggregateOutputType | null
    _min: GiftsMinAggregateOutputType | null
    _max: GiftsMaxAggregateOutputType | null
  }

  export type GiftsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type GiftsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type GiftsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    title: string | null
    description: string | null
    gift_type: $Enums.GiftType | null
    status: $Enums.StatusType | null
    shipping_method: $Enums.ShippingType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type GiftsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    title: string | null
    description: string | null
    gift_type: $Enums.GiftType | null
    status: $Enums.StatusType | null
    shipping_method: $Enums.ShippingType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type GiftsCountAggregateOutputType = {
    id: number
    store_id: number
    title: number
    description: number
    products: number
    gift_type: number
    status: number
    shipping_method: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type GiftsAvgAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type GiftsSumAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type GiftsMinAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    gift_type?: true
    status?: true
    shipping_method?: true
    created_at?: true
    updated_at?: true
  }

  export type GiftsMaxAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    gift_type?: true
    status?: true
    shipping_method?: true
    created_at?: true
    updated_at?: true
  }

  export type GiftsCountAggregateInputType = {
    id?: true
    store_id?: true
    title?: true
    description?: true
    products?: true
    gift_type?: true
    status?: true
    shipping_method?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type GiftsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gifts to aggregate.
     */
    where?: GiftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gifts to fetch.
     */
    orderBy?: GiftsOrderByWithRelationInput | GiftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GiftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Gifts
    **/
    _count?: true | GiftsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GiftsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GiftsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GiftsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GiftsMaxAggregateInputType
  }

  export type GetGiftsAggregateType<T extends GiftsAggregateArgs> = {
        [P in keyof T & keyof AggregateGifts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGifts[P]>
      : GetScalarType<T[P], AggregateGifts[P]>
  }




  export type GiftsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GiftsWhereInput
    orderBy?: GiftsOrderByWithAggregationInput | GiftsOrderByWithAggregationInput[]
    by: GiftsScalarFieldEnum[] | GiftsScalarFieldEnum
    having?: GiftsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GiftsCountAggregateInputType | true
    _avg?: GiftsAvgAggregateInputType
    _sum?: GiftsSumAggregateInputType
    _min?: GiftsMinAggregateInputType
    _max?: GiftsMaxAggregateInputType
  }

  export type GiftsGroupByOutputType = {
    id: number
    store_id: number
    title: string
    description: string
    products: JsonValue
    gift_type: $Enums.GiftType
    status: $Enums.StatusType
    shipping_method: $Enums.ShippingType
    created_at: bigint
    updated_at: bigint
    _count: GiftsCountAggregateOutputType | null
    _avg: GiftsAvgAggregateOutputType | null
    _sum: GiftsSumAggregateOutputType | null
    _min: GiftsMinAggregateOutputType | null
    _max: GiftsMaxAggregateOutputType | null
  }

  type GetGiftsGroupByPayload<T extends GiftsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GiftsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GiftsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GiftsGroupByOutputType[P]>
            : GetScalarType<T[P], GiftsGroupByOutputType[P]>
        }
      >
    >


  export type GiftsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    products?: boolean
    gift_type?: boolean
    status?: boolean
    shipping_method?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliate_gifts?: boolean | Gifts$affiliate_giftsArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    _count?: boolean | GiftsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gifts"]>

  export type GiftsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    products?: boolean
    gift_type?: boolean
    status?: boolean
    shipping_method?: boolean
    created_at?: boolean
    updated_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gifts"]>

  export type GiftsSelectScalar = {
    id?: boolean
    store_id?: boolean
    title?: boolean
    description?: boolean
    products?: boolean
    gift_type?: boolean
    status?: boolean
    shipping_method?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type GiftsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_gifts?: boolean | Gifts$affiliate_giftsArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    _count?: boolean | GiftsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GiftsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $GiftsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Gifts"
    objects: {
      affiliate_gifts: Prisma.$AffiliateGiftsPayload<ExtArgs>[]
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      title: string
      description: string
      products: Prisma.JsonValue
      gift_type: $Enums.GiftType
      status: $Enums.StatusType
      shipping_method: $Enums.ShippingType
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["gifts"]>
    composites: {}
  }

  type GiftsGetPayload<S extends boolean | null | undefined | GiftsDefaultArgs> = $Result.GetResult<Prisma.$GiftsPayload, S>

  type GiftsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GiftsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GiftsCountAggregateInputType | true
    }

  export interface GiftsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Gifts'], meta: { name: 'Gifts' } }
    /**
     * Find zero or one Gifts that matches the filter.
     * @param {GiftsFindUniqueArgs} args - Arguments to find a Gifts
     * @example
     * // Get one Gifts
     * const gifts = await prisma.gifts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GiftsFindUniqueArgs>(args: SelectSubset<T, GiftsFindUniqueArgs<ExtArgs>>): Prisma__GiftsClient<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Gifts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GiftsFindUniqueOrThrowArgs} args - Arguments to find a Gifts
     * @example
     * // Get one Gifts
     * const gifts = await prisma.gifts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GiftsFindUniqueOrThrowArgs>(args: SelectSubset<T, GiftsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GiftsClient<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Gifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftsFindFirstArgs} args - Arguments to find a Gifts
     * @example
     * // Get one Gifts
     * const gifts = await prisma.gifts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GiftsFindFirstArgs>(args?: SelectSubset<T, GiftsFindFirstArgs<ExtArgs>>): Prisma__GiftsClient<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Gifts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftsFindFirstOrThrowArgs} args - Arguments to find a Gifts
     * @example
     * // Get one Gifts
     * const gifts = await prisma.gifts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GiftsFindFirstOrThrowArgs>(args?: SelectSubset<T, GiftsFindFirstOrThrowArgs<ExtArgs>>): Prisma__GiftsClient<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Gifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Gifts
     * const gifts = await prisma.gifts.findMany()
     * 
     * // Get first 10 Gifts
     * const gifts = await prisma.gifts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const giftsWithIdOnly = await prisma.gifts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GiftsFindManyArgs>(args?: SelectSubset<T, GiftsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Gifts.
     * @param {GiftsCreateArgs} args - Arguments to create a Gifts.
     * @example
     * // Create one Gifts
     * const Gifts = await prisma.gifts.create({
     *   data: {
     *     // ... data to create a Gifts
     *   }
     * })
     * 
     */
    create<T extends GiftsCreateArgs>(args: SelectSubset<T, GiftsCreateArgs<ExtArgs>>): Prisma__GiftsClient<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Gifts.
     * @param {GiftsCreateManyArgs} args - Arguments to create many Gifts.
     * @example
     * // Create many Gifts
     * const gifts = await prisma.gifts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GiftsCreateManyArgs>(args?: SelectSubset<T, GiftsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Gifts and returns the data saved in the database.
     * @param {GiftsCreateManyAndReturnArgs} args - Arguments to create many Gifts.
     * @example
     * // Create many Gifts
     * const gifts = await prisma.gifts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Gifts and only return the `id`
     * const giftsWithIdOnly = await prisma.gifts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GiftsCreateManyAndReturnArgs>(args?: SelectSubset<T, GiftsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Gifts.
     * @param {GiftsDeleteArgs} args - Arguments to delete one Gifts.
     * @example
     * // Delete one Gifts
     * const Gifts = await prisma.gifts.delete({
     *   where: {
     *     // ... filter to delete one Gifts
     *   }
     * })
     * 
     */
    delete<T extends GiftsDeleteArgs>(args: SelectSubset<T, GiftsDeleteArgs<ExtArgs>>): Prisma__GiftsClient<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Gifts.
     * @param {GiftsUpdateArgs} args - Arguments to update one Gifts.
     * @example
     * // Update one Gifts
     * const gifts = await prisma.gifts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GiftsUpdateArgs>(args: SelectSubset<T, GiftsUpdateArgs<ExtArgs>>): Prisma__GiftsClient<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Gifts.
     * @param {GiftsDeleteManyArgs} args - Arguments to filter Gifts to delete.
     * @example
     * // Delete a few Gifts
     * const { count } = await prisma.gifts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GiftsDeleteManyArgs>(args?: SelectSubset<T, GiftsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Gifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Gifts
     * const gifts = await prisma.gifts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GiftsUpdateManyArgs>(args: SelectSubset<T, GiftsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Gifts.
     * @param {GiftsUpsertArgs} args - Arguments to update or create a Gifts.
     * @example
     * // Update or create a Gifts
     * const gifts = await prisma.gifts.upsert({
     *   create: {
     *     // ... data to create a Gifts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Gifts we want to update
     *   }
     * })
     */
    upsert<T extends GiftsUpsertArgs>(args: SelectSubset<T, GiftsUpsertArgs<ExtArgs>>): Prisma__GiftsClient<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Gifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftsCountArgs} args - Arguments to filter Gifts to count.
     * @example
     * // Count the number of Gifts
     * const count = await prisma.gifts.count({
     *   where: {
     *     // ... the filter for the Gifts we want to count
     *   }
     * })
    **/
    count<T extends GiftsCountArgs>(
      args?: Subset<T, GiftsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GiftsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Gifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GiftsAggregateArgs>(args: Subset<T, GiftsAggregateArgs>): Prisma.PrismaPromise<GetGiftsAggregateType<T>>

    /**
     * Group by Gifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GiftsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GiftsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GiftsGroupByArgs['orderBy'] }
        : { orderBy?: GiftsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GiftsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGiftsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Gifts model
   */
  readonly fields: GiftsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Gifts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GiftsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate_gifts<T extends Gifts$affiliate_giftsArgs<ExtArgs> = {}>(args?: Subset<T, Gifts$affiliate_giftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "findMany"> | Null>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Gifts model
   */ 
  interface GiftsFieldRefs {
    readonly id: FieldRef<"Gifts", 'Int'>
    readonly store_id: FieldRef<"Gifts", 'Int'>
    readonly title: FieldRef<"Gifts", 'String'>
    readonly description: FieldRef<"Gifts", 'String'>
    readonly products: FieldRef<"Gifts", 'Json'>
    readonly gift_type: FieldRef<"Gifts", 'GiftType'>
    readonly status: FieldRef<"Gifts", 'StatusType'>
    readonly shipping_method: FieldRef<"Gifts", 'ShippingType'>
    readonly created_at: FieldRef<"Gifts", 'BigInt'>
    readonly updated_at: FieldRef<"Gifts", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Gifts findUnique
   */
  export type GiftsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    /**
     * Filter, which Gifts to fetch.
     */
    where: GiftsWhereUniqueInput
  }

  /**
   * Gifts findUniqueOrThrow
   */
  export type GiftsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    /**
     * Filter, which Gifts to fetch.
     */
    where: GiftsWhereUniqueInput
  }

  /**
   * Gifts findFirst
   */
  export type GiftsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    /**
     * Filter, which Gifts to fetch.
     */
    where?: GiftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gifts to fetch.
     */
    orderBy?: GiftsOrderByWithRelationInput | GiftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gifts.
     */
    cursor?: GiftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gifts.
     */
    distinct?: GiftsScalarFieldEnum | GiftsScalarFieldEnum[]
  }

  /**
   * Gifts findFirstOrThrow
   */
  export type GiftsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    /**
     * Filter, which Gifts to fetch.
     */
    where?: GiftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gifts to fetch.
     */
    orderBy?: GiftsOrderByWithRelationInput | GiftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Gifts.
     */
    cursor?: GiftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Gifts.
     */
    distinct?: GiftsScalarFieldEnum | GiftsScalarFieldEnum[]
  }

  /**
   * Gifts findMany
   */
  export type GiftsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    /**
     * Filter, which Gifts to fetch.
     */
    where?: GiftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Gifts to fetch.
     */
    orderBy?: GiftsOrderByWithRelationInput | GiftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Gifts.
     */
    cursor?: GiftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Gifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Gifts.
     */
    skip?: number
    distinct?: GiftsScalarFieldEnum | GiftsScalarFieldEnum[]
  }

  /**
   * Gifts create
   */
  export type GiftsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    /**
     * The data needed to create a Gifts.
     */
    data: XOR<GiftsCreateInput, GiftsUncheckedCreateInput>
  }

  /**
   * Gifts createMany
   */
  export type GiftsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Gifts.
     */
    data: GiftsCreateManyInput | GiftsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Gifts createManyAndReturn
   */
  export type GiftsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Gifts.
     */
    data: GiftsCreateManyInput | GiftsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Gifts update
   */
  export type GiftsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    /**
     * The data needed to update a Gifts.
     */
    data: XOR<GiftsUpdateInput, GiftsUncheckedUpdateInput>
    /**
     * Choose, which Gifts to update.
     */
    where: GiftsWhereUniqueInput
  }

  /**
   * Gifts updateMany
   */
  export type GiftsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Gifts.
     */
    data: XOR<GiftsUpdateManyMutationInput, GiftsUncheckedUpdateManyInput>
    /**
     * Filter which Gifts to update
     */
    where?: GiftsWhereInput
  }

  /**
   * Gifts upsert
   */
  export type GiftsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    /**
     * The filter to search for the Gifts to update in case it exists.
     */
    where: GiftsWhereUniqueInput
    /**
     * In case the Gifts found by the `where` argument doesn't exist, create a new Gifts with this data.
     */
    create: XOR<GiftsCreateInput, GiftsUncheckedCreateInput>
    /**
     * In case the Gifts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GiftsUpdateInput, GiftsUncheckedUpdateInput>
  }

  /**
   * Gifts delete
   */
  export type GiftsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
    /**
     * Filter which Gifts to delete.
     */
    where: GiftsWhereUniqueInput
  }

  /**
   * Gifts deleteMany
   */
  export type GiftsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Gifts to delete
     */
    where?: GiftsWhereInput
  }

  /**
   * Gifts.affiliate_gifts
   */
  export type Gifts$affiliate_giftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    where?: AffiliateGiftsWhereInput
    orderBy?: AffiliateGiftsOrderByWithRelationInput | AffiliateGiftsOrderByWithRelationInput[]
    cursor?: AffiliateGiftsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateGiftsScalarFieldEnum | AffiliateGiftsScalarFieldEnum[]
  }

  /**
   * Gifts without action
   */
  export type GiftsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Gifts
     */
    select?: GiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GiftsInclude<ExtArgs> | null
  }


  /**
   * Model Transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    amount: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    amount: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type TransactionsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    reference_type: $Enums.TransactionReferenceType | null
    reference_id: string | null
    currency_code: string | null
    type: $Enums.TransactionType | null
    is_reverted: boolean | null
    amount: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type TransactionsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    reference_type: $Enums.TransactionReferenceType | null
    reference_id: string | null
    currency_code: string | null
    type: $Enums.TransactionType | null
    is_reverted: boolean | null
    amount: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type TransactionsCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    reference_type: number
    reference_id: number
    currency_code: number
    type: number
    is_reverted: number
    amount: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    amount?: true
    created_at?: true
    updated_at?: true
  }

  export type TransactionsSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    amount?: true
    created_at?: true
    updated_at?: true
  }

  export type TransactionsMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    reference_type?: true
    reference_id?: true
    currency_code?: true
    type?: true
    is_reverted?: true
    amount?: true
    created_at?: true
    updated_at?: true
  }

  export type TransactionsMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    reference_type?: true
    reference_id?: true
    currency_code?: true
    type?: true
    is_reverted?: true
    amount?: true
    created_at?: true
    updated_at?: true
  }

  export type TransactionsCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    reference_type?: true
    reference_id?: true
    currency_code?: true
    type?: true
    is_reverted?: true
    amount?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to aggregate.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type TransactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithAggregationInput | TransactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: TransactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted: boolean
    amount: number
    created_at: bigint
    updated_at: bigint
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends TransactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type TransactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    reference_type?: boolean
    reference_id?: boolean
    currency_code?: boolean
    type?: boolean
    is_reverted?: boolean
    amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    reference_type?: boolean
    reference_id?: boolean
    currency_code?: boolean
    type?: boolean
    is_reverted?: boolean
    amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>

  export type TransactionsSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    reference_type?: boolean
    reference_id?: boolean
    currency_code?: boolean
    type?: boolean
    is_reverted?: boolean
    amount?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TransactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type TransactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $TransactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transactions"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      reference_type: $Enums.TransactionReferenceType
      reference_id: string
      currency_code: string
      type: $Enums.TransactionType
      is_reverted: boolean
      amount: number
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type TransactionsGetPayload<S extends boolean | null | undefined | TransactionsDefaultArgs> = $Result.GetResult<Prisma.$TransactionsPayload, S>

  type TransactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface TransactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transactions'], meta: { name: 'Transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {TransactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionsFindUniqueArgs>(args: SelectSubset<T, TransactionsFindUniqueArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionsFindFirstArgs>(args?: SelectSubset<T, TransactionsFindFirstArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionsWithIdOnly = await prisma.transactions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionsFindManyArgs>(args?: SelectSubset<T, TransactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transactions.
     * @param {TransactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends TransactionsCreateArgs>(args: SelectSubset<T, TransactionsCreateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionsCreateManyArgs>(args?: SelectSubset<T, TransactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionsCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionsWithIdOnly = await prisma.transactions.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Transactions.
     * @param {TransactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends TransactionsDeleteArgs>(args: SelectSubset<T, TransactionsDeleteArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transactions.
     * @param {TransactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionsUpdateArgs>(args: SelectSubset<T, TransactionsUpdateArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionsDeleteManyArgs>(args?: SelectSubset<T, TransactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionsUpdateManyArgs>(args: SelectSubset<T, TransactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactions.
     * @param {TransactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends TransactionsUpsertArgs>(args: SelectSubset<T, TransactionsUpsertArgs<ExtArgs>>): Prisma__TransactionsClient<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionsCountArgs>(
      args?: Subset<T, TransactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionsGroupByArgs['orderBy'] }
        : { orderBy?: TransactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transactions model
   */
  readonly fields: TransactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transactions model
   */ 
  interface TransactionsFieldRefs {
    readonly id: FieldRef<"Transactions", 'Int'>
    readonly store_id: FieldRef<"Transactions", 'Int'>
    readonly affiliate_id: FieldRef<"Transactions", 'Int'>
    readonly reference_type: FieldRef<"Transactions", 'TransactionReferenceType'>
    readonly reference_id: FieldRef<"Transactions", 'String'>
    readonly currency_code: FieldRef<"Transactions", 'String'>
    readonly type: FieldRef<"Transactions", 'TransactionType'>
    readonly is_reverted: FieldRef<"Transactions", 'Boolean'>
    readonly amount: FieldRef<"Transactions", 'Float'>
    readonly created_at: FieldRef<"Transactions", 'BigInt'>
    readonly updated_at: FieldRef<"Transactions", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Transactions findUnique
   */
  export type TransactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findUniqueOrThrow
   */
  export type TransactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions findFirst
   */
  export type TransactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findFirstOrThrow
   */
  export type TransactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions findMany
   */
  export type TransactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Transactions create
   */
  export type TransactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Transactions.
     */
    data: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
  }

  /**
   * Transactions createMany
   */
  export type TransactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transactions createManyAndReturn
   */
  export type TransactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionsCreateManyInput | TransactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transactions update
   */
  export type TransactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Transactions.
     */
    data: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
    /**
     * Choose, which Transactions to update.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions updateMany
   */
  export type TransactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionsWhereInput
  }

  /**
   * Transactions upsert
   */
  export type TransactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Transactions to update in case it exists.
     */
    where: TransactionsWhereUniqueInput
    /**
     * In case the Transactions found by the `where` argument doesn't exist, create a new Transactions with this data.
     */
    create: XOR<TransactionsCreateInput, TransactionsUncheckedCreateInput>
    /**
     * In case the Transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionsUpdateInput, TransactionsUncheckedUpdateInput>
  }

  /**
   * Transactions delete
   */
  export type TransactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    /**
     * Filter which Transactions to delete.
     */
    where: TransactionsWhereUniqueInput
  }

  /**
   * Transactions deleteMany
   */
  export type TransactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionsWhereInput
  }

  /**
   * Transactions without action
   */
  export type TransactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    commission_delay: number | null
    min_threshold: number | null
    created_at: number | null
    updated_at: number | null
    email_limit: number | null
  }

  export type SettingsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    commission_delay: number | null
    min_threshold: number | null
    created_at: bigint | null
    updated_at: bigint | null
    email_limit: number | null
  }

  export type SettingsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    commission_delay: number | null
    commission_approval_mode: $Enums.ApprovalModeType | null
    commission_calculation: $Enums.CommissionCalculationType | null
    min_threshold: number | null
    primary_color: string | null
    secondary_color: string | null
    created_at: bigint | null
    updated_at: bigint | null
    current_email_lang: string | null
    email_limit: number | null
    notify_once: boolean | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    commission_delay: number | null
    commission_approval_mode: $Enums.ApprovalModeType | null
    commission_calculation: $Enums.CommissionCalculationType | null
    min_threshold: number | null
    primary_color: string | null
    secondary_color: string | null
    created_at: bigint | null
    updated_at: bigint | null
    current_email_lang: string | null
    email_limit: number | null
    notify_once: boolean | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    store_id: number
    commission_delay: number
    commission_approval_mode: number
    commission_calculation: number
    details: number
    min_threshold: number
    primary_color: number
    secondary_color: number
    created_at: number
    updated_at: number
    current_email_lang: number
    email_limit: number
    notify_once: number
    _all: number
  }


  export type SettingsAvgAggregateInputType = {
    id?: true
    store_id?: true
    commission_delay?: true
    min_threshold?: true
    created_at?: true
    updated_at?: true
    email_limit?: true
  }

  export type SettingsSumAggregateInputType = {
    id?: true
    store_id?: true
    commission_delay?: true
    min_threshold?: true
    created_at?: true
    updated_at?: true
    email_limit?: true
  }

  export type SettingsMinAggregateInputType = {
    id?: true
    store_id?: true
    commission_delay?: true
    commission_approval_mode?: true
    commission_calculation?: true
    min_threshold?: true
    primary_color?: true
    secondary_color?: true
    created_at?: true
    updated_at?: true
    current_email_lang?: true
    email_limit?: true
    notify_once?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    store_id?: true
    commission_delay?: true
    commission_approval_mode?: true
    commission_calculation?: true
    min_threshold?: true
    primary_color?: true
    secondary_color?: true
    created_at?: true
    updated_at?: true
    current_email_lang?: true
    email_limit?: true
    notify_once?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    store_id?: true
    commission_delay?: true
    commission_approval_mode?: true
    commission_calculation?: true
    details?: true
    min_threshold?: true
    primary_color?: true
    secondary_color?: true
    created_at?: true
    updated_at?: true
    current_email_lang?: true
    email_limit?: true
    notify_once?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SettingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SettingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _avg?: SettingsAvgAggregateInputType
    _sum?: SettingsSumAggregateInputType
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: number
    store_id: number
    commission_delay: number
    commission_approval_mode: $Enums.ApprovalModeType
    commission_calculation: $Enums.CommissionCalculationType
    details: JsonValue | null
    min_threshold: number | null
    primary_color: string
    secondary_color: string
    created_at: bigint
    updated_at: bigint
    current_email_lang: string
    email_limit: number
    notify_once: boolean
    _count: SettingsCountAggregateOutputType | null
    _avg: SettingsAvgAggregateOutputType | null
    _sum: SettingsSumAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    commission_delay?: boolean
    commission_approval_mode?: boolean
    commission_calculation?: boolean
    details?: boolean
    min_threshold?: boolean
    primary_color?: boolean
    secondary_color?: boolean
    created_at?: boolean
    updated_at?: boolean
    current_email_lang?: boolean
    email_limit?: boolean
    notify_once?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    commission_delay?: boolean
    commission_approval_mode?: boolean
    commission_calculation?: boolean
    details?: boolean
    min_threshold?: boolean
    primary_color?: boolean
    secondary_color?: boolean
    created_at?: boolean
    updated_at?: boolean
    current_email_lang?: boolean
    email_limit?: boolean
    notify_once?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    store_id?: boolean
    commission_delay?: boolean
    commission_approval_mode?: boolean
    commission_calculation?: boolean
    details?: boolean
    min_threshold?: boolean
    primary_color?: boolean
    secondary_color?: boolean
    created_at?: boolean
    updated_at?: boolean
    current_email_lang?: boolean
    email_limit?: boolean
    notify_once?: boolean
  }

  export type SettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type SettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      commission_delay: number
      commission_approval_mode: $Enums.ApprovalModeType
      commission_calculation: $Enums.CommissionCalculationType
      details: Prisma.JsonValue | null
      min_threshold: number | null
      primary_color: string
      secondary_color: string
      created_at: bigint
      updated_at: bigint
      current_email_lang: string
      email_limit: number
      notify_once: boolean
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */ 
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'Int'>
    readonly store_id: FieldRef<"Settings", 'Int'>
    readonly commission_delay: FieldRef<"Settings", 'Int'>
    readonly commission_approval_mode: FieldRef<"Settings", 'ApprovalModeType'>
    readonly commission_calculation: FieldRef<"Settings", 'CommissionCalculationType'>
    readonly details: FieldRef<"Settings", 'Json'>
    readonly min_threshold: FieldRef<"Settings", 'Int'>
    readonly primary_color: FieldRef<"Settings", 'String'>
    readonly secondary_color: FieldRef<"Settings", 'String'>
    readonly created_at: FieldRef<"Settings", 'BigInt'>
    readonly updated_at: FieldRef<"Settings", 'BigInt'>
    readonly current_email_lang: FieldRef<"Settings", 'String'>
    readonly email_limit: FieldRef<"Settings", 'Int'>
    readonly notify_once: FieldRef<"Settings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
  }


  /**
   * Model Jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type JobsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type JobsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    status: $Enums.JobsStatusType | null
    type: $Enums.JobType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type JobsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    status: $Enums.JobsStatusType | null
    type: $Enums.JobType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type JobsCountAggregateOutputType = {
    id: number
    store_id: number
    job_metadata: number
    status: number
    type: number
    job_details: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type JobsSumAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type JobsMinAggregateInputType = {
    id?: true
    store_id?: true
    status?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type JobsMaxAggregateInputType = {
    id?: true
    store_id?: true
    status?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type JobsCountAggregateInputType = {
    id?: true
    store_id?: true
    job_metadata?: true
    status?: true
    type?: true
    job_details?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to aggregate.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type JobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobsWhereInput
    orderBy?: JobsOrderByWithAggregationInput | JobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: JobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    id: number
    store_id: number
    job_metadata: JsonValue
    status: $Enums.JobsStatusType
    type: $Enums.JobType
    job_details: JsonValue
    created_at: bigint
    updated_at: bigint
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends JobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type JobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    job_metadata?: boolean
    status?: boolean
    type?: boolean
    job_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    payouts?: boolean | Jobs$payoutsArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type JobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    job_metadata?: boolean
    status?: boolean
    type?: boolean
    job_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type JobsSelectScalar = {
    id?: boolean
    store_id?: boolean
    job_metadata?: boolean
    status?: boolean
    type?: boolean
    job_details?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type JobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    payouts?: boolean | Jobs$payoutsArgs<ExtArgs>
  }
  export type JobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $JobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Jobs"
    objects: {
      stores: Prisma.$StoresPayload<ExtArgs>
      payouts: Prisma.$PayoutsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      job_metadata: Prisma.JsonValue
      status: $Enums.JobsStatusType
      type: $Enums.JobType
      job_details: Prisma.JsonValue
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type JobsGetPayload<S extends boolean | null | undefined | JobsDefaultArgs> = $Result.GetResult<Prisma.$JobsPayload, S>

  type JobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface JobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Jobs'], meta: { name: 'Jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {JobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobsFindUniqueArgs>(args: SelectSubset<T, JobsFindUniqueArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobsFindUniqueOrThrowArgs>(args: SelectSubset<T, JobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobsFindFirstArgs>(args?: SelectSubset<T, JobsFindFirstArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobsFindFirstOrThrowArgs>(args?: SelectSubset<T, JobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobsWithIdOnly = await prisma.jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobsFindManyArgs>(args?: SelectSubset<T, JobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Jobs.
     * @param {JobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends JobsCreateArgs>(args: SelectSubset<T, JobsCreateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Jobs.
     * @param {JobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobsCreateManyArgs>(args?: SelectSubset<T, JobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {JobsCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobsWithIdOnly = await prisma.jobs.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JobsCreateManyAndReturnArgs>(args?: SelectSubset<T, JobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Jobs.
     * @param {JobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends JobsDeleteArgs>(args: SelectSubset<T, JobsDeleteArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Jobs.
     * @param {JobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobsUpdateArgs>(args: SelectSubset<T, JobsUpdateArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Jobs.
     * @param {JobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobsDeleteManyArgs>(args?: SelectSubset<T, JobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobsUpdateManyArgs>(args: SelectSubset<T, JobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobs.
     * @param {JobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends JobsUpsertArgs>(args: SelectSubset<T, JobsUpsertArgs<ExtArgs>>): Prisma__JobsClient<$Result.GetResult<Prisma.$JobsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobsCountArgs>(
      args?: Subset<T, JobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobsGroupByArgs['orderBy'] }
        : { orderBy?: JobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Jobs model
   */
  readonly fields: JobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payouts<T extends Jobs$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, Jobs$payoutsArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Jobs model
   */ 
  interface JobsFieldRefs {
    readonly id: FieldRef<"Jobs", 'Int'>
    readonly store_id: FieldRef<"Jobs", 'Int'>
    readonly job_metadata: FieldRef<"Jobs", 'Json'>
    readonly status: FieldRef<"Jobs", 'JobsStatusType'>
    readonly type: FieldRef<"Jobs", 'JobType'>
    readonly job_details: FieldRef<"Jobs", 'Json'>
    readonly created_at: FieldRef<"Jobs", 'BigInt'>
    readonly updated_at: FieldRef<"Jobs", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Jobs findUnique
   */
  export type JobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findUniqueOrThrow
   */
  export type JobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs findFirst
   */
  export type JobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findFirstOrThrow
   */
  export type JobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs findMany
   */
  export type JobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobsOrderByWithRelationInput | JobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * Jobs create
   */
  export type JobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The data needed to create a Jobs.
     */
    data: XOR<JobsCreateInput, JobsUncheckedCreateInput>
  }

  /**
   * Jobs createMany
   */
  export type JobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobsCreateManyInput | JobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Jobs createManyAndReturn
   */
  export type JobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Jobs.
     */
    data: JobsCreateManyInput | JobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Jobs update
   */
  export type JobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The data needed to update a Jobs.
     */
    data: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
    /**
     * Choose, which Jobs to update.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs updateMany
   */
  export type JobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobsWhereInput
  }

  /**
   * Jobs upsert
   */
  export type JobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * The filter to search for the Jobs to update in case it exists.
     */
    where: JobsWhereUniqueInput
    /**
     * In case the Jobs found by the `where` argument doesn't exist, create a new Jobs with this data.
     */
    create: XOR<JobsCreateInput, JobsUncheckedCreateInput>
    /**
     * In case the Jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobsUpdateInput, JobsUncheckedUpdateInput>
  }

  /**
   * Jobs delete
   */
  export type JobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
    /**
     * Filter which Jobs to delete.
     */
    where: JobsWhereUniqueInput
  }

  /**
   * Jobs deleteMany
   */
  export type JobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobsWhereInput
  }

  /**
   * Jobs.payouts
   */
  export type Jobs$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    where?: PayoutsWhereInput
  }

  /**
   * Jobs without action
   */
  export type JobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Jobs
     */
    select?: JobsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobsInclude<ExtArgs> | null
  }


  /**
   * Model Customers
   */

  export type AggregateCustomers = {
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  export type CustomersAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    shopify_customer_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type CustomersSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    shopify_customer_id: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type CustomersMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    shopify_customer_id: bigint | null
    first_name: string | null
    last_name: string | null
    contact_type: $Enums.ContactType | null
    email: string | null
    phone: string | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type CustomersMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    shopify_customer_id: bigint | null
    first_name: string | null
    last_name: string | null
    contact_type: $Enums.ContactType | null
    email: string | null
    phone: string | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type CustomersCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    shopify_customer_id: number
    first_name: number
    last_name: number
    contact_type: number
    email: number
    phone: number
    customer_details: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CustomersAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    shopify_customer_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomersSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    shopify_customer_id?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomersMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    shopify_customer_id?: true
    first_name?: true
    last_name?: true
    contact_type?: true
    email?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomersMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    shopify_customer_id?: true
    first_name?: true
    last_name?: true
    contact_type?: true
    email?: true
    phone?: true
    created_at?: true
    updated_at?: true
  }

  export type CustomersCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    shopify_customer_id?: true
    first_name?: true
    last_name?: true
    contact_type?: true
    email?: true
    phone?: true
    customer_details?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CustomersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to aggregate.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomersMaxAggregateInputType
  }

  export type GetCustomersAggregateType<T extends CustomersAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomers[P]>
      : GetScalarType<T[P], AggregateCustomers[P]>
  }




  export type CustomersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithAggregationInput | CustomersOrderByWithAggregationInput[]
    by: CustomersScalarFieldEnum[] | CustomersScalarFieldEnum
    having?: CustomersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomersCountAggregateInputType | true
    _avg?: CustomersAvgAggregateInputType
    _sum?: CustomersSumAggregateInputType
    _min?: CustomersMinAggregateInputType
    _max?: CustomersMaxAggregateInputType
  }

  export type CustomersGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    shopify_customer_id: bigint
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email: string | null
    phone: string | null
    customer_details: JsonValue
    created_at: bigint
    updated_at: bigint
    _count: CustomersCountAggregateOutputType | null
    _avg: CustomersAvgAggregateOutputType | null
    _sum: CustomersSumAggregateOutputType | null
    _min: CustomersMinAggregateOutputType | null
    _max: CustomersMaxAggregateOutputType | null
  }

  type GetCustomersGroupByPayload<T extends CustomersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomersGroupByOutputType[P]>
            : GetScalarType<T[P], CustomersGroupByOutputType[P]>
        }
      >
    >


  export type CustomersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    shopify_customer_id?: boolean
    first_name?: boolean
    last_name?: boolean
    contact_type?: boolean
    email?: boolean
    phone?: boolean
    customer_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    order_items?: boolean | Customers$order_itemsArgs<ExtArgs>
    orders?: boolean | Customers$ordersArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type CustomersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    shopify_customer_id?: boolean
    first_name?: boolean
    last_name?: boolean
    contact_type?: boolean
    email?: boolean
    phone?: boolean
    customer_details?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customers"]>

  export type CustomersSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    shopify_customer_id?: boolean
    first_name?: boolean
    last_name?: boolean
    contact_type?: boolean
    email?: boolean
    phone?: boolean
    customer_details?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type CustomersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    order_items?: boolean | Customers$order_itemsArgs<ExtArgs>
    orders?: boolean | Customers$ordersArgs<ExtArgs>
    _count?: boolean | CustomersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $CustomersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customers"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
      order_items: Prisma.$OrderItemsPayload<ExtArgs>[]
      orders: Prisma.$OrdersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      shopify_customer_id: bigint
      first_name: string
      last_name: string
      contact_type: $Enums.ContactType
      email: string | null
      phone: string | null
      customer_details: Prisma.JsonValue
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["customers"]>
    composites: {}
  }

  type CustomersGetPayload<S extends boolean | null | undefined | CustomersDefaultArgs> = $Result.GetResult<Prisma.$CustomersPayload, S>

  type CustomersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomersCountAggregateInputType | true
    }

  export interface CustomersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customers'], meta: { name: 'Customers' } }
    /**
     * Find zero or one Customers that matches the filter.
     * @param {CustomersFindUniqueArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomersFindUniqueArgs>(args: SelectSubset<T, CustomersFindUniqueArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customers that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomersFindUniqueOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomersFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomersFindFirstArgs>(args?: SelectSubset<T, CustomersFindFirstArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindFirstOrThrowArgs} args - Arguments to find a Customers
     * @example
     * // Get one Customers
     * const customers = await prisma.customers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomersFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomersFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customers.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomersFindManyArgs>(args?: SelectSubset<T, CustomersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customers.
     * @param {CustomersCreateArgs} args - Arguments to create a Customers.
     * @example
     * // Create one Customers
     * const Customers = await prisma.customers.create({
     *   data: {
     *     // ... data to create a Customers
     *   }
     * })
     * 
     */
    create<T extends CustomersCreateArgs>(args: SelectSubset<T, CustomersCreateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomersCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomersCreateManyArgs>(args?: SelectSubset<T, CustomersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomersCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customers = await prisma.customers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customersWithIdOnly = await prisma.customers.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomersCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customers.
     * @param {CustomersDeleteArgs} args - Arguments to delete one Customers.
     * @example
     * // Delete one Customers
     * const Customers = await prisma.customers.delete({
     *   where: {
     *     // ... filter to delete one Customers
     *   }
     * })
     * 
     */
    delete<T extends CustomersDeleteArgs>(args: SelectSubset<T, CustomersDeleteArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customers.
     * @param {CustomersUpdateArgs} args - Arguments to update one Customers.
     * @example
     * // Update one Customers
     * const customers = await prisma.customers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomersUpdateArgs>(args: SelectSubset<T, CustomersUpdateArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomersDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomersDeleteManyArgs>(args?: SelectSubset<T, CustomersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customers = await prisma.customers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomersUpdateManyArgs>(args: SelectSubset<T, CustomersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customers.
     * @param {CustomersUpsertArgs} args - Arguments to update or create a Customers.
     * @example
     * // Update or create a Customers
     * const customers = await prisma.customers.upsert({
     *   create: {
     *     // ... data to create a Customers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customers we want to update
     *   }
     * })
     */
    upsert<T extends CustomersUpsertArgs>(args: SelectSubset<T, CustomersUpsertArgs<ExtArgs>>): Prisma__CustomersClient<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customers.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomersCountArgs>(
      args?: Subset<T, CustomersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomersAggregateArgs>(args: Subset<T, CustomersAggregateArgs>): Prisma.PrismaPromise<GetCustomersAggregateType<T>>

    /**
     * Group by Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomersGroupByArgs['orderBy'] }
        : { orderBy?: CustomersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customers model
   */
  readonly fields: CustomersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    order_items<T extends Customers$order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Customers$order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Customers$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Customers$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customers model
   */ 
  interface CustomersFieldRefs {
    readonly id: FieldRef<"Customers", 'Int'>
    readonly store_id: FieldRef<"Customers", 'Int'>
    readonly affiliate_id: FieldRef<"Customers", 'Int'>
    readonly shopify_customer_id: FieldRef<"Customers", 'BigInt'>
    readonly first_name: FieldRef<"Customers", 'String'>
    readonly last_name: FieldRef<"Customers", 'String'>
    readonly contact_type: FieldRef<"Customers", 'ContactType'>
    readonly email: FieldRef<"Customers", 'String'>
    readonly phone: FieldRef<"Customers", 'String'>
    readonly customer_details: FieldRef<"Customers", 'Json'>
    readonly created_at: FieldRef<"Customers", 'BigInt'>
    readonly updated_at: FieldRef<"Customers", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Customers findUnique
   */
  export type CustomersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findUniqueOrThrow
   */
  export type CustomersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers findFirst
   */
  export type CustomersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findFirstOrThrow
   */
  export type CustomersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers findMany
   */
  export type CustomersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Customers create
   */
  export type CustomersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to create a Customers.
     */
    data: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
  }

  /**
   * Customers createMany
   */
  export type CustomersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customers createManyAndReturn
   */
  export type CustomersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomersCreateManyInput | CustomersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customers update
   */
  export type CustomersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The data needed to update a Customers.
     */
    data: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
    /**
     * Choose, which Customers to update.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers updateMany
   */
  export type CustomersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomersWhereInput
  }

  /**
   * Customers upsert
   */
  export type CustomersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * The filter to search for the Customers to update in case it exists.
     */
    where: CustomersWhereUniqueInput
    /**
     * In case the Customers found by the `where` argument doesn't exist, create a new Customers with this data.
     */
    create: XOR<CustomersCreateInput, CustomersUncheckedCreateInput>
    /**
     * In case the Customers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomersUpdateInput, CustomersUncheckedUpdateInput>
  }

  /**
   * Customers delete
   */
  export type CustomersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    /**
     * Filter which Customers to delete.
     */
    where: CustomersWhereUniqueInput
  }

  /**
   * Customers deleteMany
   */
  export type CustomersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomersWhereInput
  }

  /**
   * Customers.order_items
   */
  export type Customers$order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    cursor?: OrderItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * Customers.orders
   */
  export type Customers$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Customers without action
   */
  export type CustomersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
  }


  /**
   * Model Affiliates
   */

  export type AggregateAffiliates = {
    _count: AffiliatesCountAggregateOutputType | null
    _avg: AffiliatesAvgAggregateOutputType | null
    _sum: AffiliatesSumAggregateOutputType | null
    _min: AffiliatesMinAggregateOutputType | null
    _max: AffiliatesMaxAggregateOutputType | null
  }

  export type AffiliatesAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    member_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type AffiliatesSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    member_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliatesMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    member_id: number | null
    first_name: string | null
    last_name: string | null
    phone: string | null
    referral_code: string | null
    status: $Enums.AffiliateStatusType | null
    payout_requested: boolean | null
    created_at: bigint | null
    updated_at: bigint | null
    source: $Enums.AffiliateSourceType | null
  }

  export type AffiliatesMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    member_id: number | null
    first_name: string | null
    last_name: string | null
    phone: string | null
    referral_code: string | null
    status: $Enums.AffiliateStatusType | null
    payout_requested: boolean | null
    created_at: bigint | null
    updated_at: bigint | null
    source: $Enums.AffiliateSourceType | null
  }

  export type AffiliatesCountAggregateOutputType = {
    id: number
    store_id: number
    member_id: number
    first_name: number
    last_name: number
    phone: number
    referral_code: number
    status: number
    affiliate_details: number
    payout_requested: number
    created_at: number
    updated_at: number
    source: number
    _all: number
  }


  export type AffiliatesAvgAggregateInputType = {
    id?: true
    store_id?: true
    member_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliatesSumAggregateInputType = {
    id?: true
    store_id?: true
    member_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliatesMinAggregateInputType = {
    id?: true
    store_id?: true
    member_id?: true
    first_name?: true
    last_name?: true
    phone?: true
    referral_code?: true
    status?: true
    payout_requested?: true
    created_at?: true
    updated_at?: true
    source?: true
  }

  export type AffiliatesMaxAggregateInputType = {
    id?: true
    store_id?: true
    member_id?: true
    first_name?: true
    last_name?: true
    phone?: true
    referral_code?: true
    status?: true
    payout_requested?: true
    created_at?: true
    updated_at?: true
    source?: true
  }

  export type AffiliatesCountAggregateInputType = {
    id?: true
    store_id?: true
    member_id?: true
    first_name?: true
    last_name?: true
    phone?: true
    referral_code?: true
    status?: true
    affiliate_details?: true
    payout_requested?: true
    created_at?: true
    updated_at?: true
    source?: true
    _all?: true
  }

  export type AffiliatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliates to aggregate.
     */
    where?: AffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Affiliates
    **/
    _count?: true | AffiliatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliatesMaxAggregateInputType
  }

  export type GetAffiliatesAggregateType<T extends AffiliatesAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliates[P]>
      : GetScalarType<T[P], AggregateAffiliates[P]>
  }




  export type AffiliatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliatesWhereInput
    orderBy?: AffiliatesOrderByWithAggregationInput | AffiliatesOrderByWithAggregationInput[]
    by: AffiliatesScalarFieldEnum[] | AffiliatesScalarFieldEnum
    having?: AffiliatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliatesCountAggregateInputType | true
    _avg?: AffiliatesAvgAggregateInputType
    _sum?: AffiliatesSumAggregateInputType
    _min?: AffiliatesMinAggregateInputType
    _max?: AffiliatesMaxAggregateInputType
  }

  export type AffiliatesGroupByOutputType = {
    id: number
    store_id: number
    member_id: number
    first_name: string | null
    last_name: string | null
    phone: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details: JsonValue | null
    payout_requested: boolean | null
    created_at: bigint
    updated_at: bigint
    source: $Enums.AffiliateSourceType | null
    _count: AffiliatesCountAggregateOutputType | null
    _avg: AffiliatesAvgAggregateOutputType | null
    _sum: AffiliatesSumAggregateOutputType | null
    _min: AffiliatesMinAggregateOutputType | null
    _max: AffiliatesMaxAggregateOutputType | null
  }

  type GetAffiliatesGroupByPayload<T extends AffiliatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliatesGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliatesGroupByOutputType[P]>
        }
      >
    >


  export type AffiliatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    member_id?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    referral_code?: boolean
    status?: boolean
    affiliate_details?: boolean
    payout_requested?: boolean
    created_at?: boolean
    updated_at?: boolean
    source?: boolean
    affiliate_bonus?: boolean | Affiliates$affiliate_bonusArgs<ExtArgs>
    affiliate_discounts?: boolean | Affiliates$affiliate_discountsArgs<ExtArgs>
    affiliate_gifts?: boolean | Affiliates$affiliate_giftsArgs<ExtArgs>
    affiliate_program_history?: boolean | Affiliates$affiliate_program_historyArgs<ExtArgs>
    affiliate_programs?: boolean | Affiliates$affiliate_programsArgs<ExtArgs>
    members?: boolean | MembersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    commissions?: boolean | Affiliates$commissionsArgs<ExtArgs>
    customers?: boolean | Affiliates$customersArgs<ExtArgs>
    order_items?: boolean | Affiliates$order_itemsArgs<ExtArgs>
    orders?: boolean | Affiliates$ordersArgs<ExtArgs>
    payouts?: boolean | Affiliates$payoutsArgs<ExtArgs>
    transactions?: boolean | Affiliates$transactionsArgs<ExtArgs>
    activity_log?: boolean | Affiliates$activity_logArgs<ExtArgs>
    _count?: boolean | AffiliatesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliates"]>

  export type AffiliatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    member_id?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    referral_code?: boolean
    status?: boolean
    affiliate_details?: boolean
    payout_requested?: boolean
    created_at?: boolean
    updated_at?: boolean
    source?: boolean
    members?: boolean | MembersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliates"]>

  export type AffiliatesSelectScalar = {
    id?: boolean
    store_id?: boolean
    member_id?: boolean
    first_name?: boolean
    last_name?: boolean
    phone?: boolean
    referral_code?: boolean
    status?: boolean
    affiliate_details?: boolean
    payout_requested?: boolean
    created_at?: boolean
    updated_at?: boolean
    source?: boolean
  }

  export type AffiliatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliate_bonus?: boolean | Affiliates$affiliate_bonusArgs<ExtArgs>
    affiliate_discounts?: boolean | Affiliates$affiliate_discountsArgs<ExtArgs>
    affiliate_gifts?: boolean | Affiliates$affiliate_giftsArgs<ExtArgs>
    affiliate_program_history?: boolean | Affiliates$affiliate_program_historyArgs<ExtArgs>
    affiliate_programs?: boolean | Affiliates$affiliate_programsArgs<ExtArgs>
    members?: boolean | MembersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    commissions?: boolean | Affiliates$commissionsArgs<ExtArgs>
    customers?: boolean | Affiliates$customersArgs<ExtArgs>
    order_items?: boolean | Affiliates$order_itemsArgs<ExtArgs>
    orders?: boolean | Affiliates$ordersArgs<ExtArgs>
    payouts?: boolean | Affiliates$payoutsArgs<ExtArgs>
    transactions?: boolean | Affiliates$transactionsArgs<ExtArgs>
    activity_log?: boolean | Affiliates$activity_logArgs<ExtArgs>
    _count?: boolean | AffiliatesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AffiliatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | MembersDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $AffiliatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Affiliates"
    objects: {
      affiliate_bonus: Prisma.$AffiliateBonusPayload<ExtArgs>[]
      affiliate_discounts: Prisma.$AffiliateDiscountsPayload<ExtArgs>[]
      affiliate_gifts: Prisma.$AffiliateGiftsPayload<ExtArgs>[]
      affiliate_program_history: Prisma.$AffiliateProgramHistoryPayload<ExtArgs>[]
      affiliate_programs: Prisma.$AffiliateProgramsPayload<ExtArgs>[]
      members: Prisma.$MembersPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
      commissions: Prisma.$CommissionsPayload<ExtArgs>[]
      customers: Prisma.$CustomersPayload<ExtArgs>[]
      order_items: Prisma.$OrderItemsPayload<ExtArgs>[]
      orders: Prisma.$OrdersPayload<ExtArgs>[]
      payouts: Prisma.$PayoutsPayload<ExtArgs>[]
      transactions: Prisma.$TransactionsPayload<ExtArgs>[]
      activity_log: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      member_id: number
      first_name: string | null
      last_name: string | null
      phone: string | null
      referral_code: string
      status: $Enums.AffiliateStatusType
      affiliate_details: Prisma.JsonValue | null
      payout_requested: boolean | null
      created_at: bigint
      updated_at: bigint
      source: $Enums.AffiliateSourceType | null
    }, ExtArgs["result"]["affiliates"]>
    composites: {}
  }

  type AffiliatesGetPayload<S extends boolean | null | undefined | AffiliatesDefaultArgs> = $Result.GetResult<Prisma.$AffiliatesPayload, S>

  type AffiliatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliatesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliatesCountAggregateInputType | true
    }

  export interface AffiliatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Affiliates'], meta: { name: 'Affiliates' } }
    /**
     * Find zero or one Affiliates that matches the filter.
     * @param {AffiliatesFindUniqueArgs} args - Arguments to find a Affiliates
     * @example
     * // Get one Affiliates
     * const affiliates = await prisma.affiliates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliatesFindUniqueArgs>(args: SelectSubset<T, AffiliatesFindUniqueArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Affiliates that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliatesFindUniqueOrThrowArgs} args - Arguments to find a Affiliates
     * @example
     * // Get one Affiliates
     * const affiliates = await prisma.affiliates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliatesFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Affiliates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesFindFirstArgs} args - Arguments to find a Affiliates
     * @example
     * // Get one Affiliates
     * const affiliates = await prisma.affiliates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliatesFindFirstArgs>(args?: SelectSubset<T, AffiliatesFindFirstArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Affiliates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesFindFirstOrThrowArgs} args - Arguments to find a Affiliates
     * @example
     * // Get one Affiliates
     * const affiliates = await prisma.affiliates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliatesFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Affiliates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Affiliates
     * const affiliates = await prisma.affiliates.findMany()
     * 
     * // Get first 10 Affiliates
     * const affiliates = await prisma.affiliates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliatesWithIdOnly = await prisma.affiliates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliatesFindManyArgs>(args?: SelectSubset<T, AffiliatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Affiliates.
     * @param {AffiliatesCreateArgs} args - Arguments to create a Affiliates.
     * @example
     * // Create one Affiliates
     * const Affiliates = await prisma.affiliates.create({
     *   data: {
     *     // ... data to create a Affiliates
     *   }
     * })
     * 
     */
    create<T extends AffiliatesCreateArgs>(args: SelectSubset<T, AffiliatesCreateArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Affiliates.
     * @param {AffiliatesCreateManyArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliates = await prisma.affiliates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliatesCreateManyArgs>(args?: SelectSubset<T, AffiliatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Affiliates and returns the data saved in the database.
     * @param {AffiliatesCreateManyAndReturnArgs} args - Arguments to create many Affiliates.
     * @example
     * // Create many Affiliates
     * const affiliates = await prisma.affiliates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Affiliates and only return the `id`
     * const affiliatesWithIdOnly = await prisma.affiliates.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliatesCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Affiliates.
     * @param {AffiliatesDeleteArgs} args - Arguments to delete one Affiliates.
     * @example
     * // Delete one Affiliates
     * const Affiliates = await prisma.affiliates.delete({
     *   where: {
     *     // ... filter to delete one Affiliates
     *   }
     * })
     * 
     */
    delete<T extends AffiliatesDeleteArgs>(args: SelectSubset<T, AffiliatesDeleteArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Affiliates.
     * @param {AffiliatesUpdateArgs} args - Arguments to update one Affiliates.
     * @example
     * // Update one Affiliates
     * const affiliates = await prisma.affiliates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliatesUpdateArgs>(args: SelectSubset<T, AffiliatesUpdateArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Affiliates.
     * @param {AffiliatesDeleteManyArgs} args - Arguments to filter Affiliates to delete.
     * @example
     * // Delete a few Affiliates
     * const { count } = await prisma.affiliates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliatesDeleteManyArgs>(args?: SelectSubset<T, AffiliatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Affiliates
     * const affiliates = await prisma.affiliates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliatesUpdateManyArgs>(args: SelectSubset<T, AffiliatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Affiliates.
     * @param {AffiliatesUpsertArgs} args - Arguments to update or create a Affiliates.
     * @example
     * // Update or create a Affiliates
     * const affiliates = await prisma.affiliates.upsert({
     *   create: {
     *     // ... data to create a Affiliates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Affiliates we want to update
     *   }
     * })
     */
    upsert<T extends AffiliatesUpsertArgs>(args: SelectSubset<T, AffiliatesUpsertArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesCountArgs} args - Arguments to filter Affiliates to count.
     * @example
     * // Count the number of Affiliates
     * const count = await prisma.affiliates.count({
     *   where: {
     *     // ... the filter for the Affiliates we want to count
     *   }
     * })
    **/
    count<T extends AffiliatesCountArgs>(
      args?: Subset<T, AffiliatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliatesAggregateArgs>(args: Subset<T, AffiliatesAggregateArgs>): Prisma.PrismaPromise<GetAffiliatesAggregateType<T>>

    /**
     * Group by Affiliates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliatesGroupByArgs['orderBy'] }
        : { orderBy?: AffiliatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Affiliates model
   */
  readonly fields: AffiliatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Affiliates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliate_bonus<T extends Affiliates$affiliate_bonusArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$affiliate_bonusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_discounts<T extends Affiliates$affiliate_discountsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$affiliate_discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_gifts<T extends Affiliates$affiliate_giftsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$affiliate_giftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_program_history<T extends Affiliates$affiliate_program_historyArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$affiliate_program_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    affiliate_programs<T extends Affiliates$affiliate_programsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$affiliate_programsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "findMany"> | Null>
    members<T extends MembersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MembersDefaultArgs<ExtArgs>>): Prisma__MembersClient<$Result.GetResult<Prisma.$MembersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    commissions<T extends Affiliates$commissionsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$commissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommissionsPayload<ExtArgs>, T, "findMany"> | Null>
    customers<T extends Affiliates$customersArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomersPayload<ExtArgs>, T, "findMany"> | Null>
    order_items<T extends Affiliates$order_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$order_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemsPayload<ExtArgs>, T, "findMany"> | Null>
    orders<T extends Affiliates$ordersArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findMany"> | Null>
    payouts<T extends Affiliates$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Affiliates$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionsPayload<ExtArgs>, T, "findMany"> | Null>
    activity_log<T extends Affiliates$activity_logArgs<ExtArgs> = {}>(args?: Subset<T, Affiliates$activity_logArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Affiliates model
   */ 
  interface AffiliatesFieldRefs {
    readonly id: FieldRef<"Affiliates", 'Int'>
    readonly store_id: FieldRef<"Affiliates", 'Int'>
    readonly member_id: FieldRef<"Affiliates", 'Int'>
    readonly first_name: FieldRef<"Affiliates", 'String'>
    readonly last_name: FieldRef<"Affiliates", 'String'>
    readonly phone: FieldRef<"Affiliates", 'String'>
    readonly referral_code: FieldRef<"Affiliates", 'String'>
    readonly status: FieldRef<"Affiliates", 'AffiliateStatusType'>
    readonly affiliate_details: FieldRef<"Affiliates", 'Json'>
    readonly payout_requested: FieldRef<"Affiliates", 'Boolean'>
    readonly created_at: FieldRef<"Affiliates", 'BigInt'>
    readonly updated_at: FieldRef<"Affiliates", 'BigInt'>
    readonly source: FieldRef<"Affiliates", 'AffiliateSourceType'>
  }
    

  // Custom InputTypes
  /**
   * Affiliates findUnique
   */
  export type AffiliatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where: AffiliatesWhereUniqueInput
  }

  /**
   * Affiliates findUniqueOrThrow
   */
  export type AffiliatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where: AffiliatesWhereUniqueInput
  }

  /**
   * Affiliates findFirst
   */
  export type AffiliatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where?: AffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliates.
     */
    cursor?: AffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliates.
     */
    distinct?: AffiliatesScalarFieldEnum | AffiliatesScalarFieldEnum[]
  }

  /**
   * Affiliates findFirstOrThrow
   */
  export type AffiliatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where?: AffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Affiliates.
     */
    cursor?: AffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Affiliates.
     */
    distinct?: AffiliatesScalarFieldEnum | AffiliatesScalarFieldEnum[]
  }

  /**
   * Affiliates findMany
   */
  export type AffiliatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter, which Affiliates to fetch.
     */
    where?: AffiliatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Affiliates to fetch.
     */
    orderBy?: AffiliatesOrderByWithRelationInput | AffiliatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Affiliates.
     */
    cursor?: AffiliatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Affiliates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Affiliates.
     */
    skip?: number
    distinct?: AffiliatesScalarFieldEnum | AffiliatesScalarFieldEnum[]
  }

  /**
   * Affiliates create
   */
  export type AffiliatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * The data needed to create a Affiliates.
     */
    data: XOR<AffiliatesCreateInput, AffiliatesUncheckedCreateInput>
  }

  /**
   * Affiliates createMany
   */
  export type AffiliatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Affiliates.
     */
    data: AffiliatesCreateManyInput | AffiliatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Affiliates createManyAndReturn
   */
  export type AffiliatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Affiliates.
     */
    data: AffiliatesCreateManyInput | AffiliatesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Affiliates update
   */
  export type AffiliatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * The data needed to update a Affiliates.
     */
    data: XOR<AffiliatesUpdateInput, AffiliatesUncheckedUpdateInput>
    /**
     * Choose, which Affiliates to update.
     */
    where: AffiliatesWhereUniqueInput
  }

  /**
   * Affiliates updateMany
   */
  export type AffiliatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Affiliates.
     */
    data: XOR<AffiliatesUpdateManyMutationInput, AffiliatesUncheckedUpdateManyInput>
    /**
     * Filter which Affiliates to update
     */
    where?: AffiliatesWhereInput
  }

  /**
   * Affiliates upsert
   */
  export type AffiliatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * The filter to search for the Affiliates to update in case it exists.
     */
    where: AffiliatesWhereUniqueInput
    /**
     * In case the Affiliates found by the `where` argument doesn't exist, create a new Affiliates with this data.
     */
    create: XOR<AffiliatesCreateInput, AffiliatesUncheckedCreateInput>
    /**
     * In case the Affiliates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliatesUpdateInput, AffiliatesUncheckedUpdateInput>
  }

  /**
   * Affiliates delete
   */
  export type AffiliatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    /**
     * Filter which Affiliates to delete.
     */
    where: AffiliatesWhereUniqueInput
  }

  /**
   * Affiliates deleteMany
   */
  export type AffiliatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Affiliates to delete
     */
    where?: AffiliatesWhereInput
  }

  /**
   * Affiliates.affiliate_bonus
   */
  export type Affiliates$affiliate_bonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    where?: AffiliateBonusWhereInput
    orderBy?: AffiliateBonusOrderByWithRelationInput | AffiliateBonusOrderByWithRelationInput[]
    cursor?: AffiliateBonusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateBonusScalarFieldEnum | AffiliateBonusScalarFieldEnum[]
  }

  /**
   * Affiliates.affiliate_discounts
   */
  export type Affiliates$affiliate_discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    where?: AffiliateDiscountsWhereInput
    orderBy?: AffiliateDiscountsOrderByWithRelationInput | AffiliateDiscountsOrderByWithRelationInput[]
    cursor?: AffiliateDiscountsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateDiscountsScalarFieldEnum | AffiliateDiscountsScalarFieldEnum[]
  }

  /**
   * Affiliates.affiliate_gifts
   */
  export type Affiliates$affiliate_giftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    where?: AffiliateGiftsWhereInput
    orderBy?: AffiliateGiftsOrderByWithRelationInput | AffiliateGiftsOrderByWithRelationInput[]
    cursor?: AffiliateGiftsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateGiftsScalarFieldEnum | AffiliateGiftsScalarFieldEnum[]
  }

  /**
   * Affiliates.affiliate_program_history
   */
  export type Affiliates$affiliate_program_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    where?: AffiliateProgramHistoryWhereInput
    orderBy?: AffiliateProgramHistoryOrderByWithRelationInput | AffiliateProgramHistoryOrderByWithRelationInput[]
    cursor?: AffiliateProgramHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateProgramHistoryScalarFieldEnum | AffiliateProgramHistoryScalarFieldEnum[]
  }

  /**
   * Affiliates.affiliate_programs
   */
  export type Affiliates$affiliate_programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    where?: AffiliateProgramsWhereInput
    orderBy?: AffiliateProgramsOrderByWithRelationInput | AffiliateProgramsOrderByWithRelationInput[]
    cursor?: AffiliateProgramsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffiliateProgramsScalarFieldEnum | AffiliateProgramsScalarFieldEnum[]
  }

  /**
   * Affiliates.commissions
   */
  export type Affiliates$commissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Commissions
     */
    select?: CommissionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommissionsInclude<ExtArgs> | null
    where?: CommissionsWhereInput
    orderBy?: CommissionsOrderByWithRelationInput | CommissionsOrderByWithRelationInput[]
    cursor?: CommissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommissionsScalarFieldEnum | CommissionsScalarFieldEnum[]
  }

  /**
   * Affiliates.customers
   */
  export type Affiliates$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customers
     */
    select?: CustomersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomersInclude<ExtArgs> | null
    where?: CustomersWhereInput
    orderBy?: CustomersOrderByWithRelationInput | CustomersOrderByWithRelationInput[]
    cursor?: CustomersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomersScalarFieldEnum | CustomersScalarFieldEnum[]
  }

  /**
   * Affiliates.order_items
   */
  export type Affiliates$order_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItems
     */
    select?: OrderItemsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemsInclude<ExtArgs> | null
    where?: OrderItemsWhereInput
    orderBy?: OrderItemsOrderByWithRelationInput | OrderItemsOrderByWithRelationInput[]
    cursor?: OrderItemsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemsScalarFieldEnum | OrderItemsScalarFieldEnum[]
  }

  /**
   * Affiliates.orders
   */
  export type Affiliates$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
    orderBy?: OrdersOrderByWithRelationInput | OrdersOrderByWithRelationInput[]
    cursor?: OrdersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrdersScalarFieldEnum | OrdersScalarFieldEnum[]
  }

  /**
   * Affiliates.payouts
   */
  export type Affiliates$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    where?: PayoutsWhereInput
    orderBy?: PayoutsOrderByWithRelationInput | PayoutsOrderByWithRelationInput[]
    cursor?: PayoutsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayoutsScalarFieldEnum | PayoutsScalarFieldEnum[]
  }

  /**
   * Affiliates.transactions
   */
  export type Affiliates$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transactions
     */
    select?: TransactionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionsInclude<ExtArgs> | null
    where?: TransactionsWhereInput
    orderBy?: TransactionsOrderByWithRelationInput | TransactionsOrderByWithRelationInput[]
    cursor?: TransactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * Affiliates.activity_log
   */
  export type Affiliates$activity_logArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Affiliates without action
   */
  export type AffiliatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
  }


  /**
   * Model AffiliatePrograms
   */

  export type AggregateAffiliatePrograms = {
    _count: AffiliateProgramsCountAggregateOutputType | null
    _avg: AffiliateProgramsAvgAggregateOutputType | null
    _sum: AffiliateProgramsSumAggregateOutputType | null
    _min: AffiliateProgramsMinAggregateOutputType | null
    _max: AffiliateProgramsMaxAggregateOutputType | null
  }

  export type AffiliateProgramsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type AffiliateProgramsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateProgramsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateProgramsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateProgramsCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    program_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AffiliateProgramsAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProgramsSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProgramsMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProgramsMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProgramsCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AffiliateProgramsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliatePrograms to aggregate.
     */
    where?: AffiliateProgramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliatePrograms to fetch.
     */
    orderBy?: AffiliateProgramsOrderByWithRelationInput | AffiliateProgramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateProgramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliatePrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliatePrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliatePrograms
    **/
    _count?: true | AffiliateProgramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateProgramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateProgramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateProgramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateProgramsMaxAggregateInputType
  }

  export type GetAffiliateProgramsAggregateType<T extends AffiliateProgramsAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliatePrograms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliatePrograms[P]>
      : GetScalarType<T[P], AggregateAffiliatePrograms[P]>
  }




  export type AffiliateProgramsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProgramsWhereInput
    orderBy?: AffiliateProgramsOrderByWithAggregationInput | AffiliateProgramsOrderByWithAggregationInput[]
    by: AffiliateProgramsScalarFieldEnum[] | AffiliateProgramsScalarFieldEnum
    having?: AffiliateProgramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateProgramsCountAggregateInputType | true
    _avg?: AffiliateProgramsAvgAggregateInputType
    _sum?: AffiliateProgramsSumAggregateInputType
    _min?: AffiliateProgramsMinAggregateInputType
    _max?: AffiliateProgramsMaxAggregateInputType
  }

  export type AffiliateProgramsGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    program_id: number
    created_at: bigint
    updated_at: bigint
    _count: AffiliateProgramsCountAggregateOutputType | null
    _avg: AffiliateProgramsAvgAggregateOutputType | null
    _sum: AffiliateProgramsSumAggregateOutputType | null
    _min: AffiliateProgramsMinAggregateOutputType | null
    _max: AffiliateProgramsMaxAggregateOutputType | null
  }

  type GetAffiliateProgramsGroupByPayload<T extends AffiliateProgramsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateProgramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateProgramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateProgramsGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateProgramsGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateProgramsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    program_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliatePrograms"]>

  export type AffiliateProgramsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    program_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliatePrograms"]>

  export type AffiliateProgramsSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    program_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AffiliateProgramsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type AffiliateProgramsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $AffiliateProgramsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliatePrograms"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      programs: Prisma.$ProgramsPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      program_id: number
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["affiliatePrograms"]>
    composites: {}
  }

  type AffiliateProgramsGetPayload<S extends boolean | null | undefined | AffiliateProgramsDefaultArgs> = $Result.GetResult<Prisma.$AffiliateProgramsPayload, S>

  type AffiliateProgramsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateProgramsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateProgramsCountAggregateInputType | true
    }

  export interface AffiliateProgramsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliatePrograms'], meta: { name: 'AffiliatePrograms' } }
    /**
     * Find zero or one AffiliatePrograms that matches the filter.
     * @param {AffiliateProgramsFindUniqueArgs} args - Arguments to find a AffiliatePrograms
     * @example
     * // Get one AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateProgramsFindUniqueArgs>(args: SelectSubset<T, AffiliateProgramsFindUniqueArgs<ExtArgs>>): Prisma__AffiliateProgramsClient<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliatePrograms that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateProgramsFindUniqueOrThrowArgs} args - Arguments to find a AffiliatePrograms
     * @example
     * // Get one AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateProgramsFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateProgramsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateProgramsClient<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliatePrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramsFindFirstArgs} args - Arguments to find a AffiliatePrograms
     * @example
     * // Get one AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateProgramsFindFirstArgs>(args?: SelectSubset<T, AffiliateProgramsFindFirstArgs<ExtArgs>>): Prisma__AffiliateProgramsClient<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliatePrograms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramsFindFirstOrThrowArgs} args - Arguments to find a AffiliatePrograms
     * @example
     * // Get one AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateProgramsFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateProgramsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateProgramsClient<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliatePrograms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.findMany()
     * 
     * // Get first 10 AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateProgramsWithIdOnly = await prisma.affiliatePrograms.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateProgramsFindManyArgs>(args?: SelectSubset<T, AffiliateProgramsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliatePrograms.
     * @param {AffiliateProgramsCreateArgs} args - Arguments to create a AffiliatePrograms.
     * @example
     * // Create one AffiliatePrograms
     * const AffiliatePrograms = await prisma.affiliatePrograms.create({
     *   data: {
     *     // ... data to create a AffiliatePrograms
     *   }
     * })
     * 
     */
    create<T extends AffiliateProgramsCreateArgs>(args: SelectSubset<T, AffiliateProgramsCreateArgs<ExtArgs>>): Prisma__AffiliateProgramsClient<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliatePrograms.
     * @param {AffiliateProgramsCreateManyArgs} args - Arguments to create many AffiliatePrograms.
     * @example
     * // Create many AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateProgramsCreateManyArgs>(args?: SelectSubset<T, AffiliateProgramsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliatePrograms and returns the data saved in the database.
     * @param {AffiliateProgramsCreateManyAndReturnArgs} args - Arguments to create many AffiliatePrograms.
     * @example
     * // Create many AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliatePrograms and only return the `id`
     * const affiliateProgramsWithIdOnly = await prisma.affiliatePrograms.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateProgramsCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateProgramsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliatePrograms.
     * @param {AffiliateProgramsDeleteArgs} args - Arguments to delete one AffiliatePrograms.
     * @example
     * // Delete one AffiliatePrograms
     * const AffiliatePrograms = await prisma.affiliatePrograms.delete({
     *   where: {
     *     // ... filter to delete one AffiliatePrograms
     *   }
     * })
     * 
     */
    delete<T extends AffiliateProgramsDeleteArgs>(args: SelectSubset<T, AffiliateProgramsDeleteArgs<ExtArgs>>): Prisma__AffiliateProgramsClient<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliatePrograms.
     * @param {AffiliateProgramsUpdateArgs} args - Arguments to update one AffiliatePrograms.
     * @example
     * // Update one AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateProgramsUpdateArgs>(args: SelectSubset<T, AffiliateProgramsUpdateArgs<ExtArgs>>): Prisma__AffiliateProgramsClient<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliatePrograms.
     * @param {AffiliateProgramsDeleteManyArgs} args - Arguments to filter AffiliatePrograms to delete.
     * @example
     * // Delete a few AffiliatePrograms
     * const { count } = await prisma.affiliatePrograms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateProgramsDeleteManyArgs>(args?: SelectSubset<T, AffiliateProgramsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliatePrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateProgramsUpdateManyArgs>(args: SelectSubset<T, AffiliateProgramsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliatePrograms.
     * @param {AffiliateProgramsUpsertArgs} args - Arguments to update or create a AffiliatePrograms.
     * @example
     * // Update or create a AffiliatePrograms
     * const affiliatePrograms = await prisma.affiliatePrograms.upsert({
     *   create: {
     *     // ... data to create a AffiliatePrograms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliatePrograms we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateProgramsUpsertArgs>(args: SelectSubset<T, AffiliateProgramsUpsertArgs<ExtArgs>>): Prisma__AffiliateProgramsClient<$Result.GetResult<Prisma.$AffiliateProgramsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliatePrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramsCountArgs} args - Arguments to filter AffiliatePrograms to count.
     * @example
     * // Count the number of AffiliatePrograms
     * const count = await prisma.affiliatePrograms.count({
     *   where: {
     *     // ... the filter for the AffiliatePrograms we want to count
     *   }
     * })
    **/
    count<T extends AffiliateProgramsCountArgs>(
      args?: Subset<T, AffiliateProgramsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateProgramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliatePrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateProgramsAggregateArgs>(args: Subset<T, AffiliateProgramsAggregateArgs>): Prisma.PrismaPromise<GetAffiliateProgramsAggregateType<T>>

    /**
     * Group by AffiliatePrograms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateProgramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateProgramsGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateProgramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateProgramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateProgramsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliatePrograms model
   */
  readonly fields: AffiliateProgramsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliatePrograms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateProgramsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    programs<T extends ProgramsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramsDefaultArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliatePrograms model
   */ 
  interface AffiliateProgramsFieldRefs {
    readonly id: FieldRef<"AffiliatePrograms", 'Int'>
    readonly store_id: FieldRef<"AffiliatePrograms", 'Int'>
    readonly affiliate_id: FieldRef<"AffiliatePrograms", 'Int'>
    readonly program_id: FieldRef<"AffiliatePrograms", 'Int'>
    readonly created_at: FieldRef<"AffiliatePrograms", 'BigInt'>
    readonly updated_at: FieldRef<"AffiliatePrograms", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * AffiliatePrograms findUnique
   */
  export type AffiliateProgramsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePrograms to fetch.
     */
    where: AffiliateProgramsWhereUniqueInput
  }

  /**
   * AffiliatePrograms findUniqueOrThrow
   */
  export type AffiliateProgramsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePrograms to fetch.
     */
    where: AffiliateProgramsWhereUniqueInput
  }

  /**
   * AffiliatePrograms findFirst
   */
  export type AffiliateProgramsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePrograms to fetch.
     */
    where?: AffiliateProgramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliatePrograms to fetch.
     */
    orderBy?: AffiliateProgramsOrderByWithRelationInput | AffiliateProgramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliatePrograms.
     */
    cursor?: AffiliateProgramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliatePrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliatePrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliatePrograms.
     */
    distinct?: AffiliateProgramsScalarFieldEnum | AffiliateProgramsScalarFieldEnum[]
  }

  /**
   * AffiliatePrograms findFirstOrThrow
   */
  export type AffiliateProgramsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePrograms to fetch.
     */
    where?: AffiliateProgramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliatePrograms to fetch.
     */
    orderBy?: AffiliateProgramsOrderByWithRelationInput | AffiliateProgramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliatePrograms.
     */
    cursor?: AffiliateProgramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliatePrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliatePrograms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliatePrograms.
     */
    distinct?: AffiliateProgramsScalarFieldEnum | AffiliateProgramsScalarFieldEnum[]
  }

  /**
   * AffiliatePrograms findMany
   */
  export type AffiliateProgramsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliatePrograms to fetch.
     */
    where?: AffiliateProgramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliatePrograms to fetch.
     */
    orderBy?: AffiliateProgramsOrderByWithRelationInput | AffiliateProgramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliatePrograms.
     */
    cursor?: AffiliateProgramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliatePrograms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliatePrograms.
     */
    skip?: number
    distinct?: AffiliateProgramsScalarFieldEnum | AffiliateProgramsScalarFieldEnum[]
  }

  /**
   * AffiliatePrograms create
   */
  export type AffiliateProgramsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliatePrograms.
     */
    data: XOR<AffiliateProgramsCreateInput, AffiliateProgramsUncheckedCreateInput>
  }

  /**
   * AffiliatePrograms createMany
   */
  export type AffiliateProgramsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliatePrograms.
     */
    data: AffiliateProgramsCreateManyInput | AffiliateProgramsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliatePrograms createManyAndReturn
   */
  export type AffiliateProgramsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliatePrograms.
     */
    data: AffiliateProgramsCreateManyInput | AffiliateProgramsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliatePrograms update
   */
  export type AffiliateProgramsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliatePrograms.
     */
    data: XOR<AffiliateProgramsUpdateInput, AffiliateProgramsUncheckedUpdateInput>
    /**
     * Choose, which AffiliatePrograms to update.
     */
    where: AffiliateProgramsWhereUniqueInput
  }

  /**
   * AffiliatePrograms updateMany
   */
  export type AffiliateProgramsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliatePrograms.
     */
    data: XOR<AffiliateProgramsUpdateManyMutationInput, AffiliateProgramsUncheckedUpdateManyInput>
    /**
     * Filter which AffiliatePrograms to update
     */
    where?: AffiliateProgramsWhereInput
  }

  /**
   * AffiliatePrograms upsert
   */
  export type AffiliateProgramsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliatePrograms to update in case it exists.
     */
    where: AffiliateProgramsWhereUniqueInput
    /**
     * In case the AffiliatePrograms found by the `where` argument doesn't exist, create a new AffiliatePrograms with this data.
     */
    create: XOR<AffiliateProgramsCreateInput, AffiliateProgramsUncheckedCreateInput>
    /**
     * In case the AffiliatePrograms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateProgramsUpdateInput, AffiliateProgramsUncheckedUpdateInput>
  }

  /**
   * AffiliatePrograms delete
   */
  export type AffiliateProgramsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
    /**
     * Filter which AffiliatePrograms to delete.
     */
    where: AffiliateProgramsWhereUniqueInput
  }

  /**
   * AffiliatePrograms deleteMany
   */
  export type AffiliateProgramsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliatePrograms to delete
     */
    where?: AffiliateProgramsWhereInput
  }

  /**
   * AffiliatePrograms without action
   */
  export type AffiliateProgramsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliatePrograms
     */
    select?: AffiliateProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramsInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateProgramHistory
   */

  export type AggregateAffiliateProgramHistory = {
    _count: AffiliateProgramHistoryCountAggregateOutputType | null
    _avg: AffiliateProgramHistoryAvgAggregateOutputType | null
    _sum: AffiliateProgramHistorySumAggregateOutputType | null
    _min: AffiliateProgramHistoryMinAggregateOutputType | null
    _max: AffiliateProgramHistoryMaxAggregateOutputType | null
  }

  export type AffiliateProgramHistoryAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type AffiliateProgramHistorySumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateProgramHistoryMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    program_name: string | null
    status: $Enums.ProgramHistoryStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateProgramHistoryMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    program_name: string | null
    status: $Enums.ProgramHistoryStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateProgramHistoryCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    program_id: number
    program_name: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AffiliateProgramHistoryAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProgramHistorySumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProgramHistoryMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    program_name?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProgramHistoryMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    program_name?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateProgramHistoryCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    program_name?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AffiliateProgramHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateProgramHistory to aggregate.
     */
    where?: AffiliateProgramHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProgramHistories to fetch.
     */
    orderBy?: AffiliateProgramHistoryOrderByWithRelationInput | AffiliateProgramHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateProgramHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProgramHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProgramHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateProgramHistories
    **/
    _count?: true | AffiliateProgramHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateProgramHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateProgramHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateProgramHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateProgramHistoryMaxAggregateInputType
  }

  export type GetAffiliateProgramHistoryAggregateType<T extends AffiliateProgramHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateProgramHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateProgramHistory[P]>
      : GetScalarType<T[P], AggregateAffiliateProgramHistory[P]>
  }




  export type AffiliateProgramHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateProgramHistoryWhereInput
    orderBy?: AffiliateProgramHistoryOrderByWithAggregationInput | AffiliateProgramHistoryOrderByWithAggregationInput[]
    by: AffiliateProgramHistoryScalarFieldEnum[] | AffiliateProgramHistoryScalarFieldEnum
    having?: AffiliateProgramHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateProgramHistoryCountAggregateInputType | true
    _avg?: AffiliateProgramHistoryAvgAggregateInputType
    _sum?: AffiliateProgramHistorySumAggregateInputType
    _min?: AffiliateProgramHistoryMinAggregateInputType
    _max?: AffiliateProgramHistoryMaxAggregateInputType
  }

  export type AffiliateProgramHistoryGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint
    updated_at: bigint
    _count: AffiliateProgramHistoryCountAggregateOutputType | null
    _avg: AffiliateProgramHistoryAvgAggregateOutputType | null
    _sum: AffiliateProgramHistorySumAggregateOutputType | null
    _min: AffiliateProgramHistoryMinAggregateOutputType | null
    _max: AffiliateProgramHistoryMaxAggregateOutputType | null
  }

  type GetAffiliateProgramHistoryGroupByPayload<T extends AffiliateProgramHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateProgramHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateProgramHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateProgramHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateProgramHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateProgramHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    program_id?: boolean
    program_name?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateProgramHistory"]>

  export type AffiliateProgramHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    program_id?: boolean
    program_name?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateProgramHistory"]>

  export type AffiliateProgramHistorySelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    program_id?: boolean
    program_name?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AffiliateProgramHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type AffiliateProgramHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $AffiliateProgramHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateProgramHistory"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      program_id: number
      program_name: string
      status: $Enums.ProgramHistoryStatusType
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["affiliateProgramHistory"]>
    composites: {}
  }

  type AffiliateProgramHistoryGetPayload<S extends boolean | null | undefined | AffiliateProgramHistoryDefaultArgs> = $Result.GetResult<Prisma.$AffiliateProgramHistoryPayload, S>

  type AffiliateProgramHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateProgramHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateProgramHistoryCountAggregateInputType | true
    }

  export interface AffiliateProgramHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateProgramHistory'], meta: { name: 'AffiliateProgramHistory' } }
    /**
     * Find zero or one AffiliateProgramHistory that matches the filter.
     * @param {AffiliateProgramHistoryFindUniqueArgs} args - Arguments to find a AffiliateProgramHistory
     * @example
     * // Get one AffiliateProgramHistory
     * const affiliateProgramHistory = await prisma.affiliateProgramHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateProgramHistoryFindUniqueArgs>(args: SelectSubset<T, AffiliateProgramHistoryFindUniqueArgs<ExtArgs>>): Prisma__AffiliateProgramHistoryClient<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateProgramHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateProgramHistoryFindUniqueOrThrowArgs} args - Arguments to find a AffiliateProgramHistory
     * @example
     * // Get one AffiliateProgramHistory
     * const affiliateProgramHistory = await prisma.affiliateProgramHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateProgramHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateProgramHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateProgramHistoryClient<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateProgramHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramHistoryFindFirstArgs} args - Arguments to find a AffiliateProgramHistory
     * @example
     * // Get one AffiliateProgramHistory
     * const affiliateProgramHistory = await prisma.affiliateProgramHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateProgramHistoryFindFirstArgs>(args?: SelectSubset<T, AffiliateProgramHistoryFindFirstArgs<ExtArgs>>): Prisma__AffiliateProgramHistoryClient<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateProgramHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramHistoryFindFirstOrThrowArgs} args - Arguments to find a AffiliateProgramHistory
     * @example
     * // Get one AffiliateProgramHistory
     * const affiliateProgramHistory = await prisma.affiliateProgramHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateProgramHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateProgramHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateProgramHistoryClient<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateProgramHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateProgramHistories
     * const affiliateProgramHistories = await prisma.affiliateProgramHistory.findMany()
     * 
     * // Get first 10 AffiliateProgramHistories
     * const affiliateProgramHistories = await prisma.affiliateProgramHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateProgramHistoryWithIdOnly = await prisma.affiliateProgramHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateProgramHistoryFindManyArgs>(args?: SelectSubset<T, AffiliateProgramHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateProgramHistory.
     * @param {AffiliateProgramHistoryCreateArgs} args - Arguments to create a AffiliateProgramHistory.
     * @example
     * // Create one AffiliateProgramHistory
     * const AffiliateProgramHistory = await prisma.affiliateProgramHistory.create({
     *   data: {
     *     // ... data to create a AffiliateProgramHistory
     *   }
     * })
     * 
     */
    create<T extends AffiliateProgramHistoryCreateArgs>(args: SelectSubset<T, AffiliateProgramHistoryCreateArgs<ExtArgs>>): Prisma__AffiliateProgramHistoryClient<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateProgramHistories.
     * @param {AffiliateProgramHistoryCreateManyArgs} args - Arguments to create many AffiliateProgramHistories.
     * @example
     * // Create many AffiliateProgramHistories
     * const affiliateProgramHistory = await prisma.affiliateProgramHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateProgramHistoryCreateManyArgs>(args?: SelectSubset<T, AffiliateProgramHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateProgramHistories and returns the data saved in the database.
     * @param {AffiliateProgramHistoryCreateManyAndReturnArgs} args - Arguments to create many AffiliateProgramHistories.
     * @example
     * // Create many AffiliateProgramHistories
     * const affiliateProgramHistory = await prisma.affiliateProgramHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateProgramHistories and only return the `id`
     * const affiliateProgramHistoryWithIdOnly = await prisma.affiliateProgramHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateProgramHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateProgramHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateProgramHistory.
     * @param {AffiliateProgramHistoryDeleteArgs} args - Arguments to delete one AffiliateProgramHistory.
     * @example
     * // Delete one AffiliateProgramHistory
     * const AffiliateProgramHistory = await prisma.affiliateProgramHistory.delete({
     *   where: {
     *     // ... filter to delete one AffiliateProgramHistory
     *   }
     * })
     * 
     */
    delete<T extends AffiliateProgramHistoryDeleteArgs>(args: SelectSubset<T, AffiliateProgramHistoryDeleteArgs<ExtArgs>>): Prisma__AffiliateProgramHistoryClient<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateProgramHistory.
     * @param {AffiliateProgramHistoryUpdateArgs} args - Arguments to update one AffiliateProgramHistory.
     * @example
     * // Update one AffiliateProgramHistory
     * const affiliateProgramHistory = await prisma.affiliateProgramHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateProgramHistoryUpdateArgs>(args: SelectSubset<T, AffiliateProgramHistoryUpdateArgs<ExtArgs>>): Prisma__AffiliateProgramHistoryClient<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateProgramHistories.
     * @param {AffiliateProgramHistoryDeleteManyArgs} args - Arguments to filter AffiliateProgramHistories to delete.
     * @example
     * // Delete a few AffiliateProgramHistories
     * const { count } = await prisma.affiliateProgramHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateProgramHistoryDeleteManyArgs>(args?: SelectSubset<T, AffiliateProgramHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateProgramHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateProgramHistories
     * const affiliateProgramHistory = await prisma.affiliateProgramHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateProgramHistoryUpdateManyArgs>(args: SelectSubset<T, AffiliateProgramHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateProgramHistory.
     * @param {AffiliateProgramHistoryUpsertArgs} args - Arguments to update or create a AffiliateProgramHistory.
     * @example
     * // Update or create a AffiliateProgramHistory
     * const affiliateProgramHistory = await prisma.affiliateProgramHistory.upsert({
     *   create: {
     *     // ... data to create a AffiliateProgramHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateProgramHistory we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateProgramHistoryUpsertArgs>(args: SelectSubset<T, AffiliateProgramHistoryUpsertArgs<ExtArgs>>): Prisma__AffiliateProgramHistoryClient<$Result.GetResult<Prisma.$AffiliateProgramHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateProgramHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramHistoryCountArgs} args - Arguments to filter AffiliateProgramHistories to count.
     * @example
     * // Count the number of AffiliateProgramHistories
     * const count = await prisma.affiliateProgramHistory.count({
     *   where: {
     *     // ... the filter for the AffiliateProgramHistories we want to count
     *   }
     * })
    **/
    count<T extends AffiliateProgramHistoryCountArgs>(
      args?: Subset<T, AffiliateProgramHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateProgramHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateProgramHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateProgramHistoryAggregateArgs>(args: Subset<T, AffiliateProgramHistoryAggregateArgs>): Prisma.PrismaPromise<GetAffiliateProgramHistoryAggregateType<T>>

    /**
     * Group by AffiliateProgramHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateProgramHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateProgramHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateProgramHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateProgramHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateProgramHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateProgramHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateProgramHistory model
   */
  readonly fields: AffiliateProgramHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateProgramHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateProgramHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateProgramHistory model
   */ 
  interface AffiliateProgramHistoryFieldRefs {
    readonly id: FieldRef<"AffiliateProgramHistory", 'Int'>
    readonly store_id: FieldRef<"AffiliateProgramHistory", 'Int'>
    readonly affiliate_id: FieldRef<"AffiliateProgramHistory", 'Int'>
    readonly program_id: FieldRef<"AffiliateProgramHistory", 'Int'>
    readonly program_name: FieldRef<"AffiliateProgramHistory", 'String'>
    readonly status: FieldRef<"AffiliateProgramHistory", 'ProgramHistoryStatusType'>
    readonly created_at: FieldRef<"AffiliateProgramHistory", 'BigInt'>
    readonly updated_at: FieldRef<"AffiliateProgramHistory", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateProgramHistory findUnique
   */
  export type AffiliateProgramHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProgramHistory to fetch.
     */
    where: AffiliateProgramHistoryWhereUniqueInput
  }

  /**
   * AffiliateProgramHistory findUniqueOrThrow
   */
  export type AffiliateProgramHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProgramHistory to fetch.
     */
    where: AffiliateProgramHistoryWhereUniqueInput
  }

  /**
   * AffiliateProgramHistory findFirst
   */
  export type AffiliateProgramHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProgramHistory to fetch.
     */
    where?: AffiliateProgramHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProgramHistories to fetch.
     */
    orderBy?: AffiliateProgramHistoryOrderByWithRelationInput | AffiliateProgramHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateProgramHistories.
     */
    cursor?: AffiliateProgramHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProgramHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProgramHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateProgramHistories.
     */
    distinct?: AffiliateProgramHistoryScalarFieldEnum | AffiliateProgramHistoryScalarFieldEnum[]
  }

  /**
   * AffiliateProgramHistory findFirstOrThrow
   */
  export type AffiliateProgramHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProgramHistory to fetch.
     */
    where?: AffiliateProgramHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProgramHistories to fetch.
     */
    orderBy?: AffiliateProgramHistoryOrderByWithRelationInput | AffiliateProgramHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateProgramHistories.
     */
    cursor?: AffiliateProgramHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProgramHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProgramHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateProgramHistories.
     */
    distinct?: AffiliateProgramHistoryScalarFieldEnum | AffiliateProgramHistoryScalarFieldEnum[]
  }

  /**
   * AffiliateProgramHistory findMany
   */
  export type AffiliateProgramHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateProgramHistories to fetch.
     */
    where?: AffiliateProgramHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateProgramHistories to fetch.
     */
    orderBy?: AffiliateProgramHistoryOrderByWithRelationInput | AffiliateProgramHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateProgramHistories.
     */
    cursor?: AffiliateProgramHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateProgramHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateProgramHistories.
     */
    skip?: number
    distinct?: AffiliateProgramHistoryScalarFieldEnum | AffiliateProgramHistoryScalarFieldEnum[]
  }

  /**
   * AffiliateProgramHistory create
   */
  export type AffiliateProgramHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateProgramHistory.
     */
    data: XOR<AffiliateProgramHistoryCreateInput, AffiliateProgramHistoryUncheckedCreateInput>
  }

  /**
   * AffiliateProgramHistory createMany
   */
  export type AffiliateProgramHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateProgramHistories.
     */
    data: AffiliateProgramHistoryCreateManyInput | AffiliateProgramHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateProgramHistory createManyAndReturn
   */
  export type AffiliateProgramHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateProgramHistories.
     */
    data: AffiliateProgramHistoryCreateManyInput | AffiliateProgramHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateProgramHistory update
   */
  export type AffiliateProgramHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateProgramHistory.
     */
    data: XOR<AffiliateProgramHistoryUpdateInput, AffiliateProgramHistoryUncheckedUpdateInput>
    /**
     * Choose, which AffiliateProgramHistory to update.
     */
    where: AffiliateProgramHistoryWhereUniqueInput
  }

  /**
   * AffiliateProgramHistory updateMany
   */
  export type AffiliateProgramHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateProgramHistories.
     */
    data: XOR<AffiliateProgramHistoryUpdateManyMutationInput, AffiliateProgramHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateProgramHistories to update
     */
    where?: AffiliateProgramHistoryWhereInput
  }

  /**
   * AffiliateProgramHistory upsert
   */
  export type AffiliateProgramHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateProgramHistory to update in case it exists.
     */
    where: AffiliateProgramHistoryWhereUniqueInput
    /**
     * In case the AffiliateProgramHistory found by the `where` argument doesn't exist, create a new AffiliateProgramHistory with this data.
     */
    create: XOR<AffiliateProgramHistoryCreateInput, AffiliateProgramHistoryUncheckedCreateInput>
    /**
     * In case the AffiliateProgramHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateProgramHistoryUpdateInput, AffiliateProgramHistoryUncheckedUpdateInput>
  }

  /**
   * AffiliateProgramHistory delete
   */
  export type AffiliateProgramHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
    /**
     * Filter which AffiliateProgramHistory to delete.
     */
    where: AffiliateProgramHistoryWhereUniqueInput
  }

  /**
   * AffiliateProgramHistory deleteMany
   */
  export type AffiliateProgramHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateProgramHistories to delete
     */
    where?: AffiliateProgramHistoryWhereInput
  }

  /**
   * AffiliateProgramHistory without action
   */
  export type AffiliateProgramHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateProgramHistory
     */
    select?: AffiliateProgramHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateProgramHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateDiscounts
   */

  export type AggregateAffiliateDiscounts = {
    _count: AffiliateDiscountsCountAggregateOutputType | null
    _avg: AffiliateDiscountsAvgAggregateOutputType | null
    _sum: AffiliateDiscountsSumAggregateOutputType | null
    _min: AffiliateDiscountsMinAggregateOutputType | null
    _max: AffiliateDiscountsMaxAggregateOutputType | null
  }

  export type AffiliateDiscountsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    discount_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type AffiliateDiscountsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    discount_id: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateDiscountsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    discount_id: bigint | null
    discount_code: string | null
    is_deleted: boolean | null
    status: $Enums.DiscountStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateDiscountsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    discount_id: bigint | null
    discount_code: string | null
    is_deleted: boolean | null
    status: $Enums.DiscountStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateDiscountsCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    discount_id: number
    discount_code: number
    is_deleted: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AffiliateDiscountsAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    discount_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateDiscountsSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    discount_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateDiscountsMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    discount_id?: true
    discount_code?: true
    is_deleted?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateDiscountsMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    discount_id?: true
    discount_code?: true
    is_deleted?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateDiscountsCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    discount_id?: true
    discount_code?: true
    is_deleted?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AffiliateDiscountsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateDiscounts to aggregate.
     */
    where?: AffiliateDiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateDiscounts to fetch.
     */
    orderBy?: AffiliateDiscountsOrderByWithRelationInput | AffiliateDiscountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateDiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateDiscounts
    **/
    _count?: true | AffiliateDiscountsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateDiscountsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateDiscountsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateDiscountsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateDiscountsMaxAggregateInputType
  }

  export type GetAffiliateDiscountsAggregateType<T extends AffiliateDiscountsAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateDiscounts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateDiscounts[P]>
      : GetScalarType<T[P], AggregateAffiliateDiscounts[P]>
  }




  export type AffiliateDiscountsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateDiscountsWhereInput
    orderBy?: AffiliateDiscountsOrderByWithAggregationInput | AffiliateDiscountsOrderByWithAggregationInput[]
    by: AffiliateDiscountsScalarFieldEnum[] | AffiliateDiscountsScalarFieldEnum
    having?: AffiliateDiscountsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateDiscountsCountAggregateInputType | true
    _avg?: AffiliateDiscountsAvgAggregateInputType
    _sum?: AffiliateDiscountsSumAggregateInputType
    _min?: AffiliateDiscountsMinAggregateInputType
    _max?: AffiliateDiscountsMaxAggregateInputType
  }

  export type AffiliateDiscountsGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    discount_id: bigint
    discount_code: string
    is_deleted: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint
    updated_at: bigint
    _count: AffiliateDiscountsCountAggregateOutputType | null
    _avg: AffiliateDiscountsAvgAggregateOutputType | null
    _sum: AffiliateDiscountsSumAggregateOutputType | null
    _min: AffiliateDiscountsMinAggregateOutputType | null
    _max: AffiliateDiscountsMaxAggregateOutputType | null
  }

  type GetAffiliateDiscountsGroupByPayload<T extends AffiliateDiscountsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateDiscountsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateDiscountsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateDiscountsGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateDiscountsGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateDiscountsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    discount_id?: boolean
    discount_code?: boolean
    is_deleted?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateDiscounts"]>

  export type AffiliateDiscountsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    discount_id?: boolean
    discount_code?: boolean
    is_deleted?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateDiscounts"]>

  export type AffiliateDiscountsSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    discount_id?: boolean
    discount_code?: boolean
    is_deleted?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AffiliateDiscountsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type AffiliateDiscountsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $AffiliateDiscountsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateDiscounts"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      discount_id: bigint
      discount_code: string
      is_deleted: boolean | null
      status: $Enums.DiscountStatusType
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["affiliateDiscounts"]>
    composites: {}
  }

  type AffiliateDiscountsGetPayload<S extends boolean | null | undefined | AffiliateDiscountsDefaultArgs> = $Result.GetResult<Prisma.$AffiliateDiscountsPayload, S>

  type AffiliateDiscountsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateDiscountsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateDiscountsCountAggregateInputType | true
    }

  export interface AffiliateDiscountsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateDiscounts'], meta: { name: 'AffiliateDiscounts' } }
    /**
     * Find zero or one AffiliateDiscounts that matches the filter.
     * @param {AffiliateDiscountsFindUniqueArgs} args - Arguments to find a AffiliateDiscounts
     * @example
     * // Get one AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateDiscountsFindUniqueArgs>(args: SelectSubset<T, AffiliateDiscountsFindUniqueArgs<ExtArgs>>): Prisma__AffiliateDiscountsClient<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateDiscounts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateDiscountsFindUniqueOrThrowArgs} args - Arguments to find a AffiliateDiscounts
     * @example
     * // Get one AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateDiscountsFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateDiscountsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateDiscountsClient<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateDiscountsFindFirstArgs} args - Arguments to find a AffiliateDiscounts
     * @example
     * // Get one AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateDiscountsFindFirstArgs>(args?: SelectSubset<T, AffiliateDiscountsFindFirstArgs<ExtArgs>>): Prisma__AffiliateDiscountsClient<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateDiscounts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateDiscountsFindFirstOrThrowArgs} args - Arguments to find a AffiliateDiscounts
     * @example
     * // Get one AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateDiscountsFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateDiscountsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateDiscountsClient<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateDiscounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateDiscountsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.findMany()
     * 
     * // Get first 10 AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateDiscountsWithIdOnly = await prisma.affiliateDiscounts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateDiscountsFindManyArgs>(args?: SelectSubset<T, AffiliateDiscountsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateDiscounts.
     * @param {AffiliateDiscountsCreateArgs} args - Arguments to create a AffiliateDiscounts.
     * @example
     * // Create one AffiliateDiscounts
     * const AffiliateDiscounts = await prisma.affiliateDiscounts.create({
     *   data: {
     *     // ... data to create a AffiliateDiscounts
     *   }
     * })
     * 
     */
    create<T extends AffiliateDiscountsCreateArgs>(args: SelectSubset<T, AffiliateDiscountsCreateArgs<ExtArgs>>): Prisma__AffiliateDiscountsClient<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateDiscounts.
     * @param {AffiliateDiscountsCreateManyArgs} args - Arguments to create many AffiliateDiscounts.
     * @example
     * // Create many AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateDiscountsCreateManyArgs>(args?: SelectSubset<T, AffiliateDiscountsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateDiscounts and returns the data saved in the database.
     * @param {AffiliateDiscountsCreateManyAndReturnArgs} args - Arguments to create many AffiliateDiscounts.
     * @example
     * // Create many AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateDiscounts and only return the `id`
     * const affiliateDiscountsWithIdOnly = await prisma.affiliateDiscounts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateDiscountsCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateDiscountsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateDiscounts.
     * @param {AffiliateDiscountsDeleteArgs} args - Arguments to delete one AffiliateDiscounts.
     * @example
     * // Delete one AffiliateDiscounts
     * const AffiliateDiscounts = await prisma.affiliateDiscounts.delete({
     *   where: {
     *     // ... filter to delete one AffiliateDiscounts
     *   }
     * })
     * 
     */
    delete<T extends AffiliateDiscountsDeleteArgs>(args: SelectSubset<T, AffiliateDiscountsDeleteArgs<ExtArgs>>): Prisma__AffiliateDiscountsClient<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateDiscounts.
     * @param {AffiliateDiscountsUpdateArgs} args - Arguments to update one AffiliateDiscounts.
     * @example
     * // Update one AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateDiscountsUpdateArgs>(args: SelectSubset<T, AffiliateDiscountsUpdateArgs<ExtArgs>>): Prisma__AffiliateDiscountsClient<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateDiscounts.
     * @param {AffiliateDiscountsDeleteManyArgs} args - Arguments to filter AffiliateDiscounts to delete.
     * @example
     * // Delete a few AffiliateDiscounts
     * const { count } = await prisma.affiliateDiscounts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateDiscountsDeleteManyArgs>(args?: SelectSubset<T, AffiliateDiscountsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateDiscountsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateDiscountsUpdateManyArgs>(args: SelectSubset<T, AffiliateDiscountsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateDiscounts.
     * @param {AffiliateDiscountsUpsertArgs} args - Arguments to update or create a AffiliateDiscounts.
     * @example
     * // Update or create a AffiliateDiscounts
     * const affiliateDiscounts = await prisma.affiliateDiscounts.upsert({
     *   create: {
     *     // ... data to create a AffiliateDiscounts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateDiscounts we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateDiscountsUpsertArgs>(args: SelectSubset<T, AffiliateDiscountsUpsertArgs<ExtArgs>>): Prisma__AffiliateDiscountsClient<$Result.GetResult<Prisma.$AffiliateDiscountsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateDiscountsCountArgs} args - Arguments to filter AffiliateDiscounts to count.
     * @example
     * // Count the number of AffiliateDiscounts
     * const count = await prisma.affiliateDiscounts.count({
     *   where: {
     *     // ... the filter for the AffiliateDiscounts we want to count
     *   }
     * })
    **/
    count<T extends AffiliateDiscountsCountArgs>(
      args?: Subset<T, AffiliateDiscountsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateDiscountsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateDiscountsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateDiscountsAggregateArgs>(args: Subset<T, AffiliateDiscountsAggregateArgs>): Prisma.PrismaPromise<GetAffiliateDiscountsAggregateType<T>>

    /**
     * Group by AffiliateDiscounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateDiscountsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateDiscountsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateDiscountsGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateDiscountsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateDiscountsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateDiscountsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateDiscounts model
   */
  readonly fields: AffiliateDiscountsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateDiscounts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateDiscountsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateDiscounts model
   */ 
  interface AffiliateDiscountsFieldRefs {
    readonly id: FieldRef<"AffiliateDiscounts", 'Int'>
    readonly store_id: FieldRef<"AffiliateDiscounts", 'Int'>
    readonly affiliate_id: FieldRef<"AffiliateDiscounts", 'Int'>
    readonly discount_id: FieldRef<"AffiliateDiscounts", 'BigInt'>
    readonly discount_code: FieldRef<"AffiliateDiscounts", 'String'>
    readonly is_deleted: FieldRef<"AffiliateDiscounts", 'Boolean'>
    readonly status: FieldRef<"AffiliateDiscounts", 'DiscountStatusType'>
    readonly created_at: FieldRef<"AffiliateDiscounts", 'BigInt'>
    readonly updated_at: FieldRef<"AffiliateDiscounts", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateDiscounts findUnique
   */
  export type AffiliateDiscountsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateDiscounts to fetch.
     */
    where: AffiliateDiscountsWhereUniqueInput
  }

  /**
   * AffiliateDiscounts findUniqueOrThrow
   */
  export type AffiliateDiscountsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateDiscounts to fetch.
     */
    where: AffiliateDiscountsWhereUniqueInput
  }

  /**
   * AffiliateDiscounts findFirst
   */
  export type AffiliateDiscountsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateDiscounts to fetch.
     */
    where?: AffiliateDiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateDiscounts to fetch.
     */
    orderBy?: AffiliateDiscountsOrderByWithRelationInput | AffiliateDiscountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateDiscounts.
     */
    cursor?: AffiliateDiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateDiscounts.
     */
    distinct?: AffiliateDiscountsScalarFieldEnum | AffiliateDiscountsScalarFieldEnum[]
  }

  /**
   * AffiliateDiscounts findFirstOrThrow
   */
  export type AffiliateDiscountsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateDiscounts to fetch.
     */
    where?: AffiliateDiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateDiscounts to fetch.
     */
    orderBy?: AffiliateDiscountsOrderByWithRelationInput | AffiliateDiscountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateDiscounts.
     */
    cursor?: AffiliateDiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateDiscounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateDiscounts.
     */
    distinct?: AffiliateDiscountsScalarFieldEnum | AffiliateDiscountsScalarFieldEnum[]
  }

  /**
   * AffiliateDiscounts findMany
   */
  export type AffiliateDiscountsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateDiscounts to fetch.
     */
    where?: AffiliateDiscountsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateDiscounts to fetch.
     */
    orderBy?: AffiliateDiscountsOrderByWithRelationInput | AffiliateDiscountsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateDiscounts.
     */
    cursor?: AffiliateDiscountsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateDiscounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateDiscounts.
     */
    skip?: number
    distinct?: AffiliateDiscountsScalarFieldEnum | AffiliateDiscountsScalarFieldEnum[]
  }

  /**
   * AffiliateDiscounts create
   */
  export type AffiliateDiscountsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateDiscounts.
     */
    data: XOR<AffiliateDiscountsCreateInput, AffiliateDiscountsUncheckedCreateInput>
  }

  /**
   * AffiliateDiscounts createMany
   */
  export type AffiliateDiscountsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateDiscounts.
     */
    data: AffiliateDiscountsCreateManyInput | AffiliateDiscountsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateDiscounts createManyAndReturn
   */
  export type AffiliateDiscountsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateDiscounts.
     */
    data: AffiliateDiscountsCreateManyInput | AffiliateDiscountsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateDiscounts update
   */
  export type AffiliateDiscountsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateDiscounts.
     */
    data: XOR<AffiliateDiscountsUpdateInput, AffiliateDiscountsUncheckedUpdateInput>
    /**
     * Choose, which AffiliateDiscounts to update.
     */
    where: AffiliateDiscountsWhereUniqueInput
  }

  /**
   * AffiliateDiscounts updateMany
   */
  export type AffiliateDiscountsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateDiscounts.
     */
    data: XOR<AffiliateDiscountsUpdateManyMutationInput, AffiliateDiscountsUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateDiscounts to update
     */
    where?: AffiliateDiscountsWhereInput
  }

  /**
   * AffiliateDiscounts upsert
   */
  export type AffiliateDiscountsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateDiscounts to update in case it exists.
     */
    where: AffiliateDiscountsWhereUniqueInput
    /**
     * In case the AffiliateDiscounts found by the `where` argument doesn't exist, create a new AffiliateDiscounts with this data.
     */
    create: XOR<AffiliateDiscountsCreateInput, AffiliateDiscountsUncheckedCreateInput>
    /**
     * In case the AffiliateDiscounts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateDiscountsUpdateInput, AffiliateDiscountsUncheckedUpdateInput>
  }

  /**
   * AffiliateDiscounts delete
   */
  export type AffiliateDiscountsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
    /**
     * Filter which AffiliateDiscounts to delete.
     */
    where: AffiliateDiscountsWhereUniqueInput
  }

  /**
   * AffiliateDiscounts deleteMany
   */
  export type AffiliateDiscountsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateDiscounts to delete
     */
    where?: AffiliateDiscountsWhereInput
  }

  /**
   * AffiliateDiscounts without action
   */
  export type AffiliateDiscountsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateDiscounts
     */
    select?: AffiliateDiscountsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateDiscountsInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateGifts
   */

  export type AggregateAffiliateGifts = {
    _count: AffiliateGiftsCountAggregateOutputType | null
    _avg: AffiliateGiftsAvgAggregateOutputType | null
    _sum: AffiliateGiftsSumAggregateOutputType | null
    _min: AffiliateGiftsMinAggregateOutputType | null
    _max: AffiliateGiftsMaxAggregateOutputType | null
  }

  export type AffiliateGiftsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    gift_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type AffiliateGiftsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    gift_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateGiftsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    gift_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateGiftsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    gift_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateGiftsCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    gift_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AffiliateGiftsAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    gift_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateGiftsSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    gift_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateGiftsMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    gift_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateGiftsMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    gift_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateGiftsCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    gift_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AffiliateGiftsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateGifts to aggregate.
     */
    where?: AffiliateGiftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateGifts to fetch.
     */
    orderBy?: AffiliateGiftsOrderByWithRelationInput | AffiliateGiftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateGiftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateGifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateGifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateGifts
    **/
    _count?: true | AffiliateGiftsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateGiftsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateGiftsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateGiftsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateGiftsMaxAggregateInputType
  }

  export type GetAffiliateGiftsAggregateType<T extends AffiliateGiftsAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateGifts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateGifts[P]>
      : GetScalarType<T[P], AggregateAffiliateGifts[P]>
  }




  export type AffiliateGiftsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateGiftsWhereInput
    orderBy?: AffiliateGiftsOrderByWithAggregationInput | AffiliateGiftsOrderByWithAggregationInput[]
    by: AffiliateGiftsScalarFieldEnum[] | AffiliateGiftsScalarFieldEnum
    having?: AffiliateGiftsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateGiftsCountAggregateInputType | true
    _avg?: AffiliateGiftsAvgAggregateInputType
    _sum?: AffiliateGiftsSumAggregateInputType
    _min?: AffiliateGiftsMinAggregateInputType
    _max?: AffiliateGiftsMaxAggregateInputType
  }

  export type AffiliateGiftsGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    gift_id: number
    created_at: bigint
    updated_at: bigint
    _count: AffiliateGiftsCountAggregateOutputType | null
    _avg: AffiliateGiftsAvgAggregateOutputType | null
    _sum: AffiliateGiftsSumAggregateOutputType | null
    _min: AffiliateGiftsMinAggregateOutputType | null
    _max: AffiliateGiftsMaxAggregateOutputType | null
  }

  type GetAffiliateGiftsGroupByPayload<T extends AffiliateGiftsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateGiftsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateGiftsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateGiftsGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateGiftsGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateGiftsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    gift_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    gifts?: boolean | GiftsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateGifts"]>

  export type AffiliateGiftsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    gift_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    gifts?: boolean | GiftsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateGifts"]>

  export type AffiliateGiftsSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    gift_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AffiliateGiftsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    gifts?: boolean | GiftsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type AffiliateGiftsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    gifts?: boolean | GiftsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $AffiliateGiftsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateGifts"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      gifts: Prisma.$GiftsPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      gift_id: number
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["affiliateGifts"]>
    composites: {}
  }

  type AffiliateGiftsGetPayload<S extends boolean | null | undefined | AffiliateGiftsDefaultArgs> = $Result.GetResult<Prisma.$AffiliateGiftsPayload, S>

  type AffiliateGiftsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateGiftsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateGiftsCountAggregateInputType | true
    }

  export interface AffiliateGiftsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateGifts'], meta: { name: 'AffiliateGifts' } }
    /**
     * Find zero or one AffiliateGifts that matches the filter.
     * @param {AffiliateGiftsFindUniqueArgs} args - Arguments to find a AffiliateGifts
     * @example
     * // Get one AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateGiftsFindUniqueArgs>(args: SelectSubset<T, AffiliateGiftsFindUniqueArgs<ExtArgs>>): Prisma__AffiliateGiftsClient<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateGifts that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateGiftsFindUniqueOrThrowArgs} args - Arguments to find a AffiliateGifts
     * @example
     * // Get one AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateGiftsFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateGiftsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateGiftsClient<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateGifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateGiftsFindFirstArgs} args - Arguments to find a AffiliateGifts
     * @example
     * // Get one AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateGiftsFindFirstArgs>(args?: SelectSubset<T, AffiliateGiftsFindFirstArgs<ExtArgs>>): Prisma__AffiliateGiftsClient<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateGifts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateGiftsFindFirstOrThrowArgs} args - Arguments to find a AffiliateGifts
     * @example
     * // Get one AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateGiftsFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateGiftsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateGiftsClient<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateGifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateGiftsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.findMany()
     * 
     * // Get first 10 AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateGiftsWithIdOnly = await prisma.affiliateGifts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateGiftsFindManyArgs>(args?: SelectSubset<T, AffiliateGiftsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateGifts.
     * @param {AffiliateGiftsCreateArgs} args - Arguments to create a AffiliateGifts.
     * @example
     * // Create one AffiliateGifts
     * const AffiliateGifts = await prisma.affiliateGifts.create({
     *   data: {
     *     // ... data to create a AffiliateGifts
     *   }
     * })
     * 
     */
    create<T extends AffiliateGiftsCreateArgs>(args: SelectSubset<T, AffiliateGiftsCreateArgs<ExtArgs>>): Prisma__AffiliateGiftsClient<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateGifts.
     * @param {AffiliateGiftsCreateManyArgs} args - Arguments to create many AffiliateGifts.
     * @example
     * // Create many AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateGiftsCreateManyArgs>(args?: SelectSubset<T, AffiliateGiftsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateGifts and returns the data saved in the database.
     * @param {AffiliateGiftsCreateManyAndReturnArgs} args - Arguments to create many AffiliateGifts.
     * @example
     * // Create many AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateGifts and only return the `id`
     * const affiliateGiftsWithIdOnly = await prisma.affiliateGifts.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateGiftsCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateGiftsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateGifts.
     * @param {AffiliateGiftsDeleteArgs} args - Arguments to delete one AffiliateGifts.
     * @example
     * // Delete one AffiliateGifts
     * const AffiliateGifts = await prisma.affiliateGifts.delete({
     *   where: {
     *     // ... filter to delete one AffiliateGifts
     *   }
     * })
     * 
     */
    delete<T extends AffiliateGiftsDeleteArgs>(args: SelectSubset<T, AffiliateGiftsDeleteArgs<ExtArgs>>): Prisma__AffiliateGiftsClient<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateGifts.
     * @param {AffiliateGiftsUpdateArgs} args - Arguments to update one AffiliateGifts.
     * @example
     * // Update one AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateGiftsUpdateArgs>(args: SelectSubset<T, AffiliateGiftsUpdateArgs<ExtArgs>>): Prisma__AffiliateGiftsClient<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateGifts.
     * @param {AffiliateGiftsDeleteManyArgs} args - Arguments to filter AffiliateGifts to delete.
     * @example
     * // Delete a few AffiliateGifts
     * const { count } = await prisma.affiliateGifts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateGiftsDeleteManyArgs>(args?: SelectSubset<T, AffiliateGiftsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateGifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateGiftsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateGiftsUpdateManyArgs>(args: SelectSubset<T, AffiliateGiftsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateGifts.
     * @param {AffiliateGiftsUpsertArgs} args - Arguments to update or create a AffiliateGifts.
     * @example
     * // Update or create a AffiliateGifts
     * const affiliateGifts = await prisma.affiliateGifts.upsert({
     *   create: {
     *     // ... data to create a AffiliateGifts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateGifts we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateGiftsUpsertArgs>(args: SelectSubset<T, AffiliateGiftsUpsertArgs<ExtArgs>>): Prisma__AffiliateGiftsClient<$Result.GetResult<Prisma.$AffiliateGiftsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateGifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateGiftsCountArgs} args - Arguments to filter AffiliateGifts to count.
     * @example
     * // Count the number of AffiliateGifts
     * const count = await prisma.affiliateGifts.count({
     *   where: {
     *     // ... the filter for the AffiliateGifts we want to count
     *   }
     * })
    **/
    count<T extends AffiliateGiftsCountArgs>(
      args?: Subset<T, AffiliateGiftsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateGiftsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateGifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateGiftsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateGiftsAggregateArgs>(args: Subset<T, AffiliateGiftsAggregateArgs>): Prisma.PrismaPromise<GetAffiliateGiftsAggregateType<T>>

    /**
     * Group by AffiliateGifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateGiftsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateGiftsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateGiftsGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateGiftsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateGiftsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateGiftsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateGifts model
   */
  readonly fields: AffiliateGiftsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateGifts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateGiftsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    gifts<T extends GiftsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GiftsDefaultArgs<ExtArgs>>): Prisma__GiftsClient<$Result.GetResult<Prisma.$GiftsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateGifts model
   */ 
  interface AffiliateGiftsFieldRefs {
    readonly id: FieldRef<"AffiliateGifts", 'Int'>
    readonly store_id: FieldRef<"AffiliateGifts", 'Int'>
    readonly affiliate_id: FieldRef<"AffiliateGifts", 'Int'>
    readonly gift_id: FieldRef<"AffiliateGifts", 'Int'>
    readonly created_at: FieldRef<"AffiliateGifts", 'BigInt'>
    readonly updated_at: FieldRef<"AffiliateGifts", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateGifts findUnique
   */
  export type AffiliateGiftsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateGifts to fetch.
     */
    where: AffiliateGiftsWhereUniqueInput
  }

  /**
   * AffiliateGifts findUniqueOrThrow
   */
  export type AffiliateGiftsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateGifts to fetch.
     */
    where: AffiliateGiftsWhereUniqueInput
  }

  /**
   * AffiliateGifts findFirst
   */
  export type AffiliateGiftsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateGifts to fetch.
     */
    where?: AffiliateGiftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateGifts to fetch.
     */
    orderBy?: AffiliateGiftsOrderByWithRelationInput | AffiliateGiftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateGifts.
     */
    cursor?: AffiliateGiftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateGifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateGifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateGifts.
     */
    distinct?: AffiliateGiftsScalarFieldEnum | AffiliateGiftsScalarFieldEnum[]
  }

  /**
   * AffiliateGifts findFirstOrThrow
   */
  export type AffiliateGiftsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateGifts to fetch.
     */
    where?: AffiliateGiftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateGifts to fetch.
     */
    orderBy?: AffiliateGiftsOrderByWithRelationInput | AffiliateGiftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateGifts.
     */
    cursor?: AffiliateGiftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateGifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateGifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateGifts.
     */
    distinct?: AffiliateGiftsScalarFieldEnum | AffiliateGiftsScalarFieldEnum[]
  }

  /**
   * AffiliateGifts findMany
   */
  export type AffiliateGiftsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateGifts to fetch.
     */
    where?: AffiliateGiftsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateGifts to fetch.
     */
    orderBy?: AffiliateGiftsOrderByWithRelationInput | AffiliateGiftsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateGifts.
     */
    cursor?: AffiliateGiftsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateGifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateGifts.
     */
    skip?: number
    distinct?: AffiliateGiftsScalarFieldEnum | AffiliateGiftsScalarFieldEnum[]
  }

  /**
   * AffiliateGifts create
   */
  export type AffiliateGiftsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateGifts.
     */
    data: XOR<AffiliateGiftsCreateInput, AffiliateGiftsUncheckedCreateInput>
  }

  /**
   * AffiliateGifts createMany
   */
  export type AffiliateGiftsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateGifts.
     */
    data: AffiliateGiftsCreateManyInput | AffiliateGiftsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateGifts createManyAndReturn
   */
  export type AffiliateGiftsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateGifts.
     */
    data: AffiliateGiftsCreateManyInput | AffiliateGiftsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateGifts update
   */
  export type AffiliateGiftsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateGifts.
     */
    data: XOR<AffiliateGiftsUpdateInput, AffiliateGiftsUncheckedUpdateInput>
    /**
     * Choose, which AffiliateGifts to update.
     */
    where: AffiliateGiftsWhereUniqueInput
  }

  /**
   * AffiliateGifts updateMany
   */
  export type AffiliateGiftsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateGifts.
     */
    data: XOR<AffiliateGiftsUpdateManyMutationInput, AffiliateGiftsUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateGifts to update
     */
    where?: AffiliateGiftsWhereInput
  }

  /**
   * AffiliateGifts upsert
   */
  export type AffiliateGiftsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateGifts to update in case it exists.
     */
    where: AffiliateGiftsWhereUniqueInput
    /**
     * In case the AffiliateGifts found by the `where` argument doesn't exist, create a new AffiliateGifts with this data.
     */
    create: XOR<AffiliateGiftsCreateInput, AffiliateGiftsUncheckedCreateInput>
    /**
     * In case the AffiliateGifts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateGiftsUpdateInput, AffiliateGiftsUncheckedUpdateInput>
  }

  /**
   * AffiliateGifts delete
   */
  export type AffiliateGiftsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
    /**
     * Filter which AffiliateGifts to delete.
     */
    where: AffiliateGiftsWhereUniqueInput
  }

  /**
   * AffiliateGifts deleteMany
   */
  export type AffiliateGiftsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateGifts to delete
     */
    where?: AffiliateGiftsWhereInput
  }

  /**
   * AffiliateGifts without action
   */
  export type AffiliateGiftsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateGifts
     */
    select?: AffiliateGiftsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateGiftsInclude<ExtArgs> | null
  }


  /**
   * Model AffiliateBonus
   */

  export type AggregateAffiliateBonus = {
    _count: AffiliateBonusCountAggregateOutputType | null
    _avg: AffiliateBonusAvgAggregateOutputType | null
    _sum: AffiliateBonusSumAggregateOutputType | null
    _min: AffiliateBonusMinAggregateOutputType | null
    _max: AffiliateBonusMaxAggregateOutputType | null
  }

  export type AffiliateBonusAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    bonus_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type AffiliateBonusSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    bonus_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateBonusMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    bonus_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateBonusMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    bonus_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AffiliateBonusCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    bonus_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AffiliateBonusAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateBonusSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateBonusMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateBonusMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
  }

  export type AffiliateBonusCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AffiliateBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateBonus to aggregate.
     */
    where?: AffiliateBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateBonuses to fetch.
     */
    orderBy?: AffiliateBonusOrderByWithRelationInput | AffiliateBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AffiliateBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AffiliateBonuses
    **/
    _count?: true | AffiliateBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffiliateBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffiliateBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffiliateBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffiliateBonusMaxAggregateInputType
  }

  export type GetAffiliateBonusAggregateType<T extends AffiliateBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateAffiliateBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffiliateBonus[P]>
      : GetScalarType<T[P], AggregateAffiliateBonus[P]>
  }




  export type AffiliateBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AffiliateBonusWhereInput
    orderBy?: AffiliateBonusOrderByWithAggregationInput | AffiliateBonusOrderByWithAggregationInput[]
    by: AffiliateBonusScalarFieldEnum[] | AffiliateBonusScalarFieldEnum
    having?: AffiliateBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffiliateBonusCountAggregateInputType | true
    _avg?: AffiliateBonusAvgAggregateInputType
    _sum?: AffiliateBonusSumAggregateInputType
    _min?: AffiliateBonusMinAggregateInputType
    _max?: AffiliateBonusMaxAggregateInputType
  }

  export type AffiliateBonusGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    bonus_id: number
    created_at: bigint
    updated_at: bigint
    _count: AffiliateBonusCountAggregateOutputType | null
    _avg: AffiliateBonusAvgAggregateOutputType | null
    _sum: AffiliateBonusSumAggregateOutputType | null
    _min: AffiliateBonusMinAggregateOutputType | null
    _max: AffiliateBonusMaxAggregateOutputType | null
  }

  type GetAffiliateBonusGroupByPayload<T extends AffiliateBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffiliateBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffiliateBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffiliateBonusGroupByOutputType[P]>
            : GetScalarType<T[P], AffiliateBonusGroupByOutputType[P]>
        }
      >
    >


  export type AffiliateBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    bonus_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateBonus"]>

  export type AffiliateBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    bonus_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affiliateBonus"]>

  export type AffiliateBonusSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    bonus_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AffiliateBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type AffiliateBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affiliates?: boolean | AffiliatesDefaultArgs<ExtArgs>
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $AffiliateBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AffiliateBonus"
    objects: {
      affiliates: Prisma.$AffiliatesPayload<ExtArgs>
      bonus: Prisma.$BonusPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number
      bonus_id: number
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["affiliateBonus"]>
    composites: {}
  }

  type AffiliateBonusGetPayload<S extends boolean | null | undefined | AffiliateBonusDefaultArgs> = $Result.GetResult<Prisma.$AffiliateBonusPayload, S>

  type AffiliateBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AffiliateBonusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffiliateBonusCountAggregateInputType | true
    }

  export interface AffiliateBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AffiliateBonus'], meta: { name: 'AffiliateBonus' } }
    /**
     * Find zero or one AffiliateBonus that matches the filter.
     * @param {AffiliateBonusFindUniqueArgs} args - Arguments to find a AffiliateBonus
     * @example
     * // Get one AffiliateBonus
     * const affiliateBonus = await prisma.affiliateBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AffiliateBonusFindUniqueArgs>(args: SelectSubset<T, AffiliateBonusFindUniqueArgs<ExtArgs>>): Prisma__AffiliateBonusClient<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AffiliateBonus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AffiliateBonusFindUniqueOrThrowArgs} args - Arguments to find a AffiliateBonus
     * @example
     * // Get one AffiliateBonus
     * const affiliateBonus = await prisma.affiliateBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AffiliateBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, AffiliateBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AffiliateBonusClient<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AffiliateBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateBonusFindFirstArgs} args - Arguments to find a AffiliateBonus
     * @example
     * // Get one AffiliateBonus
     * const affiliateBonus = await prisma.affiliateBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AffiliateBonusFindFirstArgs>(args?: SelectSubset<T, AffiliateBonusFindFirstArgs<ExtArgs>>): Prisma__AffiliateBonusClient<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AffiliateBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateBonusFindFirstOrThrowArgs} args - Arguments to find a AffiliateBonus
     * @example
     * // Get one AffiliateBonus
     * const affiliateBonus = await prisma.affiliateBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AffiliateBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, AffiliateBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__AffiliateBonusClient<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AffiliateBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AffiliateBonuses
     * const affiliateBonuses = await prisma.affiliateBonus.findMany()
     * 
     * // Get first 10 AffiliateBonuses
     * const affiliateBonuses = await prisma.affiliateBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const affiliateBonusWithIdOnly = await prisma.affiliateBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AffiliateBonusFindManyArgs>(args?: SelectSubset<T, AffiliateBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AffiliateBonus.
     * @param {AffiliateBonusCreateArgs} args - Arguments to create a AffiliateBonus.
     * @example
     * // Create one AffiliateBonus
     * const AffiliateBonus = await prisma.affiliateBonus.create({
     *   data: {
     *     // ... data to create a AffiliateBonus
     *   }
     * })
     * 
     */
    create<T extends AffiliateBonusCreateArgs>(args: SelectSubset<T, AffiliateBonusCreateArgs<ExtArgs>>): Prisma__AffiliateBonusClient<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AffiliateBonuses.
     * @param {AffiliateBonusCreateManyArgs} args - Arguments to create many AffiliateBonuses.
     * @example
     * // Create many AffiliateBonuses
     * const affiliateBonus = await prisma.affiliateBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AffiliateBonusCreateManyArgs>(args?: SelectSubset<T, AffiliateBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AffiliateBonuses and returns the data saved in the database.
     * @param {AffiliateBonusCreateManyAndReturnArgs} args - Arguments to create many AffiliateBonuses.
     * @example
     * // Create many AffiliateBonuses
     * const affiliateBonus = await prisma.affiliateBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AffiliateBonuses and only return the `id`
     * const affiliateBonusWithIdOnly = await prisma.affiliateBonus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AffiliateBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, AffiliateBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AffiliateBonus.
     * @param {AffiliateBonusDeleteArgs} args - Arguments to delete one AffiliateBonus.
     * @example
     * // Delete one AffiliateBonus
     * const AffiliateBonus = await prisma.affiliateBonus.delete({
     *   where: {
     *     // ... filter to delete one AffiliateBonus
     *   }
     * })
     * 
     */
    delete<T extends AffiliateBonusDeleteArgs>(args: SelectSubset<T, AffiliateBonusDeleteArgs<ExtArgs>>): Prisma__AffiliateBonusClient<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AffiliateBonus.
     * @param {AffiliateBonusUpdateArgs} args - Arguments to update one AffiliateBonus.
     * @example
     * // Update one AffiliateBonus
     * const affiliateBonus = await prisma.affiliateBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AffiliateBonusUpdateArgs>(args: SelectSubset<T, AffiliateBonusUpdateArgs<ExtArgs>>): Prisma__AffiliateBonusClient<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AffiliateBonuses.
     * @param {AffiliateBonusDeleteManyArgs} args - Arguments to filter AffiliateBonuses to delete.
     * @example
     * // Delete a few AffiliateBonuses
     * const { count } = await prisma.affiliateBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AffiliateBonusDeleteManyArgs>(args?: SelectSubset<T, AffiliateBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AffiliateBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AffiliateBonuses
     * const affiliateBonus = await prisma.affiliateBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AffiliateBonusUpdateManyArgs>(args: SelectSubset<T, AffiliateBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AffiliateBonus.
     * @param {AffiliateBonusUpsertArgs} args - Arguments to update or create a AffiliateBonus.
     * @example
     * // Update or create a AffiliateBonus
     * const affiliateBonus = await prisma.affiliateBonus.upsert({
     *   create: {
     *     // ... data to create a AffiliateBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AffiliateBonus we want to update
     *   }
     * })
     */
    upsert<T extends AffiliateBonusUpsertArgs>(args: SelectSubset<T, AffiliateBonusUpsertArgs<ExtArgs>>): Prisma__AffiliateBonusClient<$Result.GetResult<Prisma.$AffiliateBonusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AffiliateBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateBonusCountArgs} args - Arguments to filter AffiliateBonuses to count.
     * @example
     * // Count the number of AffiliateBonuses
     * const count = await prisma.affiliateBonus.count({
     *   where: {
     *     // ... the filter for the AffiliateBonuses we want to count
     *   }
     * })
    **/
    count<T extends AffiliateBonusCountArgs>(
      args?: Subset<T, AffiliateBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffiliateBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AffiliateBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffiliateBonusAggregateArgs>(args: Subset<T, AffiliateBonusAggregateArgs>): Prisma.PrismaPromise<GetAffiliateBonusAggregateType<T>>

    /**
     * Group by AffiliateBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffiliateBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AffiliateBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AffiliateBonusGroupByArgs['orderBy'] }
        : { orderBy?: AffiliateBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AffiliateBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffiliateBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AffiliateBonus model
   */
  readonly fields: AffiliateBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AffiliateBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AffiliateBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affiliates<T extends AffiliatesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AffiliatesDefaultArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bonus<T extends BonusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BonusDefaultArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AffiliateBonus model
   */ 
  interface AffiliateBonusFieldRefs {
    readonly id: FieldRef<"AffiliateBonus", 'Int'>
    readonly store_id: FieldRef<"AffiliateBonus", 'Int'>
    readonly affiliate_id: FieldRef<"AffiliateBonus", 'Int'>
    readonly bonus_id: FieldRef<"AffiliateBonus", 'Int'>
    readonly created_at: FieldRef<"AffiliateBonus", 'BigInt'>
    readonly updated_at: FieldRef<"AffiliateBonus", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * AffiliateBonus findUnique
   */
  export type AffiliateBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateBonus to fetch.
     */
    where: AffiliateBonusWhereUniqueInput
  }

  /**
   * AffiliateBonus findUniqueOrThrow
   */
  export type AffiliateBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateBonus to fetch.
     */
    where: AffiliateBonusWhereUniqueInput
  }

  /**
   * AffiliateBonus findFirst
   */
  export type AffiliateBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateBonus to fetch.
     */
    where?: AffiliateBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateBonuses to fetch.
     */
    orderBy?: AffiliateBonusOrderByWithRelationInput | AffiliateBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateBonuses.
     */
    cursor?: AffiliateBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateBonuses.
     */
    distinct?: AffiliateBonusScalarFieldEnum | AffiliateBonusScalarFieldEnum[]
  }

  /**
   * AffiliateBonus findFirstOrThrow
   */
  export type AffiliateBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateBonus to fetch.
     */
    where?: AffiliateBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateBonuses to fetch.
     */
    orderBy?: AffiliateBonusOrderByWithRelationInput | AffiliateBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AffiliateBonuses.
     */
    cursor?: AffiliateBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AffiliateBonuses.
     */
    distinct?: AffiliateBonusScalarFieldEnum | AffiliateBonusScalarFieldEnum[]
  }

  /**
   * AffiliateBonus findMany
   */
  export type AffiliateBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    /**
     * Filter, which AffiliateBonuses to fetch.
     */
    where?: AffiliateBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AffiliateBonuses to fetch.
     */
    orderBy?: AffiliateBonusOrderByWithRelationInput | AffiliateBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AffiliateBonuses.
     */
    cursor?: AffiliateBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AffiliateBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AffiliateBonuses.
     */
    skip?: number
    distinct?: AffiliateBonusScalarFieldEnum | AffiliateBonusScalarFieldEnum[]
  }

  /**
   * AffiliateBonus create
   */
  export type AffiliateBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a AffiliateBonus.
     */
    data: XOR<AffiliateBonusCreateInput, AffiliateBonusUncheckedCreateInput>
  }

  /**
   * AffiliateBonus createMany
   */
  export type AffiliateBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AffiliateBonuses.
     */
    data: AffiliateBonusCreateManyInput | AffiliateBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AffiliateBonus createManyAndReturn
   */
  export type AffiliateBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AffiliateBonuses.
     */
    data: AffiliateBonusCreateManyInput | AffiliateBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AffiliateBonus update
   */
  export type AffiliateBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a AffiliateBonus.
     */
    data: XOR<AffiliateBonusUpdateInput, AffiliateBonusUncheckedUpdateInput>
    /**
     * Choose, which AffiliateBonus to update.
     */
    where: AffiliateBonusWhereUniqueInput
  }

  /**
   * AffiliateBonus updateMany
   */
  export type AffiliateBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AffiliateBonuses.
     */
    data: XOR<AffiliateBonusUpdateManyMutationInput, AffiliateBonusUncheckedUpdateManyInput>
    /**
     * Filter which AffiliateBonuses to update
     */
    where?: AffiliateBonusWhereInput
  }

  /**
   * AffiliateBonus upsert
   */
  export type AffiliateBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the AffiliateBonus to update in case it exists.
     */
    where: AffiliateBonusWhereUniqueInput
    /**
     * In case the AffiliateBonus found by the `where` argument doesn't exist, create a new AffiliateBonus with this data.
     */
    create: XOR<AffiliateBonusCreateInput, AffiliateBonusUncheckedCreateInput>
    /**
     * In case the AffiliateBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AffiliateBonusUpdateInput, AffiliateBonusUncheckedUpdateInput>
  }

  /**
   * AffiliateBonus delete
   */
  export type AffiliateBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
    /**
     * Filter which AffiliateBonus to delete.
     */
    where: AffiliateBonusWhereUniqueInput
  }

  /**
   * AffiliateBonus deleteMany
   */
  export type AffiliateBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AffiliateBonuses to delete
     */
    where?: AffiliateBonusWhereInput
  }

  /**
   * AffiliateBonus without action
   */
  export type AffiliateBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AffiliateBonus
     */
    select?: AffiliateBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliateBonusInclude<ExtArgs> | null
  }


  /**
   * Model ProgramBonus
   */

  export type AggregateProgramBonus = {
    _count: ProgramBonusCountAggregateOutputType | null
    _avg: ProgramBonusAvgAggregateOutputType | null
    _sum: ProgramBonusSumAggregateOutputType | null
    _min: ProgramBonusMinAggregateOutputType | null
    _max: ProgramBonusMaxAggregateOutputType | null
  }

  export type ProgramBonusAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    bonus_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type ProgramBonusSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    bonus_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type ProgramBonusMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    bonus_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type ProgramBonusMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    program_id: number | null
    bonus_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type ProgramBonusCountAggregateOutputType = {
    id: number
    store_id: number
    program_id: number
    bonus_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProgramBonusAvgAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProgramBonusSumAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProgramBonusMinAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProgramBonusMaxAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
  }

  export type ProgramBonusCountAggregateInputType = {
    id?: true
    store_id?: true
    program_id?: true
    bonus_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProgramBonusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramBonus to aggregate.
     */
    where?: ProgramBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramBonuses to fetch.
     */
    orderBy?: ProgramBonusOrderByWithRelationInput | ProgramBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramBonuses
    **/
    _count?: true | ProgramBonusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramBonusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramBonusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramBonusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramBonusMaxAggregateInputType
  }

  export type GetProgramBonusAggregateType<T extends ProgramBonusAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramBonus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramBonus[P]>
      : GetScalarType<T[P], AggregateProgramBonus[P]>
  }




  export type ProgramBonusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramBonusWhereInput
    orderBy?: ProgramBonusOrderByWithAggregationInput | ProgramBonusOrderByWithAggregationInput[]
    by: ProgramBonusScalarFieldEnum[] | ProgramBonusScalarFieldEnum
    having?: ProgramBonusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramBonusCountAggregateInputType | true
    _avg?: ProgramBonusAvgAggregateInputType
    _sum?: ProgramBonusSumAggregateInputType
    _min?: ProgramBonusMinAggregateInputType
    _max?: ProgramBonusMaxAggregateInputType
  }

  export type ProgramBonusGroupByOutputType = {
    id: number
    store_id: number
    program_id: number
    bonus_id: number
    created_at: bigint
    updated_at: bigint
    _count: ProgramBonusCountAggregateOutputType | null
    _avg: ProgramBonusAvgAggregateOutputType | null
    _sum: ProgramBonusSumAggregateOutputType | null
    _min: ProgramBonusMinAggregateOutputType | null
    _max: ProgramBonusMaxAggregateOutputType | null
  }

  type GetProgramBonusGroupByPayload<T extends ProgramBonusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramBonusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramBonusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramBonusGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramBonusGroupByOutputType[P]>
        }
      >
    >


  export type ProgramBonusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    program_id?: boolean
    bonus_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programBonus"]>

  export type ProgramBonusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    program_id?: boolean
    bonus_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programBonus"]>

  export type ProgramBonusSelectScalar = {
    id?: boolean
    store_id?: boolean
    program_id?: boolean
    bonus_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProgramBonusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type ProgramBonusIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bonus?: boolean | BonusDefaultArgs<ExtArgs>
    programs?: boolean | ProgramsDefaultArgs<ExtArgs>
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $ProgramBonusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramBonus"
    objects: {
      bonus: Prisma.$BonusPayload<ExtArgs>
      programs: Prisma.$ProgramsPayload<ExtArgs>
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      program_id: number
      bonus_id: number
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["programBonus"]>
    composites: {}
  }

  type ProgramBonusGetPayload<S extends boolean | null | undefined | ProgramBonusDefaultArgs> = $Result.GetResult<Prisma.$ProgramBonusPayload, S>

  type ProgramBonusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramBonusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramBonusCountAggregateInputType | true
    }

  export interface ProgramBonusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramBonus'], meta: { name: 'ProgramBonus' } }
    /**
     * Find zero or one ProgramBonus that matches the filter.
     * @param {ProgramBonusFindUniqueArgs} args - Arguments to find a ProgramBonus
     * @example
     * // Get one ProgramBonus
     * const programBonus = await prisma.programBonus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramBonusFindUniqueArgs>(args: SelectSubset<T, ProgramBonusFindUniqueArgs<ExtArgs>>): Prisma__ProgramBonusClient<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgramBonus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramBonusFindUniqueOrThrowArgs} args - Arguments to find a ProgramBonus
     * @example
     * // Get one ProgramBonus
     * const programBonus = await prisma.programBonus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramBonusFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramBonusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramBonusClient<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgramBonus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBonusFindFirstArgs} args - Arguments to find a ProgramBonus
     * @example
     * // Get one ProgramBonus
     * const programBonus = await prisma.programBonus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramBonusFindFirstArgs>(args?: SelectSubset<T, ProgramBonusFindFirstArgs<ExtArgs>>): Prisma__ProgramBonusClient<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgramBonus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBonusFindFirstOrThrowArgs} args - Arguments to find a ProgramBonus
     * @example
     * // Get one ProgramBonus
     * const programBonus = await prisma.programBonus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramBonusFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramBonusFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramBonusClient<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgramBonuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBonusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramBonuses
     * const programBonuses = await prisma.programBonus.findMany()
     * 
     * // Get first 10 ProgramBonuses
     * const programBonuses = await prisma.programBonus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programBonusWithIdOnly = await prisma.programBonus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramBonusFindManyArgs>(args?: SelectSubset<T, ProgramBonusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgramBonus.
     * @param {ProgramBonusCreateArgs} args - Arguments to create a ProgramBonus.
     * @example
     * // Create one ProgramBonus
     * const ProgramBonus = await prisma.programBonus.create({
     *   data: {
     *     // ... data to create a ProgramBonus
     *   }
     * })
     * 
     */
    create<T extends ProgramBonusCreateArgs>(args: SelectSubset<T, ProgramBonusCreateArgs<ExtArgs>>): Prisma__ProgramBonusClient<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgramBonuses.
     * @param {ProgramBonusCreateManyArgs} args - Arguments to create many ProgramBonuses.
     * @example
     * // Create many ProgramBonuses
     * const programBonus = await prisma.programBonus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramBonusCreateManyArgs>(args?: SelectSubset<T, ProgramBonusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramBonuses and returns the data saved in the database.
     * @param {ProgramBonusCreateManyAndReturnArgs} args - Arguments to create many ProgramBonuses.
     * @example
     * // Create many ProgramBonuses
     * const programBonus = await prisma.programBonus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramBonuses and only return the `id`
     * const programBonusWithIdOnly = await prisma.programBonus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramBonusCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramBonusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgramBonus.
     * @param {ProgramBonusDeleteArgs} args - Arguments to delete one ProgramBonus.
     * @example
     * // Delete one ProgramBonus
     * const ProgramBonus = await prisma.programBonus.delete({
     *   where: {
     *     // ... filter to delete one ProgramBonus
     *   }
     * })
     * 
     */
    delete<T extends ProgramBonusDeleteArgs>(args: SelectSubset<T, ProgramBonusDeleteArgs<ExtArgs>>): Prisma__ProgramBonusClient<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgramBonus.
     * @param {ProgramBonusUpdateArgs} args - Arguments to update one ProgramBonus.
     * @example
     * // Update one ProgramBonus
     * const programBonus = await prisma.programBonus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramBonusUpdateArgs>(args: SelectSubset<T, ProgramBonusUpdateArgs<ExtArgs>>): Prisma__ProgramBonusClient<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgramBonuses.
     * @param {ProgramBonusDeleteManyArgs} args - Arguments to filter ProgramBonuses to delete.
     * @example
     * // Delete a few ProgramBonuses
     * const { count } = await prisma.programBonus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramBonusDeleteManyArgs>(args?: SelectSubset<T, ProgramBonusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBonusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramBonuses
     * const programBonus = await prisma.programBonus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramBonusUpdateManyArgs>(args: SelectSubset<T, ProgramBonusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramBonus.
     * @param {ProgramBonusUpsertArgs} args - Arguments to update or create a ProgramBonus.
     * @example
     * // Update or create a ProgramBonus
     * const programBonus = await prisma.programBonus.upsert({
     *   create: {
     *     // ... data to create a ProgramBonus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramBonus we want to update
     *   }
     * })
     */
    upsert<T extends ProgramBonusUpsertArgs>(args: SelectSubset<T, ProgramBonusUpsertArgs<ExtArgs>>): Prisma__ProgramBonusClient<$Result.GetResult<Prisma.$ProgramBonusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgramBonuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBonusCountArgs} args - Arguments to filter ProgramBonuses to count.
     * @example
     * // Count the number of ProgramBonuses
     * const count = await prisma.programBonus.count({
     *   where: {
     *     // ... the filter for the ProgramBonuses we want to count
     *   }
     * })
    **/
    count<T extends ProgramBonusCountArgs>(
      args?: Subset<T, ProgramBonusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramBonusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBonusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramBonusAggregateArgs>(args: Subset<T, ProgramBonusAggregateArgs>): Prisma.PrismaPromise<GetProgramBonusAggregateType<T>>

    /**
     * Group by ProgramBonus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramBonusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramBonusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramBonusGroupByArgs['orderBy'] }
        : { orderBy?: ProgramBonusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramBonusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramBonusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramBonus model
   */
  readonly fields: ProgramBonusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramBonus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramBonusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bonus<T extends BonusDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BonusDefaultArgs<ExtArgs>>): Prisma__BonusClient<$Result.GetResult<Prisma.$BonusPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    programs<T extends ProgramsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramsDefaultArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramBonus model
   */ 
  interface ProgramBonusFieldRefs {
    readonly id: FieldRef<"ProgramBonus", 'Int'>
    readonly store_id: FieldRef<"ProgramBonus", 'Int'>
    readonly program_id: FieldRef<"ProgramBonus", 'Int'>
    readonly bonus_id: FieldRef<"ProgramBonus", 'Int'>
    readonly created_at: FieldRef<"ProgramBonus", 'BigInt'>
    readonly updated_at: FieldRef<"ProgramBonus", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * ProgramBonus findUnique
   */
  export type ProgramBonusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBonus to fetch.
     */
    where: ProgramBonusWhereUniqueInput
  }

  /**
   * ProgramBonus findUniqueOrThrow
   */
  export type ProgramBonusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBonus to fetch.
     */
    where: ProgramBonusWhereUniqueInput
  }

  /**
   * ProgramBonus findFirst
   */
  export type ProgramBonusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBonus to fetch.
     */
    where?: ProgramBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramBonuses to fetch.
     */
    orderBy?: ProgramBonusOrderByWithRelationInput | ProgramBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramBonuses.
     */
    cursor?: ProgramBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramBonuses.
     */
    distinct?: ProgramBonusScalarFieldEnum | ProgramBonusScalarFieldEnum[]
  }

  /**
   * ProgramBonus findFirstOrThrow
   */
  export type ProgramBonusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBonus to fetch.
     */
    where?: ProgramBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramBonuses to fetch.
     */
    orderBy?: ProgramBonusOrderByWithRelationInput | ProgramBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramBonuses.
     */
    cursor?: ProgramBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramBonuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramBonuses.
     */
    distinct?: ProgramBonusScalarFieldEnum | ProgramBonusScalarFieldEnum[]
  }

  /**
   * ProgramBonus findMany
   */
  export type ProgramBonusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    /**
     * Filter, which ProgramBonuses to fetch.
     */
    where?: ProgramBonusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramBonuses to fetch.
     */
    orderBy?: ProgramBonusOrderByWithRelationInput | ProgramBonusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramBonuses.
     */
    cursor?: ProgramBonusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramBonuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramBonuses.
     */
    skip?: number
    distinct?: ProgramBonusScalarFieldEnum | ProgramBonusScalarFieldEnum[]
  }

  /**
   * ProgramBonus create
   */
  export type ProgramBonusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramBonus.
     */
    data: XOR<ProgramBonusCreateInput, ProgramBonusUncheckedCreateInput>
  }

  /**
   * ProgramBonus createMany
   */
  export type ProgramBonusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramBonuses.
     */
    data: ProgramBonusCreateManyInput | ProgramBonusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramBonus createManyAndReturn
   */
  export type ProgramBonusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgramBonuses.
     */
    data: ProgramBonusCreateManyInput | ProgramBonusCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramBonus update
   */
  export type ProgramBonusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramBonus.
     */
    data: XOR<ProgramBonusUpdateInput, ProgramBonusUncheckedUpdateInput>
    /**
     * Choose, which ProgramBonus to update.
     */
    where: ProgramBonusWhereUniqueInput
  }

  /**
   * ProgramBonus updateMany
   */
  export type ProgramBonusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramBonuses.
     */
    data: XOR<ProgramBonusUpdateManyMutationInput, ProgramBonusUncheckedUpdateManyInput>
    /**
     * Filter which ProgramBonuses to update
     */
    where?: ProgramBonusWhereInput
  }

  /**
   * ProgramBonus upsert
   */
  export type ProgramBonusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramBonus to update in case it exists.
     */
    where: ProgramBonusWhereUniqueInput
    /**
     * In case the ProgramBonus found by the `where` argument doesn't exist, create a new ProgramBonus with this data.
     */
    create: XOR<ProgramBonusCreateInput, ProgramBonusUncheckedCreateInput>
    /**
     * In case the ProgramBonus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramBonusUpdateInput, ProgramBonusUncheckedUpdateInput>
  }

  /**
   * ProgramBonus delete
   */
  export type ProgramBonusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
    /**
     * Filter which ProgramBonus to delete.
     */
    where: ProgramBonusWhereUniqueInput
  }

  /**
   * ProgramBonus deleteMany
   */
  export type ProgramBonusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramBonuses to delete
     */
    where?: ProgramBonusWhereInput
  }

  /**
   * ProgramBonus without action
   */
  export type ProgramBonusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramBonus
     */
    select?: ProgramBonusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramBonusInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpAvgAggregateOutputType = {
    id: number | null
    code: number | null
    expire_at: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type OtpSumAggregateOutputType = {
    id: number | null
    code: number | null
    expire_at: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type OtpMinAggregateOutputType = {
    id: number | null
    code: number | null
    email: string | null
    expire_at: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type OtpMaxAggregateOutputType = {
    id: number | null
    code: number | null
    email: string | null
    expire_at: bigint | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    code: number
    email: number
    expire_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OtpAvgAggregateInputType = {
    id?: true
    code?: true
    expire_at?: true
    created_at?: true
    updated_at?: true
  }

  export type OtpSumAggregateInputType = {
    id?: true
    code?: true
    expire_at?: true
    created_at?: true
    updated_at?: true
  }

  export type OtpMinAggregateInputType = {
    id?: true
    code?: true
    email?: true
    expire_at?: true
    created_at?: true
    updated_at?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    code?: true
    email?: true
    expire_at?: true
    created_at?: true
    updated_at?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    code?: true
    email?: true
    expire_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _avg?: OtpAvgAggregateInputType
    _sum?: OtpSumAggregateInputType
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: number
    code: number
    email: string
    expire_at: bigint
    created_at: bigint
    updated_at: bigint
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    email?: boolean
    expire_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    email?: boolean
    expire_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    code?: boolean
    email?: boolean
    expire_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }


  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: number
      email: string
      expire_at: bigint
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {OtpCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */ 
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'Int'>
    readonly code: FieldRef<"Otp", 'Int'>
    readonly email: FieldRef<"Otp", 'String'>
    readonly expire_at: FieldRef<"Otp", 'BigInt'>
    readonly created_at: FieldRef<"Otp", 'BigInt'>
    readonly updated_at: FieldRef<"Otp", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp createManyAndReturn
   */
  export type OtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
  }


  /**
   * Model Notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type NotificationsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: number | null
    notification_id: string | null
    store_id: number | null
    type: $Enums.NotificationType | null
    receiver_type: $Enums.NotificationReceiverType | null
    subject: string | null
    status: $Enums.NotificationStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
    languages: string | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: number | null
    notification_id: string | null
    store_id: number | null
    type: $Enums.NotificationType | null
    receiver_type: $Enums.NotificationReceiverType | null
    subject: string | null
    status: $Enums.NotificationStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
    languages: string | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    notification_id: number
    store_id: number
    type: number
    receiver_type: number
    subject: number
    status: number
    created_at: number
    updated_at: number
    languages: number
    _all: number
  }


  export type NotificationsAvgAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationsSumAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type NotificationsMinAggregateInputType = {
    id?: true
    notification_id?: true
    store_id?: true
    type?: true
    receiver_type?: true
    subject?: true
    status?: true
    created_at?: true
    updated_at?: true
    languages?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    notification_id?: true
    store_id?: true
    type?: true
    receiver_type?: true
    subject?: true
    status?: true
    created_at?: true
    updated_at?: true
    languages?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    notification_id?: true
    store_id?: true
    type?: true
    receiver_type?: true
    subject?: true
    status?: true
    created_at?: true
    updated_at?: true
    languages?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to aggregate.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type NotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationsWhereInput
    orderBy?: NotificationsOrderByWithAggregationInput | NotificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: NotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _avg?: NotificationsAvgAggregateInputType
    _sum?: NotificationsSumAggregateInputType
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: number
    notification_id: string
    store_id: number
    type: $Enums.NotificationType
    receiver_type: $Enums.NotificationReceiverType
    subject: string
    status: $Enums.NotificationStatusType
    created_at: bigint
    updated_at: bigint
    languages: string
    _count: NotificationsCountAggregateOutputType | null
    _avg: NotificationsAvgAggregateOutputType | null
    _sum: NotificationsSumAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends NotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type NotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notification_id?: boolean
    store_id?: boolean
    type?: boolean
    receiver_type?: boolean
    subject?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    languages?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notification_id?: boolean
    store_id?: boolean
    type?: boolean
    receiver_type?: boolean
    subject?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    languages?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type NotificationsSelectScalar = {
    id?: boolean
    notification_id?: boolean
    store_id?: boolean
    type?: boolean
    receiver_type?: boolean
    subject?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    languages?: boolean
  }

  export type NotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type NotificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $NotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notifications"
    objects: {
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      notification_id: string
      store_id: number
      type: $Enums.NotificationType
      receiver_type: $Enums.NotificationReceiverType
      subject: string
      status: $Enums.NotificationStatusType
      created_at: bigint
      updated_at: bigint
      languages: string
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type NotificationsGetPayload<S extends boolean | null | undefined | NotificationsDefaultArgs> = $Result.GetResult<Prisma.$NotificationsPayload, S>

  type NotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface NotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notifications'], meta: { name: 'Notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {NotificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationsFindUniqueArgs>(args: SelectSubset<T, NotificationsFindUniqueArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationsFindFirstArgs>(args?: SelectSubset<T, NotificationsFindFirstArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationsFindManyArgs>(args?: SelectSubset<T, NotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notifications.
     * @param {NotificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends NotificationsCreateArgs>(args: SelectSubset<T, NotificationsCreateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationsCreateManyArgs>(args?: SelectSubset<T, NotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notifications.
     * @param {NotificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends NotificationsDeleteArgs>(args: SelectSubset<T, NotificationsDeleteArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notifications.
     * @param {NotificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationsUpdateArgs>(args: SelectSubset<T, NotificationsUpdateArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationsDeleteManyArgs>(args?: SelectSubset<T, NotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationsUpdateManyArgs>(args: SelectSubset<T, NotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notifications.
     * @param {NotificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends NotificationsUpsertArgs>(args: SelectSubset<T, NotificationsUpsertArgs<ExtArgs>>): Prisma__NotificationsClient<$Result.GetResult<Prisma.$NotificationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationsCountArgs>(
      args?: Subset<T, NotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationsGroupByArgs['orderBy'] }
        : { orderBy?: NotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notifications model
   */
  readonly fields: NotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notifications model
   */ 
  interface NotificationsFieldRefs {
    readonly id: FieldRef<"Notifications", 'Int'>
    readonly notification_id: FieldRef<"Notifications", 'String'>
    readonly store_id: FieldRef<"Notifications", 'Int'>
    readonly type: FieldRef<"Notifications", 'NotificationType'>
    readonly receiver_type: FieldRef<"Notifications", 'NotificationReceiverType'>
    readonly subject: FieldRef<"Notifications", 'String'>
    readonly status: FieldRef<"Notifications", 'NotificationStatusType'>
    readonly created_at: FieldRef<"Notifications", 'BigInt'>
    readonly updated_at: FieldRef<"Notifications", 'BigInt'>
    readonly languages: FieldRef<"Notifications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Notifications findUnique
   */
  export type NotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findUniqueOrThrow
   */
  export type NotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications findFirst
   */
  export type NotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findFirstOrThrow
   */
  export type NotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications findMany
   */
  export type NotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationsOrderByWithRelationInput | NotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * Notifications create
   */
  export type NotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Notifications.
     */
    data: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
  }

  /**
   * Notifications createMany
   */
  export type NotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notifications createManyAndReturn
   */
  export type NotificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationsCreateManyInput | NotificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notifications update
   */
  export type NotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Notifications.
     */
    data: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
    /**
     * Choose, which Notifications to update.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications updateMany
   */
  export type NotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationsWhereInput
  }

  /**
   * Notifications upsert
   */
  export type NotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Notifications to update in case it exists.
     */
    where: NotificationsWhereUniqueInput
    /**
     * In case the Notifications found by the `where` argument doesn't exist, create a new Notifications with this data.
     */
    create: XOR<NotificationsCreateInput, NotificationsUncheckedCreateInput>
    /**
     * In case the Notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationsUpdateInput, NotificationsUncheckedUpdateInput>
  }

  /**
   * Notifications delete
   */
  export type NotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
    /**
     * Filter which Notifications to delete.
     */
    where: NotificationsWhereUniqueInput
  }

  /**
   * Notifications deleteMany
   */
  export type NotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationsWhereInput
  }

  /**
   * Notifications without action
   */
  export type NotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notifications
     */
    select?: NotificationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationsInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    order_id: number | null
    payout_id: number | null
    created_at: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    order_id: number | null
    payout_id: number | null
    created_at: bigint | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    order_id: number | null
    payout_id: number | null
    entity_type: $Enums.ActivityEntityType | null
    message: string | null
    created_at: bigint | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    affiliate_id: number | null
    program_id: number | null
    order_id: number | null
    payout_id: number | null
    entity_type: $Enums.ActivityEntityType | null
    message: string | null
    created_at: bigint | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    store_id: number
    affiliate_id: number
    program_id: number
    order_id: number
    payout_id: number
    entity_type: number
    message: number
    created_at: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    order_id?: true
    payout_id?: true
    created_at?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    order_id?: true
    payout_id?: true
    created_at?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    order_id?: true
    payout_id?: true
    entity_type?: true
    message?: true
    created_at?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    order_id?: true
    payout_id?: true
    entity_type?: true
    message?: true
    created_at?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    store_id?: true
    affiliate_id?: true
    program_id?: true
    order_id?: true
    payout_id?: true
    entity_type?: true
    message?: true
    created_at?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: number
    store_id: number
    affiliate_id: number | null
    program_id: number | null
    order_id: number | null
    payout_id: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    program_id?: boolean
    order_id?: boolean
    payout_id?: boolean
    entity_type?: boolean
    message?: boolean
    created_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    affiliates?: boolean | ActivityLog$affiliatesArgs<ExtArgs>
    programs?: boolean | ActivityLog$programsArgs<ExtArgs>
    orders?: boolean | ActivityLog$ordersArgs<ExtArgs>
    payouts?: boolean | ActivityLog$payoutsArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    program_id?: boolean
    order_id?: boolean
    payout_id?: boolean
    entity_type?: boolean
    message?: boolean
    created_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    affiliates?: boolean | ActivityLog$affiliatesArgs<ExtArgs>
    programs?: boolean | ActivityLog$programsArgs<ExtArgs>
    orders?: boolean | ActivityLog$ordersArgs<ExtArgs>
    payouts?: boolean | ActivityLog$payoutsArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    store_id?: boolean
    affiliate_id?: boolean
    program_id?: boolean
    order_id?: boolean
    payout_id?: boolean
    entity_type?: boolean
    message?: boolean
    created_at?: boolean
  }

  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    affiliates?: boolean | ActivityLog$affiliatesArgs<ExtArgs>
    programs?: boolean | ActivityLog$programsArgs<ExtArgs>
    orders?: boolean | ActivityLog$ordersArgs<ExtArgs>
    payouts?: boolean | ActivityLog$payoutsArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
    affiliates?: boolean | ActivityLog$affiliatesArgs<ExtArgs>
    programs?: boolean | ActivityLog$programsArgs<ExtArgs>
    orders?: boolean | ActivityLog$ordersArgs<ExtArgs>
    payouts?: boolean | ActivityLog$payoutsArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      stores: Prisma.$StoresPayload<ExtArgs>
      affiliates: Prisma.$AffiliatesPayload<ExtArgs> | null
      programs: Prisma.$ProgramsPayload<ExtArgs> | null
      orders: Prisma.$OrdersPayload<ExtArgs> | null
      payouts: Prisma.$PayoutsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      affiliate_id: number | null
      program_id: number | null
      order_id: number | null
      payout_id: number | null
      entity_type: $Enums.ActivityEntityType
      message: string
      created_at: bigint
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    affiliates<T extends ActivityLog$affiliatesArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$affiliatesArgs<ExtArgs>>): Prisma__AffiliatesClient<$Result.GetResult<Prisma.$AffiliatesPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    programs<T extends ActivityLog$programsArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$programsArgs<ExtArgs>>): Prisma__ProgramsClient<$Result.GetResult<Prisma.$ProgramsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    orders<T extends ActivityLog$ordersArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$ordersArgs<ExtArgs>>): Prisma__OrdersClient<$Result.GetResult<Prisma.$OrdersPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    payouts<T extends ActivityLog$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$payoutsArgs<ExtArgs>>): Prisma__PayoutsClient<$Result.GetResult<Prisma.$PayoutsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */ 
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'Int'>
    readonly store_id: FieldRef<"ActivityLog", 'Int'>
    readonly affiliate_id: FieldRef<"ActivityLog", 'Int'>
    readonly program_id: FieldRef<"ActivityLog", 'Int'>
    readonly order_id: FieldRef<"ActivityLog", 'Int'>
    readonly payout_id: FieldRef<"ActivityLog", 'Int'>
    readonly entity_type: FieldRef<"ActivityLog", 'ActivityEntityType'>
    readonly message: FieldRef<"ActivityLog", 'String'>
    readonly created_at: FieldRef<"ActivityLog", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog.affiliates
   */
  export type ActivityLog$affiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Affiliates
     */
    select?: AffiliatesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AffiliatesInclude<ExtArgs> | null
    where?: AffiliatesWhereInput
  }

  /**
   * ActivityLog.programs
   */
  export type ActivityLog$programsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Programs
     */
    select?: ProgramsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramsInclude<ExtArgs> | null
    where?: ProgramsWhereInput
  }

  /**
   * ActivityLog.orders
   */
  export type ActivityLog$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Orders
     */
    select?: OrdersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrdersInclude<ExtArgs> | null
    where?: OrdersWhereInput
  }

  /**
   * ActivityLog.payouts
   */
  export type ActivityLog$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payouts
     */
    select?: PayoutsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayoutsInclude<ExtArgs> | null
    where?: PayoutsWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model MessageHistory
   */

  export type AggregateMessageHistory = {
    _count: MessageHistoryCountAggregateOutputType | null
    _avg: MessageHistoryAvgAggregateOutputType | null
    _sum: MessageHistorySumAggregateOutputType | null
    _min: MessageHistoryMinAggregateOutputType | null
    _max: MessageHistoryMaxAggregateOutputType | null
  }

  export type MessageHistoryAvgAggregateOutputType = {
    id: number | null
    created_at: number | null
    store_id: number | null
  }

  export type MessageHistorySumAggregateOutputType = {
    id: number | null
    created_at: bigint | null
    store_id: number | null
  }

  export type MessageHistoryMinAggregateOutputType = {
    id: number | null
    status: $Enums.MessageHistoryStatusType | null
    referenceId: string | null
    created_at: bigint | null
    store_id: number | null
  }

  export type MessageHistoryMaxAggregateOutputType = {
    id: number | null
    status: $Enums.MessageHistoryStatusType | null
    referenceId: string | null
    created_at: bigint | null
    store_id: number | null
  }

  export type MessageHistoryCountAggregateOutputType = {
    id: number
    status: number
    referenceId: number
    metaData: number
    created_at: number
    store_id: number
    _all: number
  }


  export type MessageHistoryAvgAggregateInputType = {
    id?: true
    created_at?: true
    store_id?: true
  }

  export type MessageHistorySumAggregateInputType = {
    id?: true
    created_at?: true
    store_id?: true
  }

  export type MessageHistoryMinAggregateInputType = {
    id?: true
    status?: true
    referenceId?: true
    created_at?: true
    store_id?: true
  }

  export type MessageHistoryMaxAggregateInputType = {
    id?: true
    status?: true
    referenceId?: true
    created_at?: true
    store_id?: true
  }

  export type MessageHistoryCountAggregateInputType = {
    id?: true
    status?: true
    referenceId?: true
    metaData?: true
    created_at?: true
    store_id?: true
    _all?: true
  }

  export type MessageHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageHistory to aggregate.
     */
    where?: MessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageHistories to fetch.
     */
    orderBy?: MessageHistoryOrderByWithRelationInput | MessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageHistories
    **/
    _count?: true | MessageHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageHistoryMaxAggregateInputType
  }

  export type GetMessageHistoryAggregateType<T extends MessageHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageHistory[P]>
      : GetScalarType<T[P], AggregateMessageHistory[P]>
  }




  export type MessageHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageHistoryWhereInput
    orderBy?: MessageHistoryOrderByWithAggregationInput | MessageHistoryOrderByWithAggregationInput[]
    by: MessageHistoryScalarFieldEnum[] | MessageHistoryScalarFieldEnum
    having?: MessageHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageHistoryCountAggregateInputType | true
    _avg?: MessageHistoryAvgAggregateInputType
    _sum?: MessageHistorySumAggregateInputType
    _min?: MessageHistoryMinAggregateInputType
    _max?: MessageHistoryMaxAggregateInputType
  }

  export type MessageHistoryGroupByOutputType = {
    id: number
    status: $Enums.MessageHistoryStatusType
    referenceId: string
    metaData: JsonValue
    created_at: bigint
    store_id: number
    _count: MessageHistoryCountAggregateOutputType | null
    _avg: MessageHistoryAvgAggregateOutputType | null
    _sum: MessageHistorySumAggregateOutputType | null
    _min: MessageHistoryMinAggregateOutputType | null
    _max: MessageHistoryMaxAggregateOutputType | null
  }

  type GetMessageHistoryGroupByPayload<T extends MessageHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], MessageHistoryGroupByOutputType[P]>
        }
      >
    >


  export type MessageHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    referenceId?: boolean
    metaData?: boolean
    created_at?: boolean
    store_id?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageHistory"]>

  export type MessageHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    referenceId?: boolean
    metaData?: boolean
    created_at?: boolean
    store_id?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageHistory"]>

  export type MessageHistorySelectScalar = {
    id?: boolean
    status?: boolean
    referenceId?: boolean
    metaData?: boolean
    created_at?: boolean
    store_id?: boolean
  }

  export type MessageHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type MessageHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $MessageHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageHistory"
    objects: {
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      status: $Enums.MessageHistoryStatusType
      referenceId: string
      metaData: Prisma.JsonValue
      created_at: bigint
      store_id: number
    }, ExtArgs["result"]["messageHistory"]>
    composites: {}
  }

  type MessageHistoryGetPayload<S extends boolean | null | undefined | MessageHistoryDefaultArgs> = $Result.GetResult<Prisma.$MessageHistoryPayload, S>

  type MessageHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MessageHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MessageHistoryCountAggregateInputType | true
    }

  export interface MessageHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageHistory'], meta: { name: 'MessageHistory' } }
    /**
     * Find zero or one MessageHistory that matches the filter.
     * @param {MessageHistoryFindUniqueArgs} args - Arguments to find a MessageHistory
     * @example
     * // Get one MessageHistory
     * const messageHistory = await prisma.messageHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageHistoryFindUniqueArgs>(args: SelectSubset<T, MessageHistoryFindUniqueArgs<ExtArgs>>): Prisma__MessageHistoryClient<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MessageHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MessageHistoryFindUniqueOrThrowArgs} args - Arguments to find a MessageHistory
     * @example
     * // Get one MessageHistory
     * const messageHistory = await prisma.messageHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageHistoryClient<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MessageHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageHistoryFindFirstArgs} args - Arguments to find a MessageHistory
     * @example
     * // Get one MessageHistory
     * const messageHistory = await prisma.messageHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageHistoryFindFirstArgs>(args?: SelectSubset<T, MessageHistoryFindFirstArgs<ExtArgs>>): Prisma__MessageHistoryClient<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MessageHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageHistoryFindFirstOrThrowArgs} args - Arguments to find a MessageHistory
     * @example
     * // Get one MessageHistory
     * const messageHistory = await prisma.messageHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageHistoryClient<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MessageHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageHistories
     * const messageHistories = await prisma.messageHistory.findMany()
     * 
     * // Get first 10 MessageHistories
     * const messageHistories = await prisma.messageHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageHistoryWithIdOnly = await prisma.messageHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageHistoryFindManyArgs>(args?: SelectSubset<T, MessageHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MessageHistory.
     * @param {MessageHistoryCreateArgs} args - Arguments to create a MessageHistory.
     * @example
     * // Create one MessageHistory
     * const MessageHistory = await prisma.messageHistory.create({
     *   data: {
     *     // ... data to create a MessageHistory
     *   }
     * })
     * 
     */
    create<T extends MessageHistoryCreateArgs>(args: SelectSubset<T, MessageHistoryCreateArgs<ExtArgs>>): Prisma__MessageHistoryClient<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MessageHistories.
     * @param {MessageHistoryCreateManyArgs} args - Arguments to create many MessageHistories.
     * @example
     * // Create many MessageHistories
     * const messageHistory = await prisma.messageHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageHistoryCreateManyArgs>(args?: SelectSubset<T, MessageHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageHistories and returns the data saved in the database.
     * @param {MessageHistoryCreateManyAndReturnArgs} args - Arguments to create many MessageHistories.
     * @example
     * // Create many MessageHistories
     * const messageHistory = await prisma.messageHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageHistories and only return the `id`
     * const messageHistoryWithIdOnly = await prisma.messageHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MessageHistory.
     * @param {MessageHistoryDeleteArgs} args - Arguments to delete one MessageHistory.
     * @example
     * // Delete one MessageHistory
     * const MessageHistory = await prisma.messageHistory.delete({
     *   where: {
     *     // ... filter to delete one MessageHistory
     *   }
     * })
     * 
     */
    delete<T extends MessageHistoryDeleteArgs>(args: SelectSubset<T, MessageHistoryDeleteArgs<ExtArgs>>): Prisma__MessageHistoryClient<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MessageHistory.
     * @param {MessageHistoryUpdateArgs} args - Arguments to update one MessageHistory.
     * @example
     * // Update one MessageHistory
     * const messageHistory = await prisma.messageHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageHistoryUpdateArgs>(args: SelectSubset<T, MessageHistoryUpdateArgs<ExtArgs>>): Prisma__MessageHistoryClient<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MessageHistories.
     * @param {MessageHistoryDeleteManyArgs} args - Arguments to filter MessageHistories to delete.
     * @example
     * // Delete a few MessageHistories
     * const { count } = await prisma.messageHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageHistoryDeleteManyArgs>(args?: SelectSubset<T, MessageHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageHistories
     * const messageHistory = await prisma.messageHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageHistoryUpdateManyArgs>(args: SelectSubset<T, MessageHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MessageHistory.
     * @param {MessageHistoryUpsertArgs} args - Arguments to update or create a MessageHistory.
     * @example
     * // Update or create a MessageHistory
     * const messageHistory = await prisma.messageHistory.upsert({
     *   create: {
     *     // ... data to create a MessageHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageHistory we want to update
     *   }
     * })
     */
    upsert<T extends MessageHistoryUpsertArgs>(args: SelectSubset<T, MessageHistoryUpsertArgs<ExtArgs>>): Prisma__MessageHistoryClient<$Result.GetResult<Prisma.$MessageHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MessageHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageHistoryCountArgs} args - Arguments to filter MessageHistories to count.
     * @example
     * // Count the number of MessageHistories
     * const count = await prisma.messageHistory.count({
     *   where: {
     *     // ... the filter for the MessageHistories we want to count
     *   }
     * })
    **/
    count<T extends MessageHistoryCountArgs>(
      args?: Subset<T, MessageHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageHistoryAggregateArgs>(args: Subset<T, MessageHistoryAggregateArgs>): Prisma.PrismaPromise<GetMessageHistoryAggregateType<T>>

    /**
     * Group by MessageHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageHistoryGroupByArgs['orderBy'] }
        : { orderBy?: MessageHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageHistory model
   */
  readonly fields: MessageHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageHistory model
   */ 
  interface MessageHistoryFieldRefs {
    readonly id: FieldRef<"MessageHistory", 'Int'>
    readonly status: FieldRef<"MessageHistory", 'MessageHistoryStatusType'>
    readonly referenceId: FieldRef<"MessageHistory", 'String'>
    readonly metaData: FieldRef<"MessageHistory", 'Json'>
    readonly created_at: FieldRef<"MessageHistory", 'BigInt'>
    readonly store_id: FieldRef<"MessageHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * MessageHistory findUnique
   */
  export type MessageHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageHistory to fetch.
     */
    where: MessageHistoryWhereUniqueInput
  }

  /**
   * MessageHistory findUniqueOrThrow
   */
  export type MessageHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageHistory to fetch.
     */
    where: MessageHistoryWhereUniqueInput
  }

  /**
   * MessageHistory findFirst
   */
  export type MessageHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageHistory to fetch.
     */
    where?: MessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageHistories to fetch.
     */
    orderBy?: MessageHistoryOrderByWithRelationInput | MessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageHistories.
     */
    cursor?: MessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageHistories.
     */
    distinct?: MessageHistoryScalarFieldEnum | MessageHistoryScalarFieldEnum[]
  }

  /**
   * MessageHistory findFirstOrThrow
   */
  export type MessageHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageHistory to fetch.
     */
    where?: MessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageHistories to fetch.
     */
    orderBy?: MessageHistoryOrderByWithRelationInput | MessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageHistories.
     */
    cursor?: MessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageHistories.
     */
    distinct?: MessageHistoryScalarFieldEnum | MessageHistoryScalarFieldEnum[]
  }

  /**
   * MessageHistory findMany
   */
  export type MessageHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    /**
     * Filter, which MessageHistories to fetch.
     */
    where?: MessageHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageHistories to fetch.
     */
    orderBy?: MessageHistoryOrderByWithRelationInput | MessageHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageHistories.
     */
    cursor?: MessageHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageHistories.
     */
    skip?: number
    distinct?: MessageHistoryScalarFieldEnum | MessageHistoryScalarFieldEnum[]
  }

  /**
   * MessageHistory create
   */
  export type MessageHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageHistory.
     */
    data: XOR<MessageHistoryCreateInput, MessageHistoryUncheckedCreateInput>
  }

  /**
   * MessageHistory createMany
   */
  export type MessageHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageHistories.
     */
    data: MessageHistoryCreateManyInput | MessageHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageHistory createManyAndReturn
   */
  export type MessageHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MessageHistories.
     */
    data: MessageHistoryCreateManyInput | MessageHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageHistory update
   */
  export type MessageHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageHistory.
     */
    data: XOR<MessageHistoryUpdateInput, MessageHistoryUncheckedUpdateInput>
    /**
     * Choose, which MessageHistory to update.
     */
    where: MessageHistoryWhereUniqueInput
  }

  /**
   * MessageHistory updateMany
   */
  export type MessageHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageHistories.
     */
    data: XOR<MessageHistoryUpdateManyMutationInput, MessageHistoryUncheckedUpdateManyInput>
    /**
     * Filter which MessageHistories to update
     */
    where?: MessageHistoryWhereInput
  }

  /**
   * MessageHistory upsert
   */
  export type MessageHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageHistory to update in case it exists.
     */
    where: MessageHistoryWhereUniqueInput
    /**
     * In case the MessageHistory found by the `where` argument doesn't exist, create a new MessageHistory with this data.
     */
    create: XOR<MessageHistoryCreateInput, MessageHistoryUncheckedCreateInput>
    /**
     * In case the MessageHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageHistoryUpdateInput, MessageHistoryUncheckedUpdateInput>
  }

  /**
   * MessageHistory delete
   */
  export type MessageHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
    /**
     * Filter which MessageHistory to delete.
     */
    where: MessageHistoryWhereUniqueInput
  }

  /**
   * MessageHistory deleteMany
   */
  export type MessageHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageHistories to delete
     */
    where?: MessageHistoryWhereInput
  }

  /**
   * MessageHistory without action
   */
  export type MessageHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageHistory
     */
    select?: MessageHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageHistoryInclude<ExtArgs> | null
  }


  /**
   * Model PaymentGateway
   */

  export type AggregatePaymentGateway = {
    _count: PaymentGatewayCountAggregateOutputType | null
    _avg: PaymentGatewayAvgAggregateOutputType | null
    _sum: PaymentGatewaySumAggregateOutputType | null
    _min: PaymentGatewayMinAggregateOutputType | null
    _max: PaymentGatewayMaxAggregateOutputType | null
  }

  export type PaymentGatewayAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type PaymentGatewaySumAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type PaymentGatewayMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    payment_uuid: string | null
    provider: $Enums.PaymentType | null
    webhook_id: string | null
    status: $Enums.NotificationStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type PaymentGatewayMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    payment_uuid: string | null
    provider: $Enums.PaymentType | null
    webhook_id: string | null
    status: $Enums.NotificationStatusType | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type PaymentGatewayCountAggregateOutputType = {
    id: number
    store_id: number
    payment_uuid: number
    provider: number
    credentials: number
    webhook_id: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentGatewayAvgAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentGatewaySumAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentGatewayMinAggregateInputType = {
    id?: true
    store_id?: true
    payment_uuid?: true
    provider?: true
    webhook_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentGatewayMaxAggregateInputType = {
    id?: true
    store_id?: true
    payment_uuid?: true
    provider?: true
    webhook_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentGatewayCountAggregateInputType = {
    id?: true
    store_id?: true
    payment_uuid?: true
    provider?: true
    credentials?: true
    webhook_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentGatewayAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentGateway to aggregate.
     */
    where?: PaymentGatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGateways to fetch.
     */
    orderBy?: PaymentGatewayOrderByWithRelationInput | PaymentGatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentGatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentGateways
    **/
    _count?: true | PaymentGatewayCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentGatewayAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentGatewaySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentGatewayMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentGatewayMaxAggregateInputType
  }

  export type GetPaymentGatewayAggregateType<T extends PaymentGatewayAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentGateway]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentGateway[P]>
      : GetScalarType<T[P], AggregatePaymentGateway[P]>
  }




  export type PaymentGatewayGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentGatewayWhereInput
    orderBy?: PaymentGatewayOrderByWithAggregationInput | PaymentGatewayOrderByWithAggregationInput[]
    by: PaymentGatewayScalarFieldEnum[] | PaymentGatewayScalarFieldEnum
    having?: PaymentGatewayScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentGatewayCountAggregateInputType | true
    _avg?: PaymentGatewayAvgAggregateInputType
    _sum?: PaymentGatewaySumAggregateInputType
    _min?: PaymentGatewayMinAggregateInputType
    _max?: PaymentGatewayMaxAggregateInputType
  }

  export type PaymentGatewayGroupByOutputType = {
    id: number
    store_id: number
    payment_uuid: string
    provider: $Enums.PaymentType
    credentials: JsonValue
    webhook_id: string | null
    status: $Enums.NotificationStatusType
    created_at: bigint
    updated_at: bigint
    _count: PaymentGatewayCountAggregateOutputType | null
    _avg: PaymentGatewayAvgAggregateOutputType | null
    _sum: PaymentGatewaySumAggregateOutputType | null
    _min: PaymentGatewayMinAggregateOutputType | null
    _max: PaymentGatewayMaxAggregateOutputType | null
  }

  type GetPaymentGatewayGroupByPayload<T extends PaymentGatewayGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGatewayGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGatewayGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGatewayGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGatewayGroupByOutputType[P]>
        }
      >
    >


  export type PaymentGatewaySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    payment_uuid?: boolean
    provider?: boolean
    credentials?: boolean
    webhook_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentGateway"]>

  export type PaymentGatewaySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    payment_uuid?: boolean
    provider?: boolean
    credentials?: boolean
    webhook_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentGateway"]>

  export type PaymentGatewaySelectScalar = {
    id?: boolean
    store_id?: boolean
    payment_uuid?: boolean
    provider?: boolean
    credentials?: boolean
    webhook_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PaymentGatewayInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type PaymentGatewayIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $PaymentGatewayPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentGateway"
    objects: {
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      payment_uuid: string
      provider: $Enums.PaymentType
      credentials: Prisma.JsonValue
      webhook_id: string | null
      status: $Enums.NotificationStatusType
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["paymentGateway"]>
    composites: {}
  }

  type PaymentGatewayGetPayload<S extends boolean | null | undefined | PaymentGatewayDefaultArgs> = $Result.GetResult<Prisma.$PaymentGatewayPayload, S>

  type PaymentGatewayCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentGatewayFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentGatewayCountAggregateInputType | true
    }

  export interface PaymentGatewayDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentGateway'], meta: { name: 'PaymentGateway' } }
    /**
     * Find zero or one PaymentGateway that matches the filter.
     * @param {PaymentGatewayFindUniqueArgs} args - Arguments to find a PaymentGateway
     * @example
     * // Get one PaymentGateway
     * const paymentGateway = await prisma.paymentGateway.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentGatewayFindUniqueArgs>(args: SelectSubset<T, PaymentGatewayFindUniqueArgs<ExtArgs>>): Prisma__PaymentGatewayClient<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentGateway that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentGatewayFindUniqueOrThrowArgs} args - Arguments to find a PaymentGateway
     * @example
     * // Get one PaymentGateway
     * const paymentGateway = await prisma.paymentGateway.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentGatewayFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentGatewayFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentGatewayClient<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentGateway that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayFindFirstArgs} args - Arguments to find a PaymentGateway
     * @example
     * // Get one PaymentGateway
     * const paymentGateway = await prisma.paymentGateway.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentGatewayFindFirstArgs>(args?: SelectSubset<T, PaymentGatewayFindFirstArgs<ExtArgs>>): Prisma__PaymentGatewayClient<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentGateway that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayFindFirstOrThrowArgs} args - Arguments to find a PaymentGateway
     * @example
     * // Get one PaymentGateway
     * const paymentGateway = await prisma.paymentGateway.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentGatewayFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentGatewayFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentGatewayClient<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentGateways that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentGateways
     * const paymentGateways = await prisma.paymentGateway.findMany()
     * 
     * // Get first 10 PaymentGateways
     * const paymentGateways = await prisma.paymentGateway.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentGatewayWithIdOnly = await prisma.paymentGateway.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentGatewayFindManyArgs>(args?: SelectSubset<T, PaymentGatewayFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentGateway.
     * @param {PaymentGatewayCreateArgs} args - Arguments to create a PaymentGateway.
     * @example
     * // Create one PaymentGateway
     * const PaymentGateway = await prisma.paymentGateway.create({
     *   data: {
     *     // ... data to create a PaymentGateway
     *   }
     * })
     * 
     */
    create<T extends PaymentGatewayCreateArgs>(args: SelectSubset<T, PaymentGatewayCreateArgs<ExtArgs>>): Prisma__PaymentGatewayClient<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentGateways.
     * @param {PaymentGatewayCreateManyArgs} args - Arguments to create many PaymentGateways.
     * @example
     * // Create many PaymentGateways
     * const paymentGateway = await prisma.paymentGateway.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentGatewayCreateManyArgs>(args?: SelectSubset<T, PaymentGatewayCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentGateways and returns the data saved in the database.
     * @param {PaymentGatewayCreateManyAndReturnArgs} args - Arguments to create many PaymentGateways.
     * @example
     * // Create many PaymentGateways
     * const paymentGateway = await prisma.paymentGateway.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentGateways and only return the `id`
     * const paymentGatewayWithIdOnly = await prisma.paymentGateway.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentGatewayCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentGatewayCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentGateway.
     * @param {PaymentGatewayDeleteArgs} args - Arguments to delete one PaymentGateway.
     * @example
     * // Delete one PaymentGateway
     * const PaymentGateway = await prisma.paymentGateway.delete({
     *   where: {
     *     // ... filter to delete one PaymentGateway
     *   }
     * })
     * 
     */
    delete<T extends PaymentGatewayDeleteArgs>(args: SelectSubset<T, PaymentGatewayDeleteArgs<ExtArgs>>): Prisma__PaymentGatewayClient<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentGateway.
     * @param {PaymentGatewayUpdateArgs} args - Arguments to update one PaymentGateway.
     * @example
     * // Update one PaymentGateway
     * const paymentGateway = await prisma.paymentGateway.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentGatewayUpdateArgs>(args: SelectSubset<T, PaymentGatewayUpdateArgs<ExtArgs>>): Prisma__PaymentGatewayClient<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentGateways.
     * @param {PaymentGatewayDeleteManyArgs} args - Arguments to filter PaymentGateways to delete.
     * @example
     * // Delete a few PaymentGateways
     * const { count } = await prisma.paymentGateway.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentGatewayDeleteManyArgs>(args?: SelectSubset<T, PaymentGatewayDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentGateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentGateways
     * const paymentGateway = await prisma.paymentGateway.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentGatewayUpdateManyArgs>(args: SelectSubset<T, PaymentGatewayUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentGateway.
     * @param {PaymentGatewayUpsertArgs} args - Arguments to update or create a PaymentGateway.
     * @example
     * // Update or create a PaymentGateway
     * const paymentGateway = await prisma.paymentGateway.upsert({
     *   create: {
     *     // ... data to create a PaymentGateway
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentGateway we want to update
     *   }
     * })
     */
    upsert<T extends PaymentGatewayUpsertArgs>(args: SelectSubset<T, PaymentGatewayUpsertArgs<ExtArgs>>): Prisma__PaymentGatewayClient<$Result.GetResult<Prisma.$PaymentGatewayPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentGateways.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayCountArgs} args - Arguments to filter PaymentGateways to count.
     * @example
     * // Count the number of PaymentGateways
     * const count = await prisma.paymentGateway.count({
     *   where: {
     *     // ... the filter for the PaymentGateways we want to count
     *   }
     * })
    **/
    count<T extends PaymentGatewayCountArgs>(
      args?: Subset<T, PaymentGatewayCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentGatewayCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentGateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentGatewayAggregateArgs>(args: Subset<T, PaymentGatewayAggregateArgs>): Prisma.PrismaPromise<GetPaymentGatewayAggregateType<T>>

    /**
     * Group by PaymentGateway.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGatewayGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGatewayGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGatewayGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGatewayGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGatewayGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGatewayGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentGateway model
   */
  readonly fields: PaymentGatewayFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentGateway.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentGatewayClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentGateway model
   */ 
  interface PaymentGatewayFieldRefs {
    readonly id: FieldRef<"PaymentGateway", 'Int'>
    readonly store_id: FieldRef<"PaymentGateway", 'Int'>
    readonly payment_uuid: FieldRef<"PaymentGateway", 'String'>
    readonly provider: FieldRef<"PaymentGateway", 'PaymentType'>
    readonly credentials: FieldRef<"PaymentGateway", 'Json'>
    readonly webhook_id: FieldRef<"PaymentGateway", 'String'>
    readonly status: FieldRef<"PaymentGateway", 'NotificationStatusType'>
    readonly created_at: FieldRef<"PaymentGateway", 'BigInt'>
    readonly updated_at: FieldRef<"PaymentGateway", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * PaymentGateway findUnique
   */
  export type PaymentGatewayFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGateway to fetch.
     */
    where: PaymentGatewayWhereUniqueInput
  }

  /**
   * PaymentGateway findUniqueOrThrow
   */
  export type PaymentGatewayFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGateway to fetch.
     */
    where: PaymentGatewayWhereUniqueInput
  }

  /**
   * PaymentGateway findFirst
   */
  export type PaymentGatewayFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGateway to fetch.
     */
    where?: PaymentGatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGateways to fetch.
     */
    orderBy?: PaymentGatewayOrderByWithRelationInput | PaymentGatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentGateways.
     */
    cursor?: PaymentGatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentGateways.
     */
    distinct?: PaymentGatewayScalarFieldEnum | PaymentGatewayScalarFieldEnum[]
  }

  /**
   * PaymentGateway findFirstOrThrow
   */
  export type PaymentGatewayFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGateway to fetch.
     */
    where?: PaymentGatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGateways to fetch.
     */
    orderBy?: PaymentGatewayOrderByWithRelationInput | PaymentGatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentGateways.
     */
    cursor?: PaymentGatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGateways.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentGateways.
     */
    distinct?: PaymentGatewayScalarFieldEnum | PaymentGatewayScalarFieldEnum[]
  }

  /**
   * PaymentGateway findMany
   */
  export type PaymentGatewayFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    /**
     * Filter, which PaymentGateways to fetch.
     */
    where?: PaymentGatewayWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentGateways to fetch.
     */
    orderBy?: PaymentGatewayOrderByWithRelationInput | PaymentGatewayOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentGateways.
     */
    cursor?: PaymentGatewayWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentGateways from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentGateways.
     */
    skip?: number
    distinct?: PaymentGatewayScalarFieldEnum | PaymentGatewayScalarFieldEnum[]
  }

  /**
   * PaymentGateway create
   */
  export type PaymentGatewayCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentGateway.
     */
    data: XOR<PaymentGatewayCreateInput, PaymentGatewayUncheckedCreateInput>
  }

  /**
   * PaymentGateway createMany
   */
  export type PaymentGatewayCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentGateways.
     */
    data: PaymentGatewayCreateManyInput | PaymentGatewayCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentGateway createManyAndReturn
   */
  export type PaymentGatewayCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentGateways.
     */
    data: PaymentGatewayCreateManyInput | PaymentGatewayCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentGateway update
   */
  export type PaymentGatewayUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentGateway.
     */
    data: XOR<PaymentGatewayUpdateInput, PaymentGatewayUncheckedUpdateInput>
    /**
     * Choose, which PaymentGateway to update.
     */
    where: PaymentGatewayWhereUniqueInput
  }

  /**
   * PaymentGateway updateMany
   */
  export type PaymentGatewayUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentGateways.
     */
    data: XOR<PaymentGatewayUpdateManyMutationInput, PaymentGatewayUncheckedUpdateManyInput>
    /**
     * Filter which PaymentGateways to update
     */
    where?: PaymentGatewayWhereInput
  }

  /**
   * PaymentGateway upsert
   */
  export type PaymentGatewayUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentGateway to update in case it exists.
     */
    where: PaymentGatewayWhereUniqueInput
    /**
     * In case the PaymentGateway found by the `where` argument doesn't exist, create a new PaymentGateway with this data.
     */
    create: XOR<PaymentGatewayCreateInput, PaymentGatewayUncheckedCreateInput>
    /**
     * In case the PaymentGateway was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentGatewayUpdateInput, PaymentGatewayUncheckedUpdateInput>
  }

  /**
   * PaymentGateway delete
   */
  export type PaymentGatewayDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
    /**
     * Filter which PaymentGateway to delete.
     */
    where: PaymentGatewayWhereUniqueInput
  }

  /**
   * PaymentGateway deleteMany
   */
  export type PaymentGatewayDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentGateways to delete
     */
    where?: PaymentGatewayWhereInput
  }

  /**
   * PaymentGateway without action
   */
  export type PaymentGatewayDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentGateway
     */
    select?: PaymentGatewaySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentGatewayInclude<ExtArgs> | null
  }


  /**
   * Model AppSubscription
   */

  export type AggregateAppSubscription = {
    _count: AppSubscriptionCountAggregateOutputType | null
    _avg: AppSubscriptionAvgAggregateOutputType | null
    _sum: AppSubscriptionSumAggregateOutputType | null
    _min: AppSubscriptionMinAggregateOutputType | null
    _max: AppSubscriptionMaxAggregateOutputType | null
  }

  export type AppSubscriptionAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    price: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type AppSubscriptionSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    price: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AppSubscriptionMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    plan_id: string | null
    name: string | null
    price: number | null
    status: $Enums.AppSubscriptionType | null
    currency_code: string | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AppSubscriptionMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    plan_id: string | null
    name: string | null
    price: number | null
    status: $Enums.AppSubscriptionType | null
    currency_code: string | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type AppSubscriptionCountAggregateOutputType = {
    id: number
    store_id: number
    plan_id: number
    name: number
    price: number
    status: number
    currency_code: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type AppSubscriptionAvgAggregateInputType = {
    id?: true
    store_id?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type AppSubscriptionSumAggregateInputType = {
    id?: true
    store_id?: true
    price?: true
    created_at?: true
    updated_at?: true
  }

  export type AppSubscriptionMinAggregateInputType = {
    id?: true
    store_id?: true
    plan_id?: true
    name?: true
    price?: true
    status?: true
    currency_code?: true
    created_at?: true
    updated_at?: true
  }

  export type AppSubscriptionMaxAggregateInputType = {
    id?: true
    store_id?: true
    plan_id?: true
    name?: true
    price?: true
    status?: true
    currency_code?: true
    created_at?: true
    updated_at?: true
  }

  export type AppSubscriptionCountAggregateInputType = {
    id?: true
    store_id?: true
    plan_id?: true
    name?: true
    price?: true
    status?: true
    currency_code?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type AppSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppSubscription to aggregate.
     */
    where?: AppSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSubscriptions to fetch.
     */
    orderBy?: AppSubscriptionOrderByWithRelationInput | AppSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppSubscriptions
    **/
    _count?: true | AppSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppSubscriptionMaxAggregateInputType
  }

  export type GetAppSubscriptionAggregateType<T extends AppSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateAppSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppSubscription[P]>
      : GetScalarType<T[P], AggregateAppSubscription[P]>
  }




  export type AppSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppSubscriptionWhereInput
    orderBy?: AppSubscriptionOrderByWithAggregationInput | AppSubscriptionOrderByWithAggregationInput[]
    by: AppSubscriptionScalarFieldEnum[] | AppSubscriptionScalarFieldEnum
    having?: AppSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppSubscriptionCountAggregateInputType | true
    _avg?: AppSubscriptionAvgAggregateInputType
    _sum?: AppSubscriptionSumAggregateInputType
    _min?: AppSubscriptionMinAggregateInputType
    _max?: AppSubscriptionMaxAggregateInputType
  }

  export type AppSubscriptionGroupByOutputType = {
    id: number
    store_id: number
    plan_id: string | null
    name: string
    price: number
    status: $Enums.AppSubscriptionType
    currency_code: string
    created_at: bigint
    updated_at: bigint
    _count: AppSubscriptionCountAggregateOutputType | null
    _avg: AppSubscriptionAvgAggregateOutputType | null
    _sum: AppSubscriptionSumAggregateOutputType | null
    _min: AppSubscriptionMinAggregateOutputType | null
    _max: AppSubscriptionMaxAggregateOutputType | null
  }

  type GetAppSubscriptionGroupByPayload<T extends AppSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], AppSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type AppSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    plan_id?: boolean
    name?: boolean
    price?: boolean
    status?: boolean
    currency_code?: boolean
    created_at?: boolean
    updated_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appSubscription"]>

  export type AppSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    plan_id?: boolean
    name?: boolean
    price?: boolean
    status?: boolean
    currency_code?: boolean
    created_at?: boolean
    updated_at?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appSubscription"]>

  export type AppSubscriptionSelectScalar = {
    id?: boolean
    store_id?: boolean
    plan_id?: boolean
    name?: boolean
    price?: boolean
    status?: boolean
    currency_code?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type AppSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type AppSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $AppSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppSubscription"
    objects: {
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      plan_id: string | null
      name: string
      price: number
      status: $Enums.AppSubscriptionType
      currency_code: string
      created_at: bigint
      updated_at: bigint
    }, ExtArgs["result"]["appSubscription"]>
    composites: {}
  }

  type AppSubscriptionGetPayload<S extends boolean | null | undefined | AppSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$AppSubscriptionPayload, S>

  type AppSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppSubscriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppSubscriptionCountAggregateInputType | true
    }

  export interface AppSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppSubscription'], meta: { name: 'AppSubscription' } }
    /**
     * Find zero or one AppSubscription that matches the filter.
     * @param {AppSubscriptionFindUniqueArgs} args - Arguments to find a AppSubscription
     * @example
     * // Get one AppSubscription
     * const appSubscription = await prisma.appSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppSubscriptionFindUniqueArgs>(args: SelectSubset<T, AppSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__AppSubscriptionClient<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AppSubscription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a AppSubscription
     * @example
     * // Get one AppSubscription
     * const appSubscription = await prisma.appSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, AppSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppSubscriptionClient<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AppSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSubscriptionFindFirstArgs} args - Arguments to find a AppSubscription
     * @example
     * // Get one AppSubscription
     * const appSubscription = await prisma.appSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppSubscriptionFindFirstArgs>(args?: SelectSubset<T, AppSubscriptionFindFirstArgs<ExtArgs>>): Prisma__AppSubscriptionClient<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AppSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSubscriptionFindFirstOrThrowArgs} args - Arguments to find a AppSubscription
     * @example
     * // Get one AppSubscription
     * const appSubscription = await prisma.appSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, AppSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppSubscriptionClient<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AppSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppSubscriptions
     * const appSubscriptions = await prisma.appSubscription.findMany()
     * 
     * // Get first 10 AppSubscriptions
     * const appSubscriptions = await prisma.appSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appSubscriptionWithIdOnly = await prisma.appSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppSubscriptionFindManyArgs>(args?: SelectSubset<T, AppSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AppSubscription.
     * @param {AppSubscriptionCreateArgs} args - Arguments to create a AppSubscription.
     * @example
     * // Create one AppSubscription
     * const AppSubscription = await prisma.appSubscription.create({
     *   data: {
     *     // ... data to create a AppSubscription
     *   }
     * })
     * 
     */
    create<T extends AppSubscriptionCreateArgs>(args: SelectSubset<T, AppSubscriptionCreateArgs<ExtArgs>>): Prisma__AppSubscriptionClient<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AppSubscriptions.
     * @param {AppSubscriptionCreateManyArgs} args - Arguments to create many AppSubscriptions.
     * @example
     * // Create many AppSubscriptions
     * const appSubscription = await prisma.appSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppSubscriptionCreateManyArgs>(args?: SelectSubset<T, AppSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppSubscriptions and returns the data saved in the database.
     * @param {AppSubscriptionCreateManyAndReturnArgs} args - Arguments to create many AppSubscriptions.
     * @example
     * // Create many AppSubscriptions
     * const appSubscription = await prisma.appSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppSubscriptions and only return the `id`
     * const appSubscriptionWithIdOnly = await prisma.appSubscription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, AppSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AppSubscription.
     * @param {AppSubscriptionDeleteArgs} args - Arguments to delete one AppSubscription.
     * @example
     * // Delete one AppSubscription
     * const AppSubscription = await prisma.appSubscription.delete({
     *   where: {
     *     // ... filter to delete one AppSubscription
     *   }
     * })
     * 
     */
    delete<T extends AppSubscriptionDeleteArgs>(args: SelectSubset<T, AppSubscriptionDeleteArgs<ExtArgs>>): Prisma__AppSubscriptionClient<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AppSubscription.
     * @param {AppSubscriptionUpdateArgs} args - Arguments to update one AppSubscription.
     * @example
     * // Update one AppSubscription
     * const appSubscription = await prisma.appSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppSubscriptionUpdateArgs>(args: SelectSubset<T, AppSubscriptionUpdateArgs<ExtArgs>>): Prisma__AppSubscriptionClient<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AppSubscriptions.
     * @param {AppSubscriptionDeleteManyArgs} args - Arguments to filter AppSubscriptions to delete.
     * @example
     * // Delete a few AppSubscriptions
     * const { count } = await prisma.appSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppSubscriptionDeleteManyArgs>(args?: SelectSubset<T, AppSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppSubscriptions
     * const appSubscription = await prisma.appSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppSubscriptionUpdateManyArgs>(args: SelectSubset<T, AppSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AppSubscription.
     * @param {AppSubscriptionUpsertArgs} args - Arguments to update or create a AppSubscription.
     * @example
     * // Update or create a AppSubscription
     * const appSubscription = await prisma.appSubscription.upsert({
     *   create: {
     *     // ... data to create a AppSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppSubscription we want to update
     *   }
     * })
     */
    upsert<T extends AppSubscriptionUpsertArgs>(args: SelectSubset<T, AppSubscriptionUpsertArgs<ExtArgs>>): Prisma__AppSubscriptionClient<$Result.GetResult<Prisma.$AppSubscriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AppSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSubscriptionCountArgs} args - Arguments to filter AppSubscriptions to count.
     * @example
     * // Count the number of AppSubscriptions
     * const count = await prisma.appSubscription.count({
     *   where: {
     *     // ... the filter for the AppSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends AppSubscriptionCountArgs>(
      args?: Subset<T, AppSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppSubscriptionAggregateArgs>(args: Subset<T, AppSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetAppSubscriptionAggregateType<T>>

    /**
     * Group by AppSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: AppSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppSubscription model
   */
  readonly fields: AppSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppSubscription model
   */ 
  interface AppSubscriptionFieldRefs {
    readonly id: FieldRef<"AppSubscription", 'Int'>
    readonly store_id: FieldRef<"AppSubscription", 'Int'>
    readonly plan_id: FieldRef<"AppSubscription", 'String'>
    readonly name: FieldRef<"AppSubscription", 'String'>
    readonly price: FieldRef<"AppSubscription", 'Int'>
    readonly status: FieldRef<"AppSubscription", 'AppSubscriptionType'>
    readonly currency_code: FieldRef<"AppSubscription", 'String'>
    readonly created_at: FieldRef<"AppSubscription", 'BigInt'>
    readonly updated_at: FieldRef<"AppSubscription", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * AppSubscription findUnique
   */
  export type AppSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AppSubscription to fetch.
     */
    where: AppSubscriptionWhereUniqueInput
  }

  /**
   * AppSubscription findUniqueOrThrow
   */
  export type AppSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AppSubscription to fetch.
     */
    where: AppSubscriptionWhereUniqueInput
  }

  /**
   * AppSubscription findFirst
   */
  export type AppSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AppSubscription to fetch.
     */
    where?: AppSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSubscriptions to fetch.
     */
    orderBy?: AppSubscriptionOrderByWithRelationInput | AppSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppSubscriptions.
     */
    cursor?: AppSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppSubscriptions.
     */
    distinct?: AppSubscriptionScalarFieldEnum | AppSubscriptionScalarFieldEnum[]
  }

  /**
   * AppSubscription findFirstOrThrow
   */
  export type AppSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AppSubscription to fetch.
     */
    where?: AppSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSubscriptions to fetch.
     */
    orderBy?: AppSubscriptionOrderByWithRelationInput | AppSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppSubscriptions.
     */
    cursor?: AppSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppSubscriptions.
     */
    distinct?: AppSubscriptionScalarFieldEnum | AppSubscriptionScalarFieldEnum[]
  }

  /**
   * AppSubscription findMany
   */
  export type AppSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which AppSubscriptions to fetch.
     */
    where?: AppSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSubscriptions to fetch.
     */
    orderBy?: AppSubscriptionOrderByWithRelationInput | AppSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppSubscriptions.
     */
    cursor?: AppSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSubscriptions.
     */
    skip?: number
    distinct?: AppSubscriptionScalarFieldEnum | AppSubscriptionScalarFieldEnum[]
  }

  /**
   * AppSubscription create
   */
  export type AppSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a AppSubscription.
     */
    data: XOR<AppSubscriptionCreateInput, AppSubscriptionUncheckedCreateInput>
  }

  /**
   * AppSubscription createMany
   */
  export type AppSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppSubscriptions.
     */
    data: AppSubscriptionCreateManyInput | AppSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppSubscription createManyAndReturn
   */
  export type AppSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AppSubscriptions.
     */
    data: AppSubscriptionCreateManyInput | AppSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppSubscription update
   */
  export type AppSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a AppSubscription.
     */
    data: XOR<AppSubscriptionUpdateInput, AppSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which AppSubscription to update.
     */
    where: AppSubscriptionWhereUniqueInput
  }

  /**
   * AppSubscription updateMany
   */
  export type AppSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppSubscriptions.
     */
    data: XOR<AppSubscriptionUpdateManyMutationInput, AppSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which AppSubscriptions to update
     */
    where?: AppSubscriptionWhereInput
  }

  /**
   * AppSubscription upsert
   */
  export type AppSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the AppSubscription to update in case it exists.
     */
    where: AppSubscriptionWhereUniqueInput
    /**
     * In case the AppSubscription found by the `where` argument doesn't exist, create a new AppSubscription with this data.
     */
    create: XOR<AppSubscriptionCreateInput, AppSubscriptionUncheckedCreateInput>
    /**
     * In case the AppSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppSubscriptionUpdateInput, AppSubscriptionUncheckedUpdateInput>
  }

  /**
   * AppSubscription delete
   */
  export type AppSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which AppSubscription to delete.
     */
    where: AppSubscriptionWhereUniqueInput
  }

  /**
   * AppSubscription deleteMany
   */
  export type AppSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppSubscriptions to delete
     */
    where?: AppSubscriptionWhereInput
  }

  /**
   * AppSubscription without action
   */
  export type AppSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSubscription
     */
    select?: AppSubscriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Integrations
   */

  export type AggregateIntegrations = {
    _count: IntegrationsCountAggregateOutputType | null
    _avg: IntegrationsAvgAggregateOutputType | null
    _sum: IntegrationsSumAggregateOutputType | null
    _min: IntegrationsMinAggregateOutputType | null
    _max: IntegrationsMaxAggregateOutputType | null
  }

  export type IntegrationsAvgAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: number | null
    updated_at: number | null
  }

  export type IntegrationsSumAggregateOutputType = {
    id: number | null
    store_id: number | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type IntegrationsMinAggregateOutputType = {
    id: number | null
    store_id: number | null
    integration_type: $Enums.IntegrationType | null
    status: $Enums.NotificationStatusType | null
    api_key: string | null
    api_secret: string | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type IntegrationsMaxAggregateOutputType = {
    id: number | null
    store_id: number | null
    integration_type: $Enums.IntegrationType | null
    status: $Enums.NotificationStatusType | null
    api_key: string | null
    api_secret: string | null
    created_at: bigint | null
    updated_at: bigint | null
  }

  export type IntegrationsCountAggregateOutputType = {
    id: number
    store_id: number
    integration_type: number
    status: number
    api_key: number
    api_secret: number
    created_at: number
    updated_at: number
    integration_details: number
    _all: number
  }


  export type IntegrationsAvgAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type IntegrationsSumAggregateInputType = {
    id?: true
    store_id?: true
    created_at?: true
    updated_at?: true
  }

  export type IntegrationsMinAggregateInputType = {
    id?: true
    store_id?: true
    integration_type?: true
    status?: true
    api_key?: true
    api_secret?: true
    created_at?: true
    updated_at?: true
  }

  export type IntegrationsMaxAggregateInputType = {
    id?: true
    store_id?: true
    integration_type?: true
    status?: true
    api_key?: true
    api_secret?: true
    created_at?: true
    updated_at?: true
  }

  export type IntegrationsCountAggregateInputType = {
    id?: true
    store_id?: true
    integration_type?: true
    status?: true
    api_key?: true
    api_secret?: true
    created_at?: true
    updated_at?: true
    integration_details?: true
    _all?: true
  }

  export type IntegrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to aggregate.
     */
    where?: IntegrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationsOrderByWithRelationInput | IntegrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IntegrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IntegrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationsMaxAggregateInputType
  }

  export type GetIntegrationsAggregateType<T extends IntegrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegrations[P]>
      : GetScalarType<T[P], AggregateIntegrations[P]>
  }




  export type IntegrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationsWhereInput
    orderBy?: IntegrationsOrderByWithAggregationInput | IntegrationsOrderByWithAggregationInput[]
    by: IntegrationsScalarFieldEnum[] | IntegrationsScalarFieldEnum
    having?: IntegrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationsCountAggregateInputType | true
    _avg?: IntegrationsAvgAggregateInputType
    _sum?: IntegrationsSumAggregateInputType
    _min?: IntegrationsMinAggregateInputType
    _max?: IntegrationsMaxAggregateInputType
  }

  export type IntegrationsGroupByOutputType = {
    id: number
    store_id: number
    integration_type: $Enums.IntegrationType
    status: $Enums.NotificationStatusType
    api_key: string
    api_secret: string | null
    created_at: bigint
    updated_at: bigint
    integration_details: JsonValue | null
    _count: IntegrationsCountAggregateOutputType | null
    _avg: IntegrationsAvgAggregateOutputType | null
    _sum: IntegrationsSumAggregateOutputType | null
    _min: IntegrationsMinAggregateOutputType | null
    _max: IntegrationsMaxAggregateOutputType | null
  }

  type GetIntegrationsGroupByPayload<T extends IntegrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationsGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationsGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    integration_type?: boolean
    status?: boolean
    api_key?: boolean
    api_secret?: boolean
    created_at?: boolean
    updated_at?: boolean
    integration_details?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrations"]>

  export type IntegrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    store_id?: boolean
    integration_type?: boolean
    status?: boolean
    api_key?: boolean
    api_secret?: boolean
    created_at?: boolean
    updated_at?: boolean
    integration_details?: boolean
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integrations"]>

  export type IntegrationsSelectScalar = {
    id?: boolean
    store_id?: boolean
    integration_type?: boolean
    status?: boolean
    api_key?: boolean
    api_secret?: boolean
    created_at?: boolean
    updated_at?: boolean
    integration_details?: boolean
  }

  export type IntegrationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }
  export type IntegrationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stores?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $IntegrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integrations"
    objects: {
      stores: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      store_id: number
      integration_type: $Enums.IntegrationType
      status: $Enums.NotificationStatusType
      api_key: string
      api_secret: string | null
      created_at: bigint
      updated_at: bigint
      integration_details: Prisma.JsonValue | null
    }, ExtArgs["result"]["integrations"]>
    composites: {}
  }

  type IntegrationsGetPayload<S extends boolean | null | undefined | IntegrationsDefaultArgs> = $Result.GetResult<Prisma.$IntegrationsPayload, S>

  type IntegrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IntegrationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IntegrationsCountAggregateInputType | true
    }

  export interface IntegrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integrations'], meta: { name: 'Integrations' } }
    /**
     * Find zero or one Integrations that matches the filter.
     * @param {IntegrationsFindUniqueArgs} args - Arguments to find a Integrations
     * @example
     * // Get one Integrations
     * const integrations = await prisma.integrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationsFindUniqueArgs>(args: SelectSubset<T, IntegrationsFindUniqueArgs<ExtArgs>>): Prisma__IntegrationsClient<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Integrations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IntegrationsFindUniqueOrThrowArgs} args - Arguments to find a Integrations
     * @example
     * // Get one Integrations
     * const integrations = await prisma.integrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationsClient<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationsFindFirstArgs} args - Arguments to find a Integrations
     * @example
     * // Get one Integrations
     * const integrations = await prisma.integrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationsFindFirstArgs>(args?: SelectSubset<T, IntegrationsFindFirstArgs<ExtArgs>>): Prisma__IntegrationsClient<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Integrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationsFindFirstOrThrowArgs} args - Arguments to find a Integrations
     * @example
     * // Get one Integrations
     * const integrations = await prisma.integrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationsClient<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integrations.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationsWithIdOnly = await prisma.integrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationsFindManyArgs>(args?: SelectSubset<T, IntegrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Integrations.
     * @param {IntegrationsCreateArgs} args - Arguments to create a Integrations.
     * @example
     * // Create one Integrations
     * const Integrations = await prisma.integrations.create({
     *   data: {
     *     // ... data to create a Integrations
     *   }
     * })
     * 
     */
    create<T extends IntegrationsCreateArgs>(args: SelectSubset<T, IntegrationsCreateArgs<ExtArgs>>): Prisma__IntegrationsClient<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Integrations.
     * @param {IntegrationsCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integrations = await prisma.integrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationsCreateManyArgs>(args?: SelectSubset<T, IntegrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationsCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integrations = await prisma.integrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationsWithIdOnly = await prisma.integrations.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Integrations.
     * @param {IntegrationsDeleteArgs} args - Arguments to delete one Integrations.
     * @example
     * // Delete one Integrations
     * const Integrations = await prisma.integrations.delete({
     *   where: {
     *     // ... filter to delete one Integrations
     *   }
     * })
     * 
     */
    delete<T extends IntegrationsDeleteArgs>(args: SelectSubset<T, IntegrationsDeleteArgs<ExtArgs>>): Prisma__IntegrationsClient<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Integrations.
     * @param {IntegrationsUpdateArgs} args - Arguments to update one Integrations.
     * @example
     * // Update one Integrations
     * const integrations = await prisma.integrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationsUpdateArgs>(args: SelectSubset<T, IntegrationsUpdateArgs<ExtArgs>>): Prisma__IntegrationsClient<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationsDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationsDeleteManyArgs>(args?: SelectSubset<T, IntegrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integrations = await prisma.integrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationsUpdateManyArgs>(args: SelectSubset<T, IntegrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Integrations.
     * @param {IntegrationsUpsertArgs} args - Arguments to update or create a Integrations.
     * @example
     * // Update or create a Integrations
     * const integrations = await prisma.integrations.upsert({
     *   create: {
     *     // ... data to create a Integrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integrations we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationsUpsertArgs>(args: SelectSubset<T, IntegrationsUpsertArgs<ExtArgs>>): Prisma__IntegrationsClient<$Result.GetResult<Prisma.$IntegrationsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationsCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integrations.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationsCountArgs>(
      args?: Subset<T, IntegrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationsAggregateArgs>(args: Subset<T, IntegrationsAggregateArgs>): Prisma.PrismaPromise<GetIntegrationsAggregateType<T>>

    /**
     * Group by Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationsGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integrations model
   */
  readonly fields: IntegrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stores<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integrations model
   */ 
  interface IntegrationsFieldRefs {
    readonly id: FieldRef<"Integrations", 'Int'>
    readonly store_id: FieldRef<"Integrations", 'Int'>
    readonly integration_type: FieldRef<"Integrations", 'IntegrationType'>
    readonly status: FieldRef<"Integrations", 'NotificationStatusType'>
    readonly api_key: FieldRef<"Integrations", 'String'>
    readonly api_secret: FieldRef<"Integrations", 'String'>
    readonly created_at: FieldRef<"Integrations", 'BigInt'>
    readonly updated_at: FieldRef<"Integrations", 'BigInt'>
    readonly integration_details: FieldRef<"Integrations", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Integrations findUnique
   */
  export type IntegrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where: IntegrationsWhereUniqueInput
  }

  /**
   * Integrations findUniqueOrThrow
   */
  export type IntegrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where: IntegrationsWhereUniqueInput
  }

  /**
   * Integrations findFirst
   */
  export type IntegrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationsOrderByWithRelationInput | IntegrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationsScalarFieldEnum | IntegrationsScalarFieldEnum[]
  }

  /**
   * Integrations findFirstOrThrow
   */
  export type IntegrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationsOrderByWithRelationInput | IntegrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationsScalarFieldEnum | IntegrationsScalarFieldEnum[]
  }

  /**
   * Integrations findMany
   */
  export type IntegrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationsOrderByWithRelationInput | IntegrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationsScalarFieldEnum | IntegrationsScalarFieldEnum[]
  }

  /**
   * Integrations create
   */
  export type IntegrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    /**
     * The data needed to create a Integrations.
     */
    data: XOR<IntegrationsCreateInput, IntegrationsUncheckedCreateInput>
  }

  /**
   * Integrations createMany
   */
  export type IntegrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationsCreateManyInput | IntegrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integrations createManyAndReturn
   */
  export type IntegrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationsCreateManyInput | IntegrationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integrations update
   */
  export type IntegrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    /**
     * The data needed to update a Integrations.
     */
    data: XOR<IntegrationsUpdateInput, IntegrationsUncheckedUpdateInput>
    /**
     * Choose, which Integrations to update.
     */
    where: IntegrationsWhereUniqueInput
  }

  /**
   * Integrations updateMany
   */
  export type IntegrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationsUpdateManyMutationInput, IntegrationsUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationsWhereInput
  }

  /**
   * Integrations upsert
   */
  export type IntegrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    /**
     * The filter to search for the Integrations to update in case it exists.
     */
    where: IntegrationsWhereUniqueInput
    /**
     * In case the Integrations found by the `where` argument doesn't exist, create a new Integrations with this data.
     */
    create: XOR<IntegrationsCreateInput, IntegrationsUncheckedCreateInput>
    /**
     * In case the Integrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationsUpdateInput, IntegrationsUncheckedUpdateInput>
  }

  /**
   * Integrations delete
   */
  export type IntegrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
    /**
     * Filter which Integrations to delete.
     */
    where: IntegrationsWhereUniqueInput
  }

  /**
   * Integrations deleteMany
   */
  export type IntegrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationsWhereInput
  }

  /**
   * Integrations without action
   */
  export type IntegrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integrations
     */
    select?: IntegrationsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StoresScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    domain: 'domain',
    myshopify_domain: 'myshopify_domain',
    email: 'email',
    blacklisted: 'blacklisted',
    currency_code: 'currency_code',
    country_code: 'country_code',
    language: 'language',
    status: 'status',
    store_details: 'store_details',
    remote_details: 'remote_details',
    admin_access_token: 'admin_access_token',
    storefront_access_token: 'storefront_access_token',
    created_at: 'created_at',
    updated_at: 'updated_at',
    shopify_store_id: 'shopify_store_id',
    landing_page_id: 'landing_page_id',
    portal_page_id: 'portal_page_id',
    contact_email: 'contact_email',
    contact_name: 'contact_name',
    contact_phone: 'contact_phone',
    webhook_registration_check: 'webhook_registration_check'
  };

  export type StoresScalarFieldEnum = (typeof StoresScalarFieldEnum)[keyof typeof StoresScalarFieldEnum]


  export const MembersScalarFieldEnum: {
    id: 'id',
    member_id: 'member_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    phone: 'phone',
    member_details: 'member_details',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MembersScalarFieldEnum = (typeof MembersScalarFieldEnum)[keyof typeof MembersScalarFieldEnum]


  export const ProgramsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    title: 'title',
    description: 'description',
    currency_code: 'currency_code',
    program_details: 'program_details',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProgramsScalarFieldEnum = (typeof ProgramsScalarFieldEnum)[keyof typeof ProgramsScalarFieldEnum]


  export const TiersScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    program_id: 'program_id',
    tier_type: 'tier_type',
    min_value: 'min_value',
    max_value: 'max_value',
    commission_type: 'commission_type',
    commission_rate: 'commission_rate',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TiersScalarFieldEnum = (typeof TiersScalarFieldEnum)[keyof typeof TiersScalarFieldEnum]


  export const CustomerDiscountsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    program_id: 'program_id',
    discount_rate: 'discount_rate',
    discount_options: 'discount_options',
    created_at: 'created_at',
    updated_at: 'updated_at',
    discount_type: 'discount_type'
  };

  export type CustomerDiscountsScalarFieldEnum = (typeof CustomerDiscountsScalarFieldEnum)[keyof typeof CustomerDiscountsScalarFieldEnum]


  export const OrdersScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    customer_id: 'customer_id',
    order_id: 'order_id',
    shopify_order_number: 'shopify_order_number',
    shop_order_currency_code: 'shop_order_currency_code',
    shop_order_amount: 'shop_order_amount',
    customer_order_currency_code: 'customer_order_currency_code',
    customer_order_amount: 'customer_order_amount',
    financial_status: 'financial_status',
    order_details: 'order_details',
    attribute_type: 'attribute_type',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    program_id: 'program_id'
  };

  export type OrdersScalarFieldEnum = (typeof OrdersScalarFieldEnum)[keyof typeof OrdersScalarFieldEnum]


  export const OrderItemsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    customer_id: 'customer_id',
    order_id: 'order_id',
    item_id: 'item_id',
    product_id: 'product_id',
    variant_id: 'variant_id',
    product_title: 'product_title',
    variant_title: 'variant_title',
    quantity: 'quantity',
    shop_item_currency_code: 'shop_item_currency_code',
    shop_item_amount: 'shop_item_amount',
    customer_item_currency_code: 'customer_item_currency_code',
    customer_item_amount: 'customer_item_amount',
    item_details: 'item_details',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OrderItemsScalarFieldEnum = (typeof OrderItemsScalarFieldEnum)[keyof typeof OrderItemsScalarFieldEnum]


  export const CommissionsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    order_id: 'order_id',
    currency_code: 'currency_code',
    amount: 'amount',
    status: 'status',
    approval_mode: 'approval_mode',
    review_on: 'review_on',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CommissionsScalarFieldEnum = (typeof CommissionsScalarFieldEnum)[keyof typeof CommissionsScalarFieldEnum]


  export const PayoutsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    transaction_id: 'transaction_id',
    currency_code: 'currency_code',
    amount: 'amount',
    notes: 'notes',
    payment_method: 'payment_method',
    payment_details: 'payment_details',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id',
    job_id: 'job_id'
  };

  export type PayoutsScalarFieldEnum = (typeof PayoutsScalarFieldEnum)[keyof typeof PayoutsScalarFieldEnum]


  export const BonusScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    title: 'title',
    description: 'description',
    bonus_associate: 'bonus_associate',
    target_type: 'target_type',
    target_goal: 'target_goal',
    bonus_type: 'bonus_type',
    bonus_rate: 'bonus_rate',
    status: 'status',
    begin_datetime: 'begin_datetime',
    expire_datetime: 'expire_datetime',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BonusScalarFieldEnum = (typeof BonusScalarFieldEnum)[keyof typeof BonusScalarFieldEnum]


  export const GiftsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    title: 'title',
    description: 'description',
    products: 'products',
    gift_type: 'gift_type',
    status: 'status',
    shipping_method: 'shipping_method',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type GiftsScalarFieldEnum = (typeof GiftsScalarFieldEnum)[keyof typeof GiftsScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    reference_type: 'reference_type',
    reference_id: 'reference_id',
    currency_code: 'currency_code',
    type: 'type',
    is_reverted: 'is_reverted',
    amount: 'amount',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    commission_delay: 'commission_delay',
    commission_approval_mode: 'commission_approval_mode',
    commission_calculation: 'commission_calculation',
    details: 'details',
    min_threshold: 'min_threshold',
    primary_color: 'primary_color',
    secondary_color: 'secondary_color',
    created_at: 'created_at',
    updated_at: 'updated_at',
    current_email_lang: 'current_email_lang',
    email_limit: 'email_limit',
    notify_once: 'notify_once'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    job_metadata: 'job_metadata',
    status: 'status',
    type: 'type',
    job_details: 'job_details',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const CustomersScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    shopify_customer_id: 'shopify_customer_id',
    first_name: 'first_name',
    last_name: 'last_name',
    contact_type: 'contact_type',
    email: 'email',
    phone: 'phone',
    customer_details: 'customer_details',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CustomersScalarFieldEnum = (typeof CustomersScalarFieldEnum)[keyof typeof CustomersScalarFieldEnum]


  export const AffiliatesScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    member_id: 'member_id',
    first_name: 'first_name',
    last_name: 'last_name',
    phone: 'phone',
    referral_code: 'referral_code',
    status: 'status',
    affiliate_details: 'affiliate_details',
    payout_requested: 'payout_requested',
    created_at: 'created_at',
    updated_at: 'updated_at',
    source: 'source'
  };

  export type AffiliatesScalarFieldEnum = (typeof AffiliatesScalarFieldEnum)[keyof typeof AffiliatesScalarFieldEnum]


  export const AffiliateProgramsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    program_id: 'program_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AffiliateProgramsScalarFieldEnum = (typeof AffiliateProgramsScalarFieldEnum)[keyof typeof AffiliateProgramsScalarFieldEnum]


  export const AffiliateProgramHistoryScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    program_id: 'program_id',
    program_name: 'program_name',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AffiliateProgramHistoryScalarFieldEnum = (typeof AffiliateProgramHistoryScalarFieldEnum)[keyof typeof AffiliateProgramHistoryScalarFieldEnum]


  export const AffiliateDiscountsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    discount_id: 'discount_id',
    discount_code: 'discount_code',
    is_deleted: 'is_deleted',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AffiliateDiscountsScalarFieldEnum = (typeof AffiliateDiscountsScalarFieldEnum)[keyof typeof AffiliateDiscountsScalarFieldEnum]


  export const AffiliateGiftsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    gift_id: 'gift_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AffiliateGiftsScalarFieldEnum = (typeof AffiliateGiftsScalarFieldEnum)[keyof typeof AffiliateGiftsScalarFieldEnum]


  export const AffiliateBonusScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    bonus_id: 'bonus_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AffiliateBonusScalarFieldEnum = (typeof AffiliateBonusScalarFieldEnum)[keyof typeof AffiliateBonusScalarFieldEnum]


  export const ProgramBonusScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    program_id: 'program_id',
    bonus_id: 'bonus_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProgramBonusScalarFieldEnum = (typeof ProgramBonusScalarFieldEnum)[keyof typeof ProgramBonusScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    code: 'code',
    email: 'email',
    expire_at: 'expire_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    notification_id: 'notification_id',
    store_id: 'store_id',
    type: 'type',
    receiver_type: 'receiver_type',
    subject: 'subject',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    languages: 'languages'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    affiliate_id: 'affiliate_id',
    program_id: 'program_id',
    order_id: 'order_id',
    payout_id: 'payout_id',
    entity_type: 'entity_type',
    message: 'message',
    created_at: 'created_at'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const MessageHistoryScalarFieldEnum: {
    id: 'id',
    status: 'status',
    referenceId: 'referenceId',
    metaData: 'metaData',
    created_at: 'created_at',
    store_id: 'store_id'
  };

  export type MessageHistoryScalarFieldEnum = (typeof MessageHistoryScalarFieldEnum)[keyof typeof MessageHistoryScalarFieldEnum]


  export const PaymentGatewayScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    payment_uuid: 'payment_uuid',
    provider: 'provider',
    credentials: 'credentials',
    webhook_id: 'webhook_id',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentGatewayScalarFieldEnum = (typeof PaymentGatewayScalarFieldEnum)[keyof typeof PaymentGatewayScalarFieldEnum]


  export const AppSubscriptionScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    plan_id: 'plan_id',
    name: 'name',
    price: 'price',
    status: 'status',
    currency_code: 'currency_code',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type AppSubscriptionScalarFieldEnum = (typeof AppSubscriptionScalarFieldEnum)[keyof typeof AppSubscriptionScalarFieldEnum]


  export const IntegrationsScalarFieldEnum: {
    id: 'id',
    store_id: 'store_id',
    integration_type: 'integration_type',
    status: 'status',
    api_key: 'api_key',
    api_secret: 'api_secret',
    created_at: 'created_at',
    updated_at: 'updated_at',
    integration_details: 'integration_details'
  };

  export type IntegrationsScalarFieldEnum = (typeof IntegrationsScalarFieldEnum)[keyof typeof IntegrationsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'StoreStatusType'
   */
  export type EnumStoreStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreStatusType'>
    


  /**
   * Reference to a field of type 'StoreStatusType[]'
   */
  export type ListEnumStoreStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StoreStatusType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'ProgramStatusType'
   */
  export type EnumProgramStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgramStatusType'>
    


  /**
   * Reference to a field of type 'ProgramStatusType[]'
   */
  export type ListEnumProgramStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgramStatusType[]'>
    


  /**
   * Reference to a field of type 'TierType'
   */
  export type EnumTierTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TierType'>
    


  /**
   * Reference to a field of type 'TierType[]'
   */
  export type ListEnumTierTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TierType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'EarningType'
   */
  export type EnumEarningTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EarningType'>
    


  /**
   * Reference to a field of type 'EarningType[]'
   */
  export type ListEnumEarningTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EarningType[]'>
    


  /**
   * Reference to a field of type 'CustomerDiscountType'
   */
  export type EnumCustomerDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerDiscountType'>
    


  /**
   * Reference to a field of type 'CustomerDiscountType[]'
   */
  export type ListEnumCustomerDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerDiscountType[]'>
    


  /**
   * Reference to a field of type 'OrderAttributeType'
   */
  export type EnumOrderAttributeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderAttributeType'>
    


  /**
   * Reference to a field of type 'OrderAttributeType[]'
   */
  export type ListEnumOrderAttributeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderAttributeType[]'>
    


  /**
   * Reference to a field of type 'OrderStatusType'
   */
  export type EnumOrderStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatusType'>
    


  /**
   * Reference to a field of type 'OrderStatusType[]'
   */
  export type ListEnumOrderStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderStatusType[]'>
    


  /**
   * Reference to a field of type 'StatusType'
   */
  export type EnumStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusType'>
    


  /**
   * Reference to a field of type 'StatusType[]'
   */
  export type ListEnumStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StatusType[]'>
    


  /**
   * Reference to a field of type 'ApprovalModeType'
   */
  export type EnumApprovalModeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalModeType'>
    


  /**
   * Reference to a field of type 'ApprovalModeType[]'
   */
  export type ListEnumApprovalModeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalModeType[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


  /**
   * Reference to a field of type 'BonusType'
   */
  export type EnumBonusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BonusType'>
    


  /**
   * Reference to a field of type 'BonusType[]'
   */
  export type ListEnumBonusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BonusType[]'>
    


  /**
   * Reference to a field of type 'GiftType'
   */
  export type EnumGiftTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GiftType'>
    


  /**
   * Reference to a field of type 'GiftType[]'
   */
  export type ListEnumGiftTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GiftType[]'>
    


  /**
   * Reference to a field of type 'ShippingType'
   */
  export type EnumShippingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShippingType'>
    


  /**
   * Reference to a field of type 'ShippingType[]'
   */
  export type ListEnumShippingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ShippingType[]'>
    


  /**
   * Reference to a field of type 'TransactionReferenceType'
   */
  export type EnumTransactionReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionReferenceType'>
    


  /**
   * Reference to a field of type 'TransactionReferenceType[]'
   */
  export type ListEnumTransactionReferenceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionReferenceType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'CommissionCalculationType'
   */
  export type EnumCommissionCalculationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionCalculationType'>
    


  /**
   * Reference to a field of type 'CommissionCalculationType[]'
   */
  export type ListEnumCommissionCalculationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CommissionCalculationType[]'>
    


  /**
   * Reference to a field of type 'JobsStatusType'
   */
  export type EnumJobsStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobsStatusType'>
    


  /**
   * Reference to a field of type 'JobsStatusType[]'
   */
  export type ListEnumJobsStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobsStatusType[]'>
    


  /**
   * Reference to a field of type 'JobType'
   */
  export type EnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType'>
    


  /**
   * Reference to a field of type 'JobType[]'
   */
  export type ListEnumJobTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'JobType[]'>
    


  /**
   * Reference to a field of type 'ContactType'
   */
  export type EnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType'>
    


  /**
   * Reference to a field of type 'ContactType[]'
   */
  export type ListEnumContactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContactType[]'>
    


  /**
   * Reference to a field of type 'AffiliateStatusType'
   */
  export type EnumAffiliateStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateStatusType'>
    


  /**
   * Reference to a field of type 'AffiliateStatusType[]'
   */
  export type ListEnumAffiliateStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateStatusType[]'>
    


  /**
   * Reference to a field of type 'AffiliateSourceType'
   */
  export type EnumAffiliateSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateSourceType'>
    


  /**
   * Reference to a field of type 'AffiliateSourceType[]'
   */
  export type ListEnumAffiliateSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AffiliateSourceType[]'>
    


  /**
   * Reference to a field of type 'ProgramHistoryStatusType'
   */
  export type EnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgramHistoryStatusType'>
    


  /**
   * Reference to a field of type 'ProgramHistoryStatusType[]'
   */
  export type ListEnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProgramHistoryStatusType[]'>
    


  /**
   * Reference to a field of type 'DiscountStatusType'
   */
  export type EnumDiscountStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountStatusType'>
    


  /**
   * Reference to a field of type 'DiscountStatusType[]'
   */
  export type ListEnumDiscountStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountStatusType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'NotificationReceiverType'
   */
  export type EnumNotificationReceiverTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationReceiverType'>
    


  /**
   * Reference to a field of type 'NotificationReceiverType[]'
   */
  export type ListEnumNotificationReceiverTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationReceiverType[]'>
    


  /**
   * Reference to a field of type 'NotificationStatusType'
   */
  export type EnumNotificationStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatusType'>
    


  /**
   * Reference to a field of type 'NotificationStatusType[]'
   */
  export type ListEnumNotificationStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatusType[]'>
    


  /**
   * Reference to a field of type 'ActivityEntityType'
   */
  export type EnumActivityEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityEntityType'>
    


  /**
   * Reference to a field of type 'ActivityEntityType[]'
   */
  export type ListEnumActivityEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityEntityType[]'>
    


  /**
   * Reference to a field of type 'MessageHistoryStatusType'
   */
  export type EnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageHistoryStatusType'>
    


  /**
   * Reference to a field of type 'MessageHistoryStatusType[]'
   */
  export type ListEnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageHistoryStatusType[]'>
    


  /**
   * Reference to a field of type 'AppSubscriptionType'
   */
  export type EnumAppSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppSubscriptionType'>
    


  /**
   * Reference to a field of type 'AppSubscriptionType[]'
   */
  export type ListEnumAppSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppSubscriptionType[]'>
    


  /**
   * Reference to a field of type 'IntegrationType'
   */
  export type EnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType'>
    


  /**
   * Reference to a field of type 'IntegrationType[]'
   */
  export type ListEnumIntegrationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IntegrationType[]'>
    
  /**
   * Deep Input Types
   */


  export type StoresWhereInput = {
    AND?: StoresWhereInput | StoresWhereInput[]
    OR?: StoresWhereInput[]
    NOT?: StoresWhereInput | StoresWhereInput[]
    id?: IntFilter<"Stores"> | number
    store_id?: StringFilter<"Stores"> | string
    domain?: StringFilter<"Stores"> | string
    myshopify_domain?: StringFilter<"Stores"> | string
    email?: StringFilter<"Stores"> | string
    blacklisted?: BoolFilter<"Stores"> | boolean
    currency_code?: StringFilter<"Stores"> | string
    country_code?: StringFilter<"Stores"> | string
    language?: StringFilter<"Stores"> | string
    status?: EnumStoreStatusTypeFilter<"Stores"> | $Enums.StoreStatusType
    store_details?: JsonFilter<"Stores">
    remote_details?: JsonNullableFilter<"Stores">
    admin_access_token?: StringFilter<"Stores"> | string
    storefront_access_token?: StringFilter<"Stores"> | string
    created_at?: BigIntFilter<"Stores"> | bigint | number
    updated_at?: BigIntFilter<"Stores"> | bigint | number
    shopify_store_id?: BigIntNullableFilter<"Stores"> | bigint | number | null
    landing_page_id?: BigIntNullableFilter<"Stores"> | bigint | number | null
    portal_page_id?: BigIntNullableFilter<"Stores"> | bigint | number | null
    contact_email?: StringFilter<"Stores"> | string
    contact_name?: StringFilter<"Stores"> | string
    contact_phone?: StringNullableFilter<"Stores"> | string | null
    webhook_registration_check?: BoolNullableFilter<"Stores"> | boolean | null
    activity_log?: ActivityLogListRelationFilter
    affiliate_bonus?: AffiliateBonusListRelationFilter
    affiliate_discounts?: AffiliateDiscountsListRelationFilter
    affiliate_gifts?: AffiliateGiftsListRelationFilter
    affiliate_program_history?: AffiliateProgramHistoryListRelationFilter
    affiliate_programs?: AffiliateProgramsListRelationFilter
    affiliates?: AffiliatesListRelationFilter
    AppSubscription?: XOR<AppSubscriptionNullableRelationFilter, AppSubscriptionWhereInput> | null
    bonus?: BonusListRelationFilter
    commissions?: CommissionsListRelationFilter
    customer_discounts?: CustomerDiscountsListRelationFilter
    customers?: CustomersListRelationFilter
    gifts?: GiftsListRelationFilter
    Integrations?: IntegrationsListRelationFilter
    jobs?: JobsListRelationFilter
    messageHistory?: MessageHistoryListRelationFilter
    notifications?: NotificationsListRelationFilter
    orderItems?: OrderItemsListRelationFilter
    orders?: OrdersListRelationFilter
    PaymentGateway?: PaymentGatewayListRelationFilter
    payouts?: PayoutsListRelationFilter
    program_bonus?: ProgramBonusListRelationFilter
    programs?: ProgramsListRelationFilter
    settings?: XOR<SettingsNullableRelationFilter, SettingsWhereInput> | null
    tiers?: TiersListRelationFilter
    transactions?: TransactionsListRelationFilter
  }

  export type StoresOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    domain?: SortOrder
    myshopify_domain?: SortOrder
    email?: SortOrder
    blacklisted?: SortOrder
    currency_code?: SortOrder
    country_code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    store_details?: SortOrder
    remote_details?: SortOrderInput | SortOrder
    admin_access_token?: SortOrder
    storefront_access_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shopify_store_id?: SortOrderInput | SortOrder
    landing_page_id?: SortOrderInput | SortOrder
    portal_page_id?: SortOrderInput | SortOrder
    contact_email?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrderInput | SortOrder
    webhook_registration_check?: SortOrderInput | SortOrder
    activity_log?: ActivityLogOrderByRelationAggregateInput
    affiliate_bonus?: AffiliateBonusOrderByRelationAggregateInput
    affiliate_discounts?: AffiliateDiscountsOrderByRelationAggregateInput
    affiliate_gifts?: AffiliateGiftsOrderByRelationAggregateInput
    affiliate_program_history?: AffiliateProgramHistoryOrderByRelationAggregateInput
    affiliate_programs?: AffiliateProgramsOrderByRelationAggregateInput
    affiliates?: AffiliatesOrderByRelationAggregateInput
    AppSubscription?: AppSubscriptionOrderByWithRelationInput
    bonus?: BonusOrderByRelationAggregateInput
    commissions?: CommissionsOrderByRelationAggregateInput
    customer_discounts?: CustomerDiscountsOrderByRelationAggregateInput
    customers?: CustomersOrderByRelationAggregateInput
    gifts?: GiftsOrderByRelationAggregateInput
    Integrations?: IntegrationsOrderByRelationAggregateInput
    jobs?: JobsOrderByRelationAggregateInput
    messageHistory?: MessageHistoryOrderByRelationAggregateInput
    notifications?: NotificationsOrderByRelationAggregateInput
    orderItems?: OrderItemsOrderByRelationAggregateInput
    orders?: OrdersOrderByRelationAggregateInput
    PaymentGateway?: PaymentGatewayOrderByRelationAggregateInput
    payouts?: PayoutsOrderByRelationAggregateInput
    program_bonus?: ProgramBonusOrderByRelationAggregateInput
    programs?: ProgramsOrderByRelationAggregateInput
    settings?: SettingsOrderByWithRelationInput
    tiers?: TiersOrderByRelationAggregateInput
    transactions?: TransactionsOrderByRelationAggregateInput
  }

  export type StoresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id?: string
    myshopify_domain?: string
    AND?: StoresWhereInput | StoresWhereInput[]
    OR?: StoresWhereInput[]
    NOT?: StoresWhereInput | StoresWhereInput[]
    domain?: StringFilter<"Stores"> | string
    email?: StringFilter<"Stores"> | string
    blacklisted?: BoolFilter<"Stores"> | boolean
    currency_code?: StringFilter<"Stores"> | string
    country_code?: StringFilter<"Stores"> | string
    language?: StringFilter<"Stores"> | string
    status?: EnumStoreStatusTypeFilter<"Stores"> | $Enums.StoreStatusType
    store_details?: JsonFilter<"Stores">
    remote_details?: JsonNullableFilter<"Stores">
    admin_access_token?: StringFilter<"Stores"> | string
    storefront_access_token?: StringFilter<"Stores"> | string
    created_at?: BigIntFilter<"Stores"> | bigint | number
    updated_at?: BigIntFilter<"Stores"> | bigint | number
    shopify_store_id?: BigIntNullableFilter<"Stores"> | bigint | number | null
    landing_page_id?: BigIntNullableFilter<"Stores"> | bigint | number | null
    portal_page_id?: BigIntNullableFilter<"Stores"> | bigint | number | null
    contact_email?: StringFilter<"Stores"> | string
    contact_name?: StringFilter<"Stores"> | string
    contact_phone?: StringNullableFilter<"Stores"> | string | null
    webhook_registration_check?: BoolNullableFilter<"Stores"> | boolean | null
    activity_log?: ActivityLogListRelationFilter
    affiliate_bonus?: AffiliateBonusListRelationFilter
    affiliate_discounts?: AffiliateDiscountsListRelationFilter
    affiliate_gifts?: AffiliateGiftsListRelationFilter
    affiliate_program_history?: AffiliateProgramHistoryListRelationFilter
    affiliate_programs?: AffiliateProgramsListRelationFilter
    affiliates?: AffiliatesListRelationFilter
    AppSubscription?: XOR<AppSubscriptionNullableRelationFilter, AppSubscriptionWhereInput> | null
    bonus?: BonusListRelationFilter
    commissions?: CommissionsListRelationFilter
    customer_discounts?: CustomerDiscountsListRelationFilter
    customers?: CustomersListRelationFilter
    gifts?: GiftsListRelationFilter
    Integrations?: IntegrationsListRelationFilter
    jobs?: JobsListRelationFilter
    messageHistory?: MessageHistoryListRelationFilter
    notifications?: NotificationsListRelationFilter
    orderItems?: OrderItemsListRelationFilter
    orders?: OrdersListRelationFilter
    PaymentGateway?: PaymentGatewayListRelationFilter
    payouts?: PayoutsListRelationFilter
    program_bonus?: ProgramBonusListRelationFilter
    programs?: ProgramsListRelationFilter
    settings?: XOR<SettingsNullableRelationFilter, SettingsWhereInput> | null
    tiers?: TiersListRelationFilter
    transactions?: TransactionsListRelationFilter
  }, "id" | "store_id" | "myshopify_domain">

  export type StoresOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    domain?: SortOrder
    myshopify_domain?: SortOrder
    email?: SortOrder
    blacklisted?: SortOrder
    currency_code?: SortOrder
    country_code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    store_details?: SortOrder
    remote_details?: SortOrderInput | SortOrder
    admin_access_token?: SortOrder
    storefront_access_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shopify_store_id?: SortOrderInput | SortOrder
    landing_page_id?: SortOrderInput | SortOrder
    portal_page_id?: SortOrderInput | SortOrder
    contact_email?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrderInput | SortOrder
    webhook_registration_check?: SortOrderInput | SortOrder
    _count?: StoresCountOrderByAggregateInput
    _avg?: StoresAvgOrderByAggregateInput
    _max?: StoresMaxOrderByAggregateInput
    _min?: StoresMinOrderByAggregateInput
    _sum?: StoresSumOrderByAggregateInput
  }

  export type StoresScalarWhereWithAggregatesInput = {
    AND?: StoresScalarWhereWithAggregatesInput | StoresScalarWhereWithAggregatesInput[]
    OR?: StoresScalarWhereWithAggregatesInput[]
    NOT?: StoresScalarWhereWithAggregatesInput | StoresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stores"> | number
    store_id?: StringWithAggregatesFilter<"Stores"> | string
    domain?: StringWithAggregatesFilter<"Stores"> | string
    myshopify_domain?: StringWithAggregatesFilter<"Stores"> | string
    email?: StringWithAggregatesFilter<"Stores"> | string
    blacklisted?: BoolWithAggregatesFilter<"Stores"> | boolean
    currency_code?: StringWithAggregatesFilter<"Stores"> | string
    country_code?: StringWithAggregatesFilter<"Stores"> | string
    language?: StringWithAggregatesFilter<"Stores"> | string
    status?: EnumStoreStatusTypeWithAggregatesFilter<"Stores"> | $Enums.StoreStatusType
    store_details?: JsonWithAggregatesFilter<"Stores">
    remote_details?: JsonNullableWithAggregatesFilter<"Stores">
    admin_access_token?: StringWithAggregatesFilter<"Stores"> | string
    storefront_access_token?: StringWithAggregatesFilter<"Stores"> | string
    created_at?: BigIntWithAggregatesFilter<"Stores"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Stores"> | bigint | number
    shopify_store_id?: BigIntNullableWithAggregatesFilter<"Stores"> | bigint | number | null
    landing_page_id?: BigIntNullableWithAggregatesFilter<"Stores"> | bigint | number | null
    portal_page_id?: BigIntNullableWithAggregatesFilter<"Stores"> | bigint | number | null
    contact_email?: StringWithAggregatesFilter<"Stores"> | string
    contact_name?: StringWithAggregatesFilter<"Stores"> | string
    contact_phone?: StringNullableWithAggregatesFilter<"Stores"> | string | null
    webhook_registration_check?: BoolNullableWithAggregatesFilter<"Stores"> | boolean | null
  }

  export type MembersWhereInput = {
    AND?: MembersWhereInput | MembersWhereInput[]
    OR?: MembersWhereInput[]
    NOT?: MembersWhereInput | MembersWhereInput[]
    id?: IntFilter<"Members"> | number
    member_id?: StringFilter<"Members"> | string
    first_name?: StringFilter<"Members"> | string
    last_name?: StringFilter<"Members"> | string
    email?: StringFilter<"Members"> | string
    phone?: StringNullableFilter<"Members"> | string | null
    member_details?: JsonFilter<"Members">
    created_at?: BigIntFilter<"Members"> | bigint | number
    updated_at?: BigIntFilter<"Members"> | bigint | number
    affiliates?: AffiliatesListRelationFilter
  }

  export type MembersOrderByWithRelationInput = {
    id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    member_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByRelationAggregateInput
  }

  export type MembersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    member_id?: string
    email?: string
    phone?: string
    AND?: MembersWhereInput | MembersWhereInput[]
    OR?: MembersWhereInput[]
    NOT?: MembersWhereInput | MembersWhereInput[]
    first_name?: StringFilter<"Members"> | string
    last_name?: StringFilter<"Members"> | string
    member_details?: JsonFilter<"Members">
    created_at?: BigIntFilter<"Members"> | bigint | number
    updated_at?: BigIntFilter<"Members"> | bigint | number
    affiliates?: AffiliatesListRelationFilter
  }, "id" | "member_id" | "email" | "phone">

  export type MembersOrderByWithAggregationInput = {
    id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    member_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MembersCountOrderByAggregateInput
    _avg?: MembersAvgOrderByAggregateInput
    _max?: MembersMaxOrderByAggregateInput
    _min?: MembersMinOrderByAggregateInput
    _sum?: MembersSumOrderByAggregateInput
  }

  export type MembersScalarWhereWithAggregatesInput = {
    AND?: MembersScalarWhereWithAggregatesInput | MembersScalarWhereWithAggregatesInput[]
    OR?: MembersScalarWhereWithAggregatesInput[]
    NOT?: MembersScalarWhereWithAggregatesInput | MembersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Members"> | number
    member_id?: StringWithAggregatesFilter<"Members"> | string
    first_name?: StringWithAggregatesFilter<"Members"> | string
    last_name?: StringWithAggregatesFilter<"Members"> | string
    email?: StringWithAggregatesFilter<"Members"> | string
    phone?: StringNullableWithAggregatesFilter<"Members"> | string | null
    member_details?: JsonWithAggregatesFilter<"Members">
    created_at?: BigIntWithAggregatesFilter<"Members"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Members"> | bigint | number
  }

  export type ProgramsWhereInput = {
    AND?: ProgramsWhereInput | ProgramsWhereInput[]
    OR?: ProgramsWhereInput[]
    NOT?: ProgramsWhereInput | ProgramsWhereInput[]
    id?: IntFilter<"Programs"> | number
    store_id?: IntFilter<"Programs"> | number
    title?: StringFilter<"Programs"> | string
    description?: StringFilter<"Programs"> | string
    currency_code?: StringFilter<"Programs"> | string
    program_details?: JsonFilter<"Programs">
    status?: EnumProgramStatusTypeFilter<"Programs"> | $Enums.ProgramStatusType
    created_at?: BigIntFilter<"Programs"> | bigint | number
    updated_at?: BigIntFilter<"Programs"> | bigint | number
    affiliate_programs?: AffiliateProgramsListRelationFilter
    customer_discounts?: XOR<CustomerDiscountsNullableRelationFilter, CustomerDiscountsWhereInput> | null
    Orders?: OrdersListRelationFilter
    program_bonus?: ProgramBonusListRelationFilter
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    tiers?: TiersListRelationFilter
    activity_log?: ActivityLogListRelationFilter
  }

  export type ProgramsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currency_code?: SortOrder
    program_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate_programs?: AffiliateProgramsOrderByRelationAggregateInput
    customer_discounts?: CustomerDiscountsOrderByWithRelationInput
    Orders?: OrdersOrderByRelationAggregateInput
    program_bonus?: ProgramBonusOrderByRelationAggregateInput
    stores?: StoresOrderByWithRelationInput
    tiers?: TiersOrderByRelationAggregateInput
    activity_log?: ActivityLogOrderByRelationAggregateInput
  }

  export type ProgramsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id_title?: ProgramsStore_idTitleCompoundUniqueInput
    AND?: ProgramsWhereInput | ProgramsWhereInput[]
    OR?: ProgramsWhereInput[]
    NOT?: ProgramsWhereInput | ProgramsWhereInput[]
    store_id?: IntFilter<"Programs"> | number
    title?: StringFilter<"Programs"> | string
    description?: StringFilter<"Programs"> | string
    currency_code?: StringFilter<"Programs"> | string
    program_details?: JsonFilter<"Programs">
    status?: EnumProgramStatusTypeFilter<"Programs"> | $Enums.ProgramStatusType
    created_at?: BigIntFilter<"Programs"> | bigint | number
    updated_at?: BigIntFilter<"Programs"> | bigint | number
    affiliate_programs?: AffiliateProgramsListRelationFilter
    customer_discounts?: XOR<CustomerDiscountsNullableRelationFilter, CustomerDiscountsWhereInput> | null
    Orders?: OrdersListRelationFilter
    program_bonus?: ProgramBonusListRelationFilter
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    tiers?: TiersListRelationFilter
    activity_log?: ActivityLogListRelationFilter
  }, "id" | "store_id_title">

  export type ProgramsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currency_code?: SortOrder
    program_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProgramsCountOrderByAggregateInput
    _avg?: ProgramsAvgOrderByAggregateInput
    _max?: ProgramsMaxOrderByAggregateInput
    _min?: ProgramsMinOrderByAggregateInput
    _sum?: ProgramsSumOrderByAggregateInput
  }

  export type ProgramsScalarWhereWithAggregatesInput = {
    AND?: ProgramsScalarWhereWithAggregatesInput | ProgramsScalarWhereWithAggregatesInput[]
    OR?: ProgramsScalarWhereWithAggregatesInput[]
    NOT?: ProgramsScalarWhereWithAggregatesInput | ProgramsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Programs"> | number
    store_id?: IntWithAggregatesFilter<"Programs"> | number
    title?: StringWithAggregatesFilter<"Programs"> | string
    description?: StringWithAggregatesFilter<"Programs"> | string
    currency_code?: StringWithAggregatesFilter<"Programs"> | string
    program_details?: JsonWithAggregatesFilter<"Programs">
    status?: EnumProgramStatusTypeWithAggregatesFilter<"Programs"> | $Enums.ProgramStatusType
    created_at?: BigIntWithAggregatesFilter<"Programs"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Programs"> | bigint | number
  }

  export type TiersWhereInput = {
    AND?: TiersWhereInput | TiersWhereInput[]
    OR?: TiersWhereInput[]
    NOT?: TiersWhereInput | TiersWhereInput[]
    id?: IntFilter<"Tiers"> | number
    store_id?: IntFilter<"Tiers"> | number
    program_id?: IntFilter<"Tiers"> | number
    tier_type?: EnumTierTypeFilter<"Tiers"> | $Enums.TierType
    min_value?: FloatFilter<"Tiers"> | number
    max_value?: FloatNullableFilter<"Tiers"> | number | null
    commission_type?: EnumEarningTypeFilter<"Tiers"> | $Enums.EarningType
    commission_rate?: FloatFilter<"Tiers"> | number
    created_at?: BigIntFilter<"Tiers"> | bigint | number
    updated_at?: BigIntFilter<"Tiers"> | bigint | number
    programs?: XOR<ProgramsRelationFilter, ProgramsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type TiersOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    tier_type?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrderInput | SortOrder
    commission_type?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    programs?: ProgramsOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type TiersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TiersWhereInput | TiersWhereInput[]
    OR?: TiersWhereInput[]
    NOT?: TiersWhereInput | TiersWhereInput[]
    store_id?: IntFilter<"Tiers"> | number
    program_id?: IntFilter<"Tiers"> | number
    tier_type?: EnumTierTypeFilter<"Tiers"> | $Enums.TierType
    min_value?: FloatFilter<"Tiers"> | number
    max_value?: FloatNullableFilter<"Tiers"> | number | null
    commission_type?: EnumEarningTypeFilter<"Tiers"> | $Enums.EarningType
    commission_rate?: FloatFilter<"Tiers"> | number
    created_at?: BigIntFilter<"Tiers"> | bigint | number
    updated_at?: BigIntFilter<"Tiers"> | bigint | number
    programs?: XOR<ProgramsRelationFilter, ProgramsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id">

  export type TiersOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    tier_type?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrderInput | SortOrder
    commission_type?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TiersCountOrderByAggregateInput
    _avg?: TiersAvgOrderByAggregateInput
    _max?: TiersMaxOrderByAggregateInput
    _min?: TiersMinOrderByAggregateInput
    _sum?: TiersSumOrderByAggregateInput
  }

  export type TiersScalarWhereWithAggregatesInput = {
    AND?: TiersScalarWhereWithAggregatesInput | TiersScalarWhereWithAggregatesInput[]
    OR?: TiersScalarWhereWithAggregatesInput[]
    NOT?: TiersScalarWhereWithAggregatesInput | TiersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tiers"> | number
    store_id?: IntWithAggregatesFilter<"Tiers"> | number
    program_id?: IntWithAggregatesFilter<"Tiers"> | number
    tier_type?: EnumTierTypeWithAggregatesFilter<"Tiers"> | $Enums.TierType
    min_value?: FloatWithAggregatesFilter<"Tiers"> | number
    max_value?: FloatNullableWithAggregatesFilter<"Tiers"> | number | null
    commission_type?: EnumEarningTypeWithAggregatesFilter<"Tiers"> | $Enums.EarningType
    commission_rate?: FloatWithAggregatesFilter<"Tiers"> | number
    created_at?: BigIntWithAggregatesFilter<"Tiers"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Tiers"> | bigint | number
  }

  export type CustomerDiscountsWhereInput = {
    AND?: CustomerDiscountsWhereInput | CustomerDiscountsWhereInput[]
    OR?: CustomerDiscountsWhereInput[]
    NOT?: CustomerDiscountsWhereInput | CustomerDiscountsWhereInput[]
    id?: IntFilter<"CustomerDiscounts"> | number
    store_id?: IntFilter<"CustomerDiscounts"> | number
    program_id?: IntFilter<"CustomerDiscounts"> | number
    discount_rate?: FloatFilter<"CustomerDiscounts"> | number
    discount_options?: JsonFilter<"CustomerDiscounts">
    created_at?: BigIntFilter<"CustomerDiscounts"> | bigint | number
    updated_at?: BigIntFilter<"CustomerDiscounts"> | bigint | number
    discount_type?: EnumCustomerDiscountTypeFilter<"CustomerDiscounts"> | $Enums.CustomerDiscountType
    programs?: XOR<ProgramsRelationFilter, ProgramsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type CustomerDiscountsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    discount_rate?: SortOrder
    discount_options?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    discount_type?: SortOrder
    programs?: ProgramsOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type CustomerDiscountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    program_id?: number
    store_id_program_id?: CustomerDiscountsStore_idProgram_idCompoundUniqueInput
    AND?: CustomerDiscountsWhereInput | CustomerDiscountsWhereInput[]
    OR?: CustomerDiscountsWhereInput[]
    NOT?: CustomerDiscountsWhereInput | CustomerDiscountsWhereInput[]
    store_id?: IntFilter<"CustomerDiscounts"> | number
    discount_rate?: FloatFilter<"CustomerDiscounts"> | number
    discount_options?: JsonFilter<"CustomerDiscounts">
    created_at?: BigIntFilter<"CustomerDiscounts"> | bigint | number
    updated_at?: BigIntFilter<"CustomerDiscounts"> | bigint | number
    discount_type?: EnumCustomerDiscountTypeFilter<"CustomerDiscounts"> | $Enums.CustomerDiscountType
    programs?: XOR<ProgramsRelationFilter, ProgramsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "program_id" | "store_id_program_id">

  export type CustomerDiscountsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    discount_rate?: SortOrder
    discount_options?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    discount_type?: SortOrder
    _count?: CustomerDiscountsCountOrderByAggregateInput
    _avg?: CustomerDiscountsAvgOrderByAggregateInput
    _max?: CustomerDiscountsMaxOrderByAggregateInput
    _min?: CustomerDiscountsMinOrderByAggregateInput
    _sum?: CustomerDiscountsSumOrderByAggregateInput
  }

  export type CustomerDiscountsScalarWhereWithAggregatesInput = {
    AND?: CustomerDiscountsScalarWhereWithAggregatesInput | CustomerDiscountsScalarWhereWithAggregatesInput[]
    OR?: CustomerDiscountsScalarWhereWithAggregatesInput[]
    NOT?: CustomerDiscountsScalarWhereWithAggregatesInput | CustomerDiscountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerDiscounts"> | number
    store_id?: IntWithAggregatesFilter<"CustomerDiscounts"> | number
    program_id?: IntWithAggregatesFilter<"CustomerDiscounts"> | number
    discount_rate?: FloatWithAggregatesFilter<"CustomerDiscounts"> | number
    discount_options?: JsonWithAggregatesFilter<"CustomerDiscounts">
    created_at?: BigIntWithAggregatesFilter<"CustomerDiscounts"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"CustomerDiscounts"> | bigint | number
    discount_type?: EnumCustomerDiscountTypeWithAggregatesFilter<"CustomerDiscounts"> | $Enums.CustomerDiscountType
  }

  export type OrdersWhereInput = {
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    id?: IntFilter<"Orders"> | number
    store_id?: IntFilter<"Orders"> | number
    affiliate_id?: IntFilter<"Orders"> | number
    customer_id?: IntFilter<"Orders"> | number
    order_id?: BigIntFilter<"Orders"> | bigint | number
    shopify_order_number?: IntFilter<"Orders"> | number
    shop_order_currency_code?: StringFilter<"Orders"> | string
    shop_order_amount?: FloatFilter<"Orders"> | number
    customer_order_currency_code?: StringFilter<"Orders"> | string
    customer_order_amount?: FloatFilter<"Orders"> | number
    financial_status?: StringFilter<"Orders"> | string
    order_details?: JsonFilter<"Orders">
    attribute_type?: EnumOrderAttributeTypeFilter<"Orders"> | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFilter<"Orders"> | $Enums.OrderStatusType
    created_at?: BigIntFilter<"Orders"> | bigint | number
    updated_at?: BigIntFilter<"Orders"> | bigint | number
    program_id?: IntNullableFilter<"Orders"> | number | null
    commissions?: XOR<CommissionsNullableRelationFilter, CommissionsWhereInput> | null
    order_items?: OrderItemsListRelationFilter
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    programs?: XOR<ProgramsNullableRelationFilter, ProgramsWhereInput> | null
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    activity_log?: ActivityLogListRelationFilter
  }

  export type OrdersOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    shopify_order_number?: SortOrder
    shop_order_currency_code?: SortOrder
    shop_order_amount?: SortOrder
    customer_order_currency_code?: SortOrder
    customer_order_amount?: SortOrder
    financial_status?: SortOrder
    order_details?: SortOrder
    attribute_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    program_id?: SortOrderInput | SortOrder
    commissions?: CommissionsOrderByWithRelationInput
    order_items?: OrderItemsOrderByRelationAggregateInput
    affiliates?: AffiliatesOrderByWithRelationInput
    customers?: CustomersOrderByWithRelationInput
    programs?: ProgramsOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
    activity_log?: ActivityLogOrderByRelationAggregateInput
  }

  export type OrdersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    order_id?: bigint | number
    AND?: OrdersWhereInput | OrdersWhereInput[]
    OR?: OrdersWhereInput[]
    NOT?: OrdersWhereInput | OrdersWhereInput[]
    store_id?: IntFilter<"Orders"> | number
    affiliate_id?: IntFilter<"Orders"> | number
    customer_id?: IntFilter<"Orders"> | number
    shopify_order_number?: IntFilter<"Orders"> | number
    shop_order_currency_code?: StringFilter<"Orders"> | string
    shop_order_amount?: FloatFilter<"Orders"> | number
    customer_order_currency_code?: StringFilter<"Orders"> | string
    customer_order_amount?: FloatFilter<"Orders"> | number
    financial_status?: StringFilter<"Orders"> | string
    order_details?: JsonFilter<"Orders">
    attribute_type?: EnumOrderAttributeTypeFilter<"Orders"> | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFilter<"Orders"> | $Enums.OrderStatusType
    created_at?: BigIntFilter<"Orders"> | bigint | number
    updated_at?: BigIntFilter<"Orders"> | bigint | number
    program_id?: IntNullableFilter<"Orders"> | number | null
    commissions?: XOR<CommissionsNullableRelationFilter, CommissionsWhereInput> | null
    order_items?: OrderItemsListRelationFilter
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    programs?: XOR<ProgramsNullableRelationFilter, ProgramsWhereInput> | null
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    activity_log?: ActivityLogListRelationFilter
  }, "id" | "order_id">

  export type OrdersOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    shopify_order_number?: SortOrder
    shop_order_currency_code?: SortOrder
    shop_order_amount?: SortOrder
    customer_order_currency_code?: SortOrder
    customer_order_amount?: SortOrder
    financial_status?: SortOrder
    order_details?: SortOrder
    attribute_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    program_id?: SortOrderInput | SortOrder
    _count?: OrdersCountOrderByAggregateInput
    _avg?: OrdersAvgOrderByAggregateInput
    _max?: OrdersMaxOrderByAggregateInput
    _min?: OrdersMinOrderByAggregateInput
    _sum?: OrdersSumOrderByAggregateInput
  }

  export type OrdersScalarWhereWithAggregatesInput = {
    AND?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    OR?: OrdersScalarWhereWithAggregatesInput[]
    NOT?: OrdersScalarWhereWithAggregatesInput | OrdersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Orders"> | number
    store_id?: IntWithAggregatesFilter<"Orders"> | number
    affiliate_id?: IntWithAggregatesFilter<"Orders"> | number
    customer_id?: IntWithAggregatesFilter<"Orders"> | number
    order_id?: BigIntWithAggregatesFilter<"Orders"> | bigint | number
    shopify_order_number?: IntWithAggregatesFilter<"Orders"> | number
    shop_order_currency_code?: StringWithAggregatesFilter<"Orders"> | string
    shop_order_amount?: FloatWithAggregatesFilter<"Orders"> | number
    customer_order_currency_code?: StringWithAggregatesFilter<"Orders"> | string
    customer_order_amount?: FloatWithAggregatesFilter<"Orders"> | number
    financial_status?: StringWithAggregatesFilter<"Orders"> | string
    order_details?: JsonWithAggregatesFilter<"Orders">
    attribute_type?: EnumOrderAttributeTypeWithAggregatesFilter<"Orders"> | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeWithAggregatesFilter<"Orders"> | $Enums.OrderStatusType
    created_at?: BigIntWithAggregatesFilter<"Orders"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Orders"> | bigint | number
    program_id?: IntNullableWithAggregatesFilter<"Orders"> | number | null
  }

  export type OrderItemsWhereInput = {
    AND?: OrderItemsWhereInput | OrderItemsWhereInput[]
    OR?: OrderItemsWhereInput[]
    NOT?: OrderItemsWhereInput | OrderItemsWhereInput[]
    id?: IntFilter<"OrderItems"> | number
    store_id?: IntFilter<"OrderItems"> | number
    affiliate_id?: IntFilter<"OrderItems"> | number
    customer_id?: IntFilter<"OrderItems"> | number
    order_id?: IntFilter<"OrderItems"> | number
    item_id?: BigIntFilter<"OrderItems"> | bigint | number
    product_id?: BigIntFilter<"OrderItems"> | bigint | number
    variant_id?: BigIntFilter<"OrderItems"> | bigint | number
    product_title?: StringFilter<"OrderItems"> | string
    variant_title?: StringFilter<"OrderItems"> | string
    quantity?: IntFilter<"OrderItems"> | number
    shop_item_currency_code?: StringFilter<"OrderItems"> | string
    shop_item_amount?: FloatFilter<"OrderItems"> | number
    customer_item_currency_code?: StringFilter<"OrderItems"> | string
    customer_item_amount?: FloatFilter<"OrderItems"> | number
    item_details?: JsonFilter<"OrderItems">
    created_at?: BigIntFilter<"OrderItems"> | bigint | number
    updated_at?: BigIntFilter<"OrderItems"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    orders?: XOR<OrdersRelationFilter, OrdersWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type OrderItemsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    item_id?: SortOrder
    product_id?: SortOrder
    variant_id?: SortOrder
    product_title?: SortOrder
    variant_title?: SortOrder
    quantity?: SortOrder
    shop_item_currency_code?: SortOrder
    shop_item_amount?: SortOrder
    customer_item_currency_code?: SortOrder
    customer_item_amount?: SortOrder
    item_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    customers?: CustomersOrderByWithRelationInput
    orders?: OrdersOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type OrderItemsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    item_id?: bigint | number
    AND?: OrderItemsWhereInput | OrderItemsWhereInput[]
    OR?: OrderItemsWhereInput[]
    NOT?: OrderItemsWhereInput | OrderItemsWhereInput[]
    store_id?: IntFilter<"OrderItems"> | number
    affiliate_id?: IntFilter<"OrderItems"> | number
    customer_id?: IntFilter<"OrderItems"> | number
    order_id?: IntFilter<"OrderItems"> | number
    product_id?: BigIntFilter<"OrderItems"> | bigint | number
    variant_id?: BigIntFilter<"OrderItems"> | bigint | number
    product_title?: StringFilter<"OrderItems"> | string
    variant_title?: StringFilter<"OrderItems"> | string
    quantity?: IntFilter<"OrderItems"> | number
    shop_item_currency_code?: StringFilter<"OrderItems"> | string
    shop_item_amount?: FloatFilter<"OrderItems"> | number
    customer_item_currency_code?: StringFilter<"OrderItems"> | string
    customer_item_amount?: FloatFilter<"OrderItems"> | number
    item_details?: JsonFilter<"OrderItems">
    created_at?: BigIntFilter<"OrderItems"> | bigint | number
    updated_at?: BigIntFilter<"OrderItems"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    customers?: XOR<CustomersRelationFilter, CustomersWhereInput>
    orders?: XOR<OrdersRelationFilter, OrdersWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "item_id">

  export type OrderItemsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    item_id?: SortOrder
    product_id?: SortOrder
    variant_id?: SortOrder
    product_title?: SortOrder
    variant_title?: SortOrder
    quantity?: SortOrder
    shop_item_currency_code?: SortOrder
    shop_item_amount?: SortOrder
    customer_item_currency_code?: SortOrder
    customer_item_amount?: SortOrder
    item_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: OrderItemsCountOrderByAggregateInput
    _avg?: OrderItemsAvgOrderByAggregateInput
    _max?: OrderItemsMaxOrderByAggregateInput
    _min?: OrderItemsMinOrderByAggregateInput
    _sum?: OrderItemsSumOrderByAggregateInput
  }

  export type OrderItemsScalarWhereWithAggregatesInput = {
    AND?: OrderItemsScalarWhereWithAggregatesInput | OrderItemsScalarWhereWithAggregatesInput[]
    OR?: OrderItemsScalarWhereWithAggregatesInput[]
    NOT?: OrderItemsScalarWhereWithAggregatesInput | OrderItemsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItems"> | number
    store_id?: IntWithAggregatesFilter<"OrderItems"> | number
    affiliate_id?: IntWithAggregatesFilter<"OrderItems"> | number
    customer_id?: IntWithAggregatesFilter<"OrderItems"> | number
    order_id?: IntWithAggregatesFilter<"OrderItems"> | number
    item_id?: BigIntWithAggregatesFilter<"OrderItems"> | bigint | number
    product_id?: BigIntWithAggregatesFilter<"OrderItems"> | bigint | number
    variant_id?: BigIntWithAggregatesFilter<"OrderItems"> | bigint | number
    product_title?: StringWithAggregatesFilter<"OrderItems"> | string
    variant_title?: StringWithAggregatesFilter<"OrderItems"> | string
    quantity?: IntWithAggregatesFilter<"OrderItems"> | number
    shop_item_currency_code?: StringWithAggregatesFilter<"OrderItems"> | string
    shop_item_amount?: FloatWithAggregatesFilter<"OrderItems"> | number
    customer_item_currency_code?: StringWithAggregatesFilter<"OrderItems"> | string
    customer_item_amount?: FloatWithAggregatesFilter<"OrderItems"> | number
    item_details?: JsonWithAggregatesFilter<"OrderItems">
    created_at?: BigIntWithAggregatesFilter<"OrderItems"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"OrderItems"> | bigint | number
  }

  export type CommissionsWhereInput = {
    AND?: CommissionsWhereInput | CommissionsWhereInput[]
    OR?: CommissionsWhereInput[]
    NOT?: CommissionsWhereInput | CommissionsWhereInput[]
    id?: IntFilter<"Commissions"> | number
    store_id?: IntFilter<"Commissions"> | number
    affiliate_id?: IntFilter<"Commissions"> | number
    order_id?: IntFilter<"Commissions"> | number
    currency_code?: StringFilter<"Commissions"> | string
    amount?: FloatFilter<"Commissions"> | number
    status?: EnumStatusTypeFilter<"Commissions"> | $Enums.StatusType
    approval_mode?: EnumApprovalModeTypeNullableFilter<"Commissions"> | $Enums.ApprovalModeType | null
    review_on?: BigIntNullableFilter<"Commissions"> | bigint | number | null
    created_at?: BigIntFilter<"Commissions"> | bigint | number
    updated_at?: BigIntFilter<"Commissions"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    orders?: XOR<OrdersRelationFilter, OrdersWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type CommissionsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    order_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    approval_mode?: SortOrderInput | SortOrder
    review_on?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    orders?: OrdersOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type CommissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    order_id?: number
    AND?: CommissionsWhereInput | CommissionsWhereInput[]
    OR?: CommissionsWhereInput[]
    NOT?: CommissionsWhereInput | CommissionsWhereInput[]
    store_id?: IntFilter<"Commissions"> | number
    affiliate_id?: IntFilter<"Commissions"> | number
    currency_code?: StringFilter<"Commissions"> | string
    amount?: FloatFilter<"Commissions"> | number
    status?: EnumStatusTypeFilter<"Commissions"> | $Enums.StatusType
    approval_mode?: EnumApprovalModeTypeNullableFilter<"Commissions"> | $Enums.ApprovalModeType | null
    review_on?: BigIntNullableFilter<"Commissions"> | bigint | number | null
    created_at?: BigIntFilter<"Commissions"> | bigint | number
    updated_at?: BigIntFilter<"Commissions"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    orders?: XOR<OrdersRelationFilter, OrdersWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "order_id">

  export type CommissionsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    order_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    approval_mode?: SortOrderInput | SortOrder
    review_on?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CommissionsCountOrderByAggregateInput
    _avg?: CommissionsAvgOrderByAggregateInput
    _max?: CommissionsMaxOrderByAggregateInput
    _min?: CommissionsMinOrderByAggregateInput
    _sum?: CommissionsSumOrderByAggregateInput
  }

  export type CommissionsScalarWhereWithAggregatesInput = {
    AND?: CommissionsScalarWhereWithAggregatesInput | CommissionsScalarWhereWithAggregatesInput[]
    OR?: CommissionsScalarWhereWithAggregatesInput[]
    NOT?: CommissionsScalarWhereWithAggregatesInput | CommissionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Commissions"> | number
    store_id?: IntWithAggregatesFilter<"Commissions"> | number
    affiliate_id?: IntWithAggregatesFilter<"Commissions"> | number
    order_id?: IntWithAggregatesFilter<"Commissions"> | number
    currency_code?: StringWithAggregatesFilter<"Commissions"> | string
    amount?: FloatWithAggregatesFilter<"Commissions"> | number
    status?: EnumStatusTypeWithAggregatesFilter<"Commissions"> | $Enums.StatusType
    approval_mode?: EnumApprovalModeTypeNullableWithAggregatesFilter<"Commissions"> | $Enums.ApprovalModeType | null
    review_on?: BigIntNullableWithAggregatesFilter<"Commissions"> | bigint | number | null
    created_at?: BigIntWithAggregatesFilter<"Commissions"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Commissions"> | bigint | number
  }

  export type PayoutsWhereInput = {
    AND?: PayoutsWhereInput | PayoutsWhereInput[]
    OR?: PayoutsWhereInput[]
    NOT?: PayoutsWhereInput | PayoutsWhereInput[]
    id?: IntFilter<"Payouts"> | number
    store_id?: IntFilter<"Payouts"> | number
    affiliate_id?: IntFilter<"Payouts"> | number
    transaction_id?: StringFilter<"Payouts"> | string
    currency_code?: StringFilter<"Payouts"> | string
    amount?: FloatFilter<"Payouts"> | number
    notes?: StringFilter<"Payouts"> | string
    payment_method?: EnumPaymentTypeFilter<"Payouts"> | $Enums.PaymentType
    payment_details?: JsonFilter<"Payouts">
    status?: EnumStatusTypeFilter<"Payouts"> | $Enums.StatusType
    created_at?: BigIntFilter<"Payouts"> | bigint | number
    updated_at?: BigIntFilter<"Payouts"> | bigint | number
    user_id?: BigIntNullableFilter<"Payouts"> | bigint | number | null
    job_id?: IntFilter<"Payouts"> | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    jobs?: XOR<JobsRelationFilter, JobsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    activity_log?: ActivityLogListRelationFilter
  }

  export type PayoutsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    transaction_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    payment_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    job_id?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    jobs?: JobsOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
    activity_log?: ActivityLogOrderByRelationAggregateInput
  }

  export type PayoutsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    transaction_id?: string
    job_id?: number
    AND?: PayoutsWhereInput | PayoutsWhereInput[]
    OR?: PayoutsWhereInput[]
    NOT?: PayoutsWhereInput | PayoutsWhereInput[]
    store_id?: IntFilter<"Payouts"> | number
    affiliate_id?: IntFilter<"Payouts"> | number
    currency_code?: StringFilter<"Payouts"> | string
    amount?: FloatFilter<"Payouts"> | number
    notes?: StringFilter<"Payouts"> | string
    payment_method?: EnumPaymentTypeFilter<"Payouts"> | $Enums.PaymentType
    payment_details?: JsonFilter<"Payouts">
    status?: EnumStatusTypeFilter<"Payouts"> | $Enums.StatusType
    created_at?: BigIntFilter<"Payouts"> | bigint | number
    updated_at?: BigIntFilter<"Payouts"> | bigint | number
    user_id?: BigIntNullableFilter<"Payouts"> | bigint | number | null
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    jobs?: XOR<JobsRelationFilter, JobsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    activity_log?: ActivityLogListRelationFilter
  }, "id" | "transaction_id" | "job_id">

  export type PayoutsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    transaction_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    payment_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    job_id?: SortOrder
    _count?: PayoutsCountOrderByAggregateInput
    _avg?: PayoutsAvgOrderByAggregateInput
    _max?: PayoutsMaxOrderByAggregateInput
    _min?: PayoutsMinOrderByAggregateInput
    _sum?: PayoutsSumOrderByAggregateInput
  }

  export type PayoutsScalarWhereWithAggregatesInput = {
    AND?: PayoutsScalarWhereWithAggregatesInput | PayoutsScalarWhereWithAggregatesInput[]
    OR?: PayoutsScalarWhereWithAggregatesInput[]
    NOT?: PayoutsScalarWhereWithAggregatesInput | PayoutsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payouts"> | number
    store_id?: IntWithAggregatesFilter<"Payouts"> | number
    affiliate_id?: IntWithAggregatesFilter<"Payouts"> | number
    transaction_id?: StringWithAggregatesFilter<"Payouts"> | string
    currency_code?: StringWithAggregatesFilter<"Payouts"> | string
    amount?: FloatWithAggregatesFilter<"Payouts"> | number
    notes?: StringWithAggregatesFilter<"Payouts"> | string
    payment_method?: EnumPaymentTypeWithAggregatesFilter<"Payouts"> | $Enums.PaymentType
    payment_details?: JsonWithAggregatesFilter<"Payouts">
    status?: EnumStatusTypeWithAggregatesFilter<"Payouts"> | $Enums.StatusType
    created_at?: BigIntWithAggregatesFilter<"Payouts"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Payouts"> | bigint | number
    user_id?: BigIntNullableWithAggregatesFilter<"Payouts"> | bigint | number | null
    job_id?: IntWithAggregatesFilter<"Payouts"> | number
  }

  export type BonusWhereInput = {
    AND?: BonusWhereInput | BonusWhereInput[]
    OR?: BonusWhereInput[]
    NOT?: BonusWhereInput | BonusWhereInput[]
    id?: IntFilter<"Bonus"> | number
    store_id?: IntFilter<"Bonus"> | number
    title?: StringFilter<"Bonus"> | string
    description?: StringFilter<"Bonus"> | string
    bonus_associate?: EnumBonusTypeFilter<"Bonus"> | $Enums.BonusType
    target_type?: EnumTierTypeFilter<"Bonus"> | $Enums.TierType
    target_goal?: FloatFilter<"Bonus"> | number
    bonus_type?: EnumEarningTypeFilter<"Bonus"> | $Enums.EarningType
    bonus_rate?: FloatFilter<"Bonus"> | number
    status?: EnumStatusTypeFilter<"Bonus"> | $Enums.StatusType
    begin_datetime?: BigIntFilter<"Bonus"> | bigint | number
    expire_datetime?: BigIntFilter<"Bonus"> | bigint | number
    created_at?: BigIntFilter<"Bonus"> | bigint | number
    updated_at?: BigIntFilter<"Bonus"> | bigint | number
    affiliate_bonus?: AffiliateBonusListRelationFilter
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    program_bonus?: ProgramBonusListRelationFilter
  }

  export type BonusOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    bonus_associate?: SortOrder
    target_type?: SortOrder
    target_goal?: SortOrder
    bonus_type?: SortOrder
    bonus_rate?: SortOrder
    status?: SortOrder
    begin_datetime?: SortOrder
    expire_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate_bonus?: AffiliateBonusOrderByRelationAggregateInput
    stores?: StoresOrderByWithRelationInput
    program_bonus?: ProgramBonusOrderByRelationAggregateInput
  }

  export type BonusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BonusWhereInput | BonusWhereInput[]
    OR?: BonusWhereInput[]
    NOT?: BonusWhereInput | BonusWhereInput[]
    store_id?: IntFilter<"Bonus"> | number
    title?: StringFilter<"Bonus"> | string
    description?: StringFilter<"Bonus"> | string
    bonus_associate?: EnumBonusTypeFilter<"Bonus"> | $Enums.BonusType
    target_type?: EnumTierTypeFilter<"Bonus"> | $Enums.TierType
    target_goal?: FloatFilter<"Bonus"> | number
    bonus_type?: EnumEarningTypeFilter<"Bonus"> | $Enums.EarningType
    bonus_rate?: FloatFilter<"Bonus"> | number
    status?: EnumStatusTypeFilter<"Bonus"> | $Enums.StatusType
    begin_datetime?: BigIntFilter<"Bonus"> | bigint | number
    expire_datetime?: BigIntFilter<"Bonus"> | bigint | number
    created_at?: BigIntFilter<"Bonus"> | bigint | number
    updated_at?: BigIntFilter<"Bonus"> | bigint | number
    affiliate_bonus?: AffiliateBonusListRelationFilter
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    program_bonus?: ProgramBonusListRelationFilter
  }, "id">

  export type BonusOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    bonus_associate?: SortOrder
    target_type?: SortOrder
    target_goal?: SortOrder
    bonus_type?: SortOrder
    bonus_rate?: SortOrder
    status?: SortOrder
    begin_datetime?: SortOrder
    expire_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BonusCountOrderByAggregateInput
    _avg?: BonusAvgOrderByAggregateInput
    _max?: BonusMaxOrderByAggregateInput
    _min?: BonusMinOrderByAggregateInput
    _sum?: BonusSumOrderByAggregateInput
  }

  export type BonusScalarWhereWithAggregatesInput = {
    AND?: BonusScalarWhereWithAggregatesInput | BonusScalarWhereWithAggregatesInput[]
    OR?: BonusScalarWhereWithAggregatesInput[]
    NOT?: BonusScalarWhereWithAggregatesInput | BonusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bonus"> | number
    store_id?: IntWithAggregatesFilter<"Bonus"> | number
    title?: StringWithAggregatesFilter<"Bonus"> | string
    description?: StringWithAggregatesFilter<"Bonus"> | string
    bonus_associate?: EnumBonusTypeWithAggregatesFilter<"Bonus"> | $Enums.BonusType
    target_type?: EnumTierTypeWithAggregatesFilter<"Bonus"> | $Enums.TierType
    target_goal?: FloatWithAggregatesFilter<"Bonus"> | number
    bonus_type?: EnumEarningTypeWithAggregatesFilter<"Bonus"> | $Enums.EarningType
    bonus_rate?: FloatWithAggregatesFilter<"Bonus"> | number
    status?: EnumStatusTypeWithAggregatesFilter<"Bonus"> | $Enums.StatusType
    begin_datetime?: BigIntWithAggregatesFilter<"Bonus"> | bigint | number
    expire_datetime?: BigIntWithAggregatesFilter<"Bonus"> | bigint | number
    created_at?: BigIntWithAggregatesFilter<"Bonus"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Bonus"> | bigint | number
  }

  export type GiftsWhereInput = {
    AND?: GiftsWhereInput | GiftsWhereInput[]
    OR?: GiftsWhereInput[]
    NOT?: GiftsWhereInput | GiftsWhereInput[]
    id?: IntFilter<"Gifts"> | number
    store_id?: IntFilter<"Gifts"> | number
    title?: StringFilter<"Gifts"> | string
    description?: StringFilter<"Gifts"> | string
    products?: JsonFilter<"Gifts">
    gift_type?: EnumGiftTypeFilter<"Gifts"> | $Enums.GiftType
    status?: EnumStatusTypeFilter<"Gifts"> | $Enums.StatusType
    shipping_method?: EnumShippingTypeFilter<"Gifts"> | $Enums.ShippingType
    created_at?: BigIntFilter<"Gifts"> | bigint | number
    updated_at?: BigIntFilter<"Gifts"> | bigint | number
    affiliate_gifts?: AffiliateGiftsListRelationFilter
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type GiftsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    products?: SortOrder
    gift_type?: SortOrder
    status?: SortOrder
    shipping_method?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliate_gifts?: AffiliateGiftsOrderByRelationAggregateInput
    stores?: StoresOrderByWithRelationInput
  }

  export type GiftsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: GiftsWhereInput | GiftsWhereInput[]
    OR?: GiftsWhereInput[]
    NOT?: GiftsWhereInput | GiftsWhereInput[]
    store_id?: IntFilter<"Gifts"> | number
    title?: StringFilter<"Gifts"> | string
    description?: StringFilter<"Gifts"> | string
    products?: JsonFilter<"Gifts">
    gift_type?: EnumGiftTypeFilter<"Gifts"> | $Enums.GiftType
    status?: EnumStatusTypeFilter<"Gifts"> | $Enums.StatusType
    shipping_method?: EnumShippingTypeFilter<"Gifts"> | $Enums.ShippingType
    created_at?: BigIntFilter<"Gifts"> | bigint | number
    updated_at?: BigIntFilter<"Gifts"> | bigint | number
    affiliate_gifts?: AffiliateGiftsListRelationFilter
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id">

  export type GiftsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    products?: SortOrder
    gift_type?: SortOrder
    status?: SortOrder
    shipping_method?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: GiftsCountOrderByAggregateInput
    _avg?: GiftsAvgOrderByAggregateInput
    _max?: GiftsMaxOrderByAggregateInput
    _min?: GiftsMinOrderByAggregateInput
    _sum?: GiftsSumOrderByAggregateInput
  }

  export type GiftsScalarWhereWithAggregatesInput = {
    AND?: GiftsScalarWhereWithAggregatesInput | GiftsScalarWhereWithAggregatesInput[]
    OR?: GiftsScalarWhereWithAggregatesInput[]
    NOT?: GiftsScalarWhereWithAggregatesInput | GiftsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Gifts"> | number
    store_id?: IntWithAggregatesFilter<"Gifts"> | number
    title?: StringWithAggregatesFilter<"Gifts"> | string
    description?: StringWithAggregatesFilter<"Gifts"> | string
    products?: JsonWithAggregatesFilter<"Gifts">
    gift_type?: EnumGiftTypeWithAggregatesFilter<"Gifts"> | $Enums.GiftType
    status?: EnumStatusTypeWithAggregatesFilter<"Gifts"> | $Enums.StatusType
    shipping_method?: EnumShippingTypeWithAggregatesFilter<"Gifts"> | $Enums.ShippingType
    created_at?: BigIntWithAggregatesFilter<"Gifts"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Gifts"> | bigint | number
  }

  export type TransactionsWhereInput = {
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    id?: IntFilter<"Transactions"> | number
    store_id?: IntFilter<"Transactions"> | number
    affiliate_id?: IntFilter<"Transactions"> | number
    reference_type?: EnumTransactionReferenceTypeFilter<"Transactions"> | $Enums.TransactionReferenceType
    reference_id?: StringFilter<"Transactions"> | string
    currency_code?: StringFilter<"Transactions"> | string
    type?: EnumTransactionTypeFilter<"Transactions"> | $Enums.TransactionType
    is_reverted?: BoolFilter<"Transactions"> | boolean
    amount?: FloatFilter<"Transactions"> | number
    created_at?: BigIntFilter<"Transactions"> | bigint | number
    updated_at?: BigIntFilter<"Transactions"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type TransactionsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    reference_type?: SortOrder
    reference_id?: SortOrder
    currency_code?: SortOrder
    type?: SortOrder
    is_reverted?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type TransactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TransactionsWhereInput | TransactionsWhereInput[]
    OR?: TransactionsWhereInput[]
    NOT?: TransactionsWhereInput | TransactionsWhereInput[]
    store_id?: IntFilter<"Transactions"> | number
    affiliate_id?: IntFilter<"Transactions"> | number
    reference_type?: EnumTransactionReferenceTypeFilter<"Transactions"> | $Enums.TransactionReferenceType
    reference_id?: StringFilter<"Transactions"> | string
    currency_code?: StringFilter<"Transactions"> | string
    type?: EnumTransactionTypeFilter<"Transactions"> | $Enums.TransactionType
    is_reverted?: BoolFilter<"Transactions"> | boolean
    amount?: FloatFilter<"Transactions"> | number
    created_at?: BigIntFilter<"Transactions"> | bigint | number
    updated_at?: BigIntFilter<"Transactions"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id">

  export type TransactionsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    reference_type?: SortOrder
    reference_id?: SortOrder
    currency_code?: SortOrder
    type?: SortOrder
    is_reverted?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TransactionsCountOrderByAggregateInput
    _avg?: TransactionsAvgOrderByAggregateInput
    _max?: TransactionsMaxOrderByAggregateInput
    _min?: TransactionsMinOrderByAggregateInput
    _sum?: TransactionsSumOrderByAggregateInput
  }

  export type TransactionsScalarWhereWithAggregatesInput = {
    AND?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    OR?: TransactionsScalarWhereWithAggregatesInput[]
    NOT?: TransactionsScalarWhereWithAggregatesInput | TransactionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Transactions"> | number
    store_id?: IntWithAggregatesFilter<"Transactions"> | number
    affiliate_id?: IntWithAggregatesFilter<"Transactions"> | number
    reference_type?: EnumTransactionReferenceTypeWithAggregatesFilter<"Transactions"> | $Enums.TransactionReferenceType
    reference_id?: StringWithAggregatesFilter<"Transactions"> | string
    currency_code?: StringWithAggregatesFilter<"Transactions"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transactions"> | $Enums.TransactionType
    is_reverted?: BoolWithAggregatesFilter<"Transactions"> | boolean
    amount?: FloatWithAggregatesFilter<"Transactions"> | number
    created_at?: BigIntWithAggregatesFilter<"Transactions"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Transactions"> | bigint | number
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: IntFilter<"Settings"> | number
    store_id?: IntFilter<"Settings"> | number
    commission_delay?: IntFilter<"Settings"> | number
    commission_approval_mode?: EnumApprovalModeTypeFilter<"Settings"> | $Enums.ApprovalModeType
    commission_calculation?: EnumCommissionCalculationTypeFilter<"Settings"> | $Enums.CommissionCalculationType
    details?: JsonNullableFilter<"Settings">
    min_threshold?: IntNullableFilter<"Settings"> | number | null
    primary_color?: StringFilter<"Settings"> | string
    secondary_color?: StringFilter<"Settings"> | string
    created_at?: BigIntFilter<"Settings"> | bigint | number
    updated_at?: BigIntFilter<"Settings"> | bigint | number
    current_email_lang?: StringFilter<"Settings"> | string
    email_limit?: IntFilter<"Settings"> | number
    notify_once?: BoolFilter<"Settings"> | boolean
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    commission_delay?: SortOrder
    commission_approval_mode?: SortOrder
    commission_calculation?: SortOrder
    details?: SortOrderInput | SortOrder
    min_threshold?: SortOrderInput | SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    current_email_lang?: SortOrder
    email_limit?: SortOrder
    notify_once?: SortOrder
    stores?: StoresOrderByWithRelationInput
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id?: number
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    commission_delay?: IntFilter<"Settings"> | number
    commission_approval_mode?: EnumApprovalModeTypeFilter<"Settings"> | $Enums.ApprovalModeType
    commission_calculation?: EnumCommissionCalculationTypeFilter<"Settings"> | $Enums.CommissionCalculationType
    details?: JsonNullableFilter<"Settings">
    min_threshold?: IntNullableFilter<"Settings"> | number | null
    primary_color?: StringFilter<"Settings"> | string
    secondary_color?: StringFilter<"Settings"> | string
    created_at?: BigIntFilter<"Settings"> | bigint | number
    updated_at?: BigIntFilter<"Settings"> | bigint | number
    current_email_lang?: StringFilter<"Settings"> | string
    email_limit?: IntFilter<"Settings"> | number
    notify_once?: BoolFilter<"Settings"> | boolean
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "store_id">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    commission_delay?: SortOrder
    commission_approval_mode?: SortOrder
    commission_calculation?: SortOrder
    details?: SortOrderInput | SortOrder
    min_threshold?: SortOrderInput | SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    current_email_lang?: SortOrder
    email_limit?: SortOrder
    notify_once?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _avg?: SettingsAvgOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
    _sum?: SettingsSumOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Settings"> | number
    store_id?: IntWithAggregatesFilter<"Settings"> | number
    commission_delay?: IntWithAggregatesFilter<"Settings"> | number
    commission_approval_mode?: EnumApprovalModeTypeWithAggregatesFilter<"Settings"> | $Enums.ApprovalModeType
    commission_calculation?: EnumCommissionCalculationTypeWithAggregatesFilter<"Settings"> | $Enums.CommissionCalculationType
    details?: JsonNullableWithAggregatesFilter<"Settings">
    min_threshold?: IntNullableWithAggregatesFilter<"Settings"> | number | null
    primary_color?: StringWithAggregatesFilter<"Settings"> | string
    secondary_color?: StringWithAggregatesFilter<"Settings"> | string
    created_at?: BigIntWithAggregatesFilter<"Settings"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Settings"> | bigint | number
    current_email_lang?: StringWithAggregatesFilter<"Settings"> | string
    email_limit?: IntWithAggregatesFilter<"Settings"> | number
    notify_once?: BoolWithAggregatesFilter<"Settings"> | boolean
  }

  export type JobsWhereInput = {
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    id?: IntFilter<"Jobs"> | number
    store_id?: IntFilter<"Jobs"> | number
    job_metadata?: JsonFilter<"Jobs">
    status?: EnumJobsStatusTypeFilter<"Jobs"> | $Enums.JobsStatusType
    type?: EnumJobTypeFilter<"Jobs"> | $Enums.JobType
    job_details?: JsonFilter<"Jobs">
    created_at?: BigIntFilter<"Jobs"> | bigint | number
    updated_at?: BigIntFilter<"Jobs"> | bigint | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    payouts?: XOR<PayoutsNullableRelationFilter, PayoutsWhereInput> | null
  }

  export type JobsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    job_metadata?: SortOrder
    status?: SortOrder
    type?: SortOrder
    job_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stores?: StoresOrderByWithRelationInput
    payouts?: PayoutsOrderByWithRelationInput
  }

  export type JobsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobsWhereInput | JobsWhereInput[]
    OR?: JobsWhereInput[]
    NOT?: JobsWhereInput | JobsWhereInput[]
    store_id?: IntFilter<"Jobs"> | number
    job_metadata?: JsonFilter<"Jobs">
    status?: EnumJobsStatusTypeFilter<"Jobs"> | $Enums.JobsStatusType
    type?: EnumJobTypeFilter<"Jobs"> | $Enums.JobType
    job_details?: JsonFilter<"Jobs">
    created_at?: BigIntFilter<"Jobs"> | bigint | number
    updated_at?: BigIntFilter<"Jobs"> | bigint | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    payouts?: XOR<PayoutsNullableRelationFilter, PayoutsWhereInput> | null
  }, "id">

  export type JobsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    job_metadata?: SortOrder
    status?: SortOrder
    type?: SortOrder
    job_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: JobsCountOrderByAggregateInput
    _avg?: JobsAvgOrderByAggregateInput
    _max?: JobsMaxOrderByAggregateInput
    _min?: JobsMinOrderByAggregateInput
    _sum?: JobsSumOrderByAggregateInput
  }

  export type JobsScalarWhereWithAggregatesInput = {
    AND?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    OR?: JobsScalarWhereWithAggregatesInput[]
    NOT?: JobsScalarWhereWithAggregatesInput | JobsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Jobs"> | number
    store_id?: IntWithAggregatesFilter<"Jobs"> | number
    job_metadata?: JsonWithAggregatesFilter<"Jobs">
    status?: EnumJobsStatusTypeWithAggregatesFilter<"Jobs"> | $Enums.JobsStatusType
    type?: EnumJobTypeWithAggregatesFilter<"Jobs"> | $Enums.JobType
    job_details?: JsonWithAggregatesFilter<"Jobs">
    created_at?: BigIntWithAggregatesFilter<"Jobs"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Jobs"> | bigint | number
  }

  export type CustomersWhereInput = {
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    id?: IntFilter<"Customers"> | number
    store_id?: IntFilter<"Customers"> | number
    affiliate_id?: IntFilter<"Customers"> | number
    shopify_customer_id?: BigIntFilter<"Customers"> | bigint | number
    first_name?: StringFilter<"Customers"> | string
    last_name?: StringFilter<"Customers"> | string
    contact_type?: EnumContactTypeFilter<"Customers"> | $Enums.ContactType
    email?: StringNullableFilter<"Customers"> | string | null
    phone?: StringNullableFilter<"Customers"> | string | null
    customer_details?: JsonFilter<"Customers">
    created_at?: BigIntFilter<"Customers"> | bigint | number
    updated_at?: BigIntFilter<"Customers"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    order_items?: OrderItemsListRelationFilter
    orders?: OrdersListRelationFilter
  }

  export type CustomersOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    shopify_customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    contact_type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    customer_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
    order_items?: OrderItemsOrderByRelationAggregateInput
    orders?: OrdersOrderByRelationAggregateInput
  }

  export type CustomersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id_affiliate_id_email?: CustomersStore_idAffiliate_idEmailCompoundUniqueInput
    store_id_affiliate_id_phone?: CustomersStore_idAffiliate_idPhoneCompoundUniqueInput
    AND?: CustomersWhereInput | CustomersWhereInput[]
    OR?: CustomersWhereInput[]
    NOT?: CustomersWhereInput | CustomersWhereInput[]
    store_id?: IntFilter<"Customers"> | number
    affiliate_id?: IntFilter<"Customers"> | number
    shopify_customer_id?: BigIntFilter<"Customers"> | bigint | number
    first_name?: StringFilter<"Customers"> | string
    last_name?: StringFilter<"Customers"> | string
    contact_type?: EnumContactTypeFilter<"Customers"> | $Enums.ContactType
    email?: StringNullableFilter<"Customers"> | string | null
    phone?: StringNullableFilter<"Customers"> | string | null
    customer_details?: JsonFilter<"Customers">
    created_at?: BigIntFilter<"Customers"> | bigint | number
    updated_at?: BigIntFilter<"Customers"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    order_items?: OrderItemsListRelationFilter
    orders?: OrdersListRelationFilter
  }, "id" | "store_id_affiliate_id_email" | "store_id_affiliate_id_phone">

  export type CustomersOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    shopify_customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    contact_type?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    customer_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: CustomersCountOrderByAggregateInput
    _avg?: CustomersAvgOrderByAggregateInput
    _max?: CustomersMaxOrderByAggregateInput
    _min?: CustomersMinOrderByAggregateInput
    _sum?: CustomersSumOrderByAggregateInput
  }

  export type CustomersScalarWhereWithAggregatesInput = {
    AND?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    OR?: CustomersScalarWhereWithAggregatesInput[]
    NOT?: CustomersScalarWhereWithAggregatesInput | CustomersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customers"> | number
    store_id?: IntWithAggregatesFilter<"Customers"> | number
    affiliate_id?: IntWithAggregatesFilter<"Customers"> | number
    shopify_customer_id?: BigIntWithAggregatesFilter<"Customers"> | bigint | number
    first_name?: StringWithAggregatesFilter<"Customers"> | string
    last_name?: StringWithAggregatesFilter<"Customers"> | string
    contact_type?: EnumContactTypeWithAggregatesFilter<"Customers"> | $Enums.ContactType
    email?: StringNullableWithAggregatesFilter<"Customers"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customers"> | string | null
    customer_details?: JsonWithAggregatesFilter<"Customers">
    created_at?: BigIntWithAggregatesFilter<"Customers"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Customers"> | bigint | number
  }

  export type AffiliatesWhereInput = {
    AND?: AffiliatesWhereInput | AffiliatesWhereInput[]
    OR?: AffiliatesWhereInput[]
    NOT?: AffiliatesWhereInput | AffiliatesWhereInput[]
    id?: IntFilter<"Affiliates"> | number
    store_id?: IntFilter<"Affiliates"> | number
    member_id?: IntFilter<"Affiliates"> | number
    first_name?: StringNullableFilter<"Affiliates"> | string | null
    last_name?: StringNullableFilter<"Affiliates"> | string | null
    phone?: StringNullableFilter<"Affiliates"> | string | null
    referral_code?: StringFilter<"Affiliates"> | string
    status?: EnumAffiliateStatusTypeFilter<"Affiliates"> | $Enums.AffiliateStatusType
    affiliate_details?: JsonNullableFilter<"Affiliates">
    payout_requested?: BoolNullableFilter<"Affiliates"> | boolean | null
    created_at?: BigIntFilter<"Affiliates"> | bigint | number
    updated_at?: BigIntFilter<"Affiliates"> | bigint | number
    source?: EnumAffiliateSourceTypeNullableFilter<"Affiliates"> | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusListRelationFilter
    affiliate_discounts?: AffiliateDiscountsListRelationFilter
    affiliate_gifts?: AffiliateGiftsListRelationFilter
    affiliate_program_history?: AffiliateProgramHistoryListRelationFilter
    affiliate_programs?: AffiliateProgramsListRelationFilter
    members?: XOR<MembersRelationFilter, MembersWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    commissions?: CommissionsListRelationFilter
    customers?: CustomersListRelationFilter
    order_items?: OrderItemsListRelationFilter
    orders?: OrdersListRelationFilter
    payouts?: PayoutsListRelationFilter
    transactions?: TransactionsListRelationFilter
    activity_log?: ActivityLogListRelationFilter
  }

  export type AffiliatesOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    referral_code?: SortOrder
    status?: SortOrder
    affiliate_details?: SortOrderInput | SortOrder
    payout_requested?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    source?: SortOrderInput | SortOrder
    affiliate_bonus?: AffiliateBonusOrderByRelationAggregateInput
    affiliate_discounts?: AffiliateDiscountsOrderByRelationAggregateInput
    affiliate_gifts?: AffiliateGiftsOrderByRelationAggregateInput
    affiliate_program_history?: AffiliateProgramHistoryOrderByRelationAggregateInput
    affiliate_programs?: AffiliateProgramsOrderByRelationAggregateInput
    members?: MembersOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
    commissions?: CommissionsOrderByRelationAggregateInput
    customers?: CustomersOrderByRelationAggregateInput
    order_items?: OrderItemsOrderByRelationAggregateInput
    orders?: OrdersOrderByRelationAggregateInput
    payouts?: PayoutsOrderByRelationAggregateInput
    transactions?: TransactionsOrderByRelationAggregateInput
    activity_log?: ActivityLogOrderByRelationAggregateInput
  }

  export type AffiliatesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id_phone?: AffiliatesStore_idPhoneCompoundUniqueInput
    store_id_member_id?: AffiliatesStore_idMember_idCompoundUniqueInput
    store_id_referral_code?: AffiliatesStore_idReferral_codeCompoundUniqueInput
    AND?: AffiliatesWhereInput | AffiliatesWhereInput[]
    OR?: AffiliatesWhereInput[]
    NOT?: AffiliatesWhereInput | AffiliatesWhereInput[]
    store_id?: IntFilter<"Affiliates"> | number
    member_id?: IntFilter<"Affiliates"> | number
    first_name?: StringNullableFilter<"Affiliates"> | string | null
    last_name?: StringNullableFilter<"Affiliates"> | string | null
    phone?: StringNullableFilter<"Affiliates"> | string | null
    referral_code?: StringFilter<"Affiliates"> | string
    status?: EnumAffiliateStatusTypeFilter<"Affiliates"> | $Enums.AffiliateStatusType
    affiliate_details?: JsonNullableFilter<"Affiliates">
    payout_requested?: BoolNullableFilter<"Affiliates"> | boolean | null
    created_at?: BigIntFilter<"Affiliates"> | bigint | number
    updated_at?: BigIntFilter<"Affiliates"> | bigint | number
    source?: EnumAffiliateSourceTypeNullableFilter<"Affiliates"> | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusListRelationFilter
    affiliate_discounts?: AffiliateDiscountsListRelationFilter
    affiliate_gifts?: AffiliateGiftsListRelationFilter
    affiliate_program_history?: AffiliateProgramHistoryListRelationFilter
    affiliate_programs?: AffiliateProgramsListRelationFilter
    members?: XOR<MembersRelationFilter, MembersWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    commissions?: CommissionsListRelationFilter
    customers?: CustomersListRelationFilter
    order_items?: OrderItemsListRelationFilter
    orders?: OrdersListRelationFilter
    payouts?: PayoutsListRelationFilter
    transactions?: TransactionsListRelationFilter
    activity_log?: ActivityLogListRelationFilter
  }, "id" | "store_id_phone" | "store_id_member_id" | "store_id_referral_code">

  export type AffiliatesOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    referral_code?: SortOrder
    status?: SortOrder
    affiliate_details?: SortOrderInput | SortOrder
    payout_requested?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    source?: SortOrderInput | SortOrder
    _count?: AffiliatesCountOrderByAggregateInput
    _avg?: AffiliatesAvgOrderByAggregateInput
    _max?: AffiliatesMaxOrderByAggregateInput
    _min?: AffiliatesMinOrderByAggregateInput
    _sum?: AffiliatesSumOrderByAggregateInput
  }

  export type AffiliatesScalarWhereWithAggregatesInput = {
    AND?: AffiliatesScalarWhereWithAggregatesInput | AffiliatesScalarWhereWithAggregatesInput[]
    OR?: AffiliatesScalarWhereWithAggregatesInput[]
    NOT?: AffiliatesScalarWhereWithAggregatesInput | AffiliatesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Affiliates"> | number
    store_id?: IntWithAggregatesFilter<"Affiliates"> | number
    member_id?: IntWithAggregatesFilter<"Affiliates"> | number
    first_name?: StringNullableWithAggregatesFilter<"Affiliates"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"Affiliates"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Affiliates"> | string | null
    referral_code?: StringWithAggregatesFilter<"Affiliates"> | string
    status?: EnumAffiliateStatusTypeWithAggregatesFilter<"Affiliates"> | $Enums.AffiliateStatusType
    affiliate_details?: JsonNullableWithAggregatesFilter<"Affiliates">
    payout_requested?: BoolNullableWithAggregatesFilter<"Affiliates"> | boolean | null
    created_at?: BigIntWithAggregatesFilter<"Affiliates"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Affiliates"> | bigint | number
    source?: EnumAffiliateSourceTypeNullableWithAggregatesFilter<"Affiliates"> | $Enums.AffiliateSourceType | null
  }

  export type AffiliateProgramsWhereInput = {
    AND?: AffiliateProgramsWhereInput | AffiliateProgramsWhereInput[]
    OR?: AffiliateProgramsWhereInput[]
    NOT?: AffiliateProgramsWhereInput | AffiliateProgramsWhereInput[]
    id?: IntFilter<"AffiliatePrograms"> | number
    store_id?: IntFilter<"AffiliatePrograms"> | number
    affiliate_id?: IntFilter<"AffiliatePrograms"> | number
    program_id?: IntFilter<"AffiliatePrograms"> | number
    created_at?: BigIntFilter<"AffiliatePrograms"> | bigint | number
    updated_at?: BigIntFilter<"AffiliatePrograms"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    programs?: XOR<ProgramsRelationFilter, ProgramsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type AffiliateProgramsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    programs?: ProgramsOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type AffiliateProgramsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id_affiliate_id?: AffiliateProgramsStore_idAffiliate_idCompoundUniqueInput
    store_id_affiliate_id_program_id?: AffiliateProgramsStore_idAffiliate_idProgram_idCompoundUniqueInput
    AND?: AffiliateProgramsWhereInput | AffiliateProgramsWhereInput[]
    OR?: AffiliateProgramsWhereInput[]
    NOT?: AffiliateProgramsWhereInput | AffiliateProgramsWhereInput[]
    store_id?: IntFilter<"AffiliatePrograms"> | number
    affiliate_id?: IntFilter<"AffiliatePrograms"> | number
    program_id?: IntFilter<"AffiliatePrograms"> | number
    created_at?: BigIntFilter<"AffiliatePrograms"> | bigint | number
    updated_at?: BigIntFilter<"AffiliatePrograms"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    programs?: XOR<ProgramsRelationFilter, ProgramsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "store_id_affiliate_id" | "store_id_affiliate_id_program_id">

  export type AffiliateProgramsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AffiliateProgramsCountOrderByAggregateInput
    _avg?: AffiliateProgramsAvgOrderByAggregateInput
    _max?: AffiliateProgramsMaxOrderByAggregateInput
    _min?: AffiliateProgramsMinOrderByAggregateInput
    _sum?: AffiliateProgramsSumOrderByAggregateInput
  }

  export type AffiliateProgramsScalarWhereWithAggregatesInput = {
    AND?: AffiliateProgramsScalarWhereWithAggregatesInput | AffiliateProgramsScalarWhereWithAggregatesInput[]
    OR?: AffiliateProgramsScalarWhereWithAggregatesInput[]
    NOT?: AffiliateProgramsScalarWhereWithAggregatesInput | AffiliateProgramsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AffiliatePrograms"> | number
    store_id?: IntWithAggregatesFilter<"AffiliatePrograms"> | number
    affiliate_id?: IntWithAggregatesFilter<"AffiliatePrograms"> | number
    program_id?: IntWithAggregatesFilter<"AffiliatePrograms"> | number
    created_at?: BigIntWithAggregatesFilter<"AffiliatePrograms"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"AffiliatePrograms"> | bigint | number
  }

  export type AffiliateProgramHistoryWhereInput = {
    AND?: AffiliateProgramHistoryWhereInput | AffiliateProgramHistoryWhereInput[]
    OR?: AffiliateProgramHistoryWhereInput[]
    NOT?: AffiliateProgramHistoryWhereInput | AffiliateProgramHistoryWhereInput[]
    id?: IntFilter<"AffiliateProgramHistory"> | number
    store_id?: IntFilter<"AffiliateProgramHistory"> | number
    affiliate_id?: IntFilter<"AffiliateProgramHistory"> | number
    program_id?: IntFilter<"AffiliateProgramHistory"> | number
    program_name?: StringFilter<"AffiliateProgramHistory"> | string
    status?: EnumProgramHistoryStatusTypeFilter<"AffiliateProgramHistory"> | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFilter<"AffiliateProgramHistory"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateProgramHistory"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type AffiliateProgramHistoryOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    program_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type AffiliateProgramHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AffiliateProgramHistoryWhereInput | AffiliateProgramHistoryWhereInput[]
    OR?: AffiliateProgramHistoryWhereInput[]
    NOT?: AffiliateProgramHistoryWhereInput | AffiliateProgramHistoryWhereInput[]
    store_id?: IntFilter<"AffiliateProgramHistory"> | number
    affiliate_id?: IntFilter<"AffiliateProgramHistory"> | number
    program_id?: IntFilter<"AffiliateProgramHistory"> | number
    program_name?: StringFilter<"AffiliateProgramHistory"> | string
    status?: EnumProgramHistoryStatusTypeFilter<"AffiliateProgramHistory"> | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFilter<"AffiliateProgramHistory"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateProgramHistory"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id">

  export type AffiliateProgramHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    program_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AffiliateProgramHistoryCountOrderByAggregateInput
    _avg?: AffiliateProgramHistoryAvgOrderByAggregateInput
    _max?: AffiliateProgramHistoryMaxOrderByAggregateInput
    _min?: AffiliateProgramHistoryMinOrderByAggregateInput
    _sum?: AffiliateProgramHistorySumOrderByAggregateInput
  }

  export type AffiliateProgramHistoryScalarWhereWithAggregatesInput = {
    AND?: AffiliateProgramHistoryScalarWhereWithAggregatesInput | AffiliateProgramHistoryScalarWhereWithAggregatesInput[]
    OR?: AffiliateProgramHistoryScalarWhereWithAggregatesInput[]
    NOT?: AffiliateProgramHistoryScalarWhereWithAggregatesInput | AffiliateProgramHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AffiliateProgramHistory"> | number
    store_id?: IntWithAggregatesFilter<"AffiliateProgramHistory"> | number
    affiliate_id?: IntWithAggregatesFilter<"AffiliateProgramHistory"> | number
    program_id?: IntWithAggregatesFilter<"AffiliateProgramHistory"> | number
    program_name?: StringWithAggregatesFilter<"AffiliateProgramHistory"> | string
    status?: EnumProgramHistoryStatusTypeWithAggregatesFilter<"AffiliateProgramHistory"> | $Enums.ProgramHistoryStatusType
    created_at?: BigIntWithAggregatesFilter<"AffiliateProgramHistory"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"AffiliateProgramHistory"> | bigint | number
  }

  export type AffiliateDiscountsWhereInput = {
    AND?: AffiliateDiscountsWhereInput | AffiliateDiscountsWhereInput[]
    OR?: AffiliateDiscountsWhereInput[]
    NOT?: AffiliateDiscountsWhereInput | AffiliateDiscountsWhereInput[]
    id?: IntFilter<"AffiliateDiscounts"> | number
    store_id?: IntFilter<"AffiliateDiscounts"> | number
    affiliate_id?: IntFilter<"AffiliateDiscounts"> | number
    discount_id?: BigIntFilter<"AffiliateDiscounts"> | bigint | number
    discount_code?: StringFilter<"AffiliateDiscounts"> | string
    is_deleted?: BoolNullableFilter<"AffiliateDiscounts"> | boolean | null
    status?: EnumDiscountStatusTypeFilter<"AffiliateDiscounts"> | $Enums.DiscountStatusType
    created_at?: BigIntFilter<"AffiliateDiscounts"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateDiscounts"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type AffiliateDiscountsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    discount_id?: SortOrder
    discount_code?: SortOrder
    is_deleted?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type AffiliateDiscountsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    discount_id?: bigint | number
    store_id_affiliate_id_discount_id?: AffiliateDiscountsStore_idAffiliate_idDiscount_idCompoundUniqueInput
    AND?: AffiliateDiscountsWhereInput | AffiliateDiscountsWhereInput[]
    OR?: AffiliateDiscountsWhereInput[]
    NOT?: AffiliateDiscountsWhereInput | AffiliateDiscountsWhereInput[]
    store_id?: IntFilter<"AffiliateDiscounts"> | number
    affiliate_id?: IntFilter<"AffiliateDiscounts"> | number
    discount_code?: StringFilter<"AffiliateDiscounts"> | string
    is_deleted?: BoolNullableFilter<"AffiliateDiscounts"> | boolean | null
    status?: EnumDiscountStatusTypeFilter<"AffiliateDiscounts"> | $Enums.DiscountStatusType
    created_at?: BigIntFilter<"AffiliateDiscounts"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateDiscounts"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "discount_id" | "store_id_affiliate_id_discount_id">

  export type AffiliateDiscountsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    discount_id?: SortOrder
    discount_code?: SortOrder
    is_deleted?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AffiliateDiscountsCountOrderByAggregateInput
    _avg?: AffiliateDiscountsAvgOrderByAggregateInput
    _max?: AffiliateDiscountsMaxOrderByAggregateInput
    _min?: AffiliateDiscountsMinOrderByAggregateInput
    _sum?: AffiliateDiscountsSumOrderByAggregateInput
  }

  export type AffiliateDiscountsScalarWhereWithAggregatesInput = {
    AND?: AffiliateDiscountsScalarWhereWithAggregatesInput | AffiliateDiscountsScalarWhereWithAggregatesInput[]
    OR?: AffiliateDiscountsScalarWhereWithAggregatesInput[]
    NOT?: AffiliateDiscountsScalarWhereWithAggregatesInput | AffiliateDiscountsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AffiliateDiscounts"> | number
    store_id?: IntWithAggregatesFilter<"AffiliateDiscounts"> | number
    affiliate_id?: IntWithAggregatesFilter<"AffiliateDiscounts"> | number
    discount_id?: BigIntWithAggregatesFilter<"AffiliateDiscounts"> | bigint | number
    discount_code?: StringWithAggregatesFilter<"AffiliateDiscounts"> | string
    is_deleted?: BoolNullableWithAggregatesFilter<"AffiliateDiscounts"> | boolean | null
    status?: EnumDiscountStatusTypeWithAggregatesFilter<"AffiliateDiscounts"> | $Enums.DiscountStatusType
    created_at?: BigIntWithAggregatesFilter<"AffiliateDiscounts"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"AffiliateDiscounts"> | bigint | number
  }

  export type AffiliateGiftsWhereInput = {
    AND?: AffiliateGiftsWhereInput | AffiliateGiftsWhereInput[]
    OR?: AffiliateGiftsWhereInput[]
    NOT?: AffiliateGiftsWhereInput | AffiliateGiftsWhereInput[]
    id?: IntFilter<"AffiliateGifts"> | number
    store_id?: IntFilter<"AffiliateGifts"> | number
    affiliate_id?: IntFilter<"AffiliateGifts"> | number
    gift_id?: IntFilter<"AffiliateGifts"> | number
    created_at?: BigIntFilter<"AffiliateGifts"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateGifts"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    gifts?: XOR<GiftsRelationFilter, GiftsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type AffiliateGiftsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    gift_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    gifts?: GiftsOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type AffiliateGiftsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id_affiliate_id_gift_id?: AffiliateGiftsStore_idAffiliate_idGift_idCompoundUniqueInput
    AND?: AffiliateGiftsWhereInput | AffiliateGiftsWhereInput[]
    OR?: AffiliateGiftsWhereInput[]
    NOT?: AffiliateGiftsWhereInput | AffiliateGiftsWhereInput[]
    store_id?: IntFilter<"AffiliateGifts"> | number
    affiliate_id?: IntFilter<"AffiliateGifts"> | number
    gift_id?: IntFilter<"AffiliateGifts"> | number
    created_at?: BigIntFilter<"AffiliateGifts"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateGifts"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    gifts?: XOR<GiftsRelationFilter, GiftsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "store_id_affiliate_id_gift_id">

  export type AffiliateGiftsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    gift_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AffiliateGiftsCountOrderByAggregateInput
    _avg?: AffiliateGiftsAvgOrderByAggregateInput
    _max?: AffiliateGiftsMaxOrderByAggregateInput
    _min?: AffiliateGiftsMinOrderByAggregateInput
    _sum?: AffiliateGiftsSumOrderByAggregateInput
  }

  export type AffiliateGiftsScalarWhereWithAggregatesInput = {
    AND?: AffiliateGiftsScalarWhereWithAggregatesInput | AffiliateGiftsScalarWhereWithAggregatesInput[]
    OR?: AffiliateGiftsScalarWhereWithAggregatesInput[]
    NOT?: AffiliateGiftsScalarWhereWithAggregatesInput | AffiliateGiftsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AffiliateGifts"> | number
    store_id?: IntWithAggregatesFilter<"AffiliateGifts"> | number
    affiliate_id?: IntWithAggregatesFilter<"AffiliateGifts"> | number
    gift_id?: IntWithAggregatesFilter<"AffiliateGifts"> | number
    created_at?: BigIntWithAggregatesFilter<"AffiliateGifts"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"AffiliateGifts"> | bigint | number
  }

  export type AffiliateBonusWhereInput = {
    AND?: AffiliateBonusWhereInput | AffiliateBonusWhereInput[]
    OR?: AffiliateBonusWhereInput[]
    NOT?: AffiliateBonusWhereInput | AffiliateBonusWhereInput[]
    id?: IntFilter<"AffiliateBonus"> | number
    store_id?: IntFilter<"AffiliateBonus"> | number
    affiliate_id?: IntFilter<"AffiliateBonus"> | number
    bonus_id?: IntFilter<"AffiliateBonus"> | number
    created_at?: BigIntFilter<"AffiliateBonus"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateBonus"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    bonus?: XOR<BonusRelationFilter, BonusWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type AffiliateBonusOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    affiliates?: AffiliatesOrderByWithRelationInput
    bonus?: BonusOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type AffiliateBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id_affiliate_id_bonus_id?: AffiliateBonusStore_idAffiliate_idBonus_idCompoundUniqueInput
    AND?: AffiliateBonusWhereInput | AffiliateBonusWhereInput[]
    OR?: AffiliateBonusWhereInput[]
    NOT?: AffiliateBonusWhereInput | AffiliateBonusWhereInput[]
    store_id?: IntFilter<"AffiliateBonus"> | number
    affiliate_id?: IntFilter<"AffiliateBonus"> | number
    bonus_id?: IntFilter<"AffiliateBonus"> | number
    created_at?: BigIntFilter<"AffiliateBonus"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateBonus"> | bigint | number
    affiliates?: XOR<AffiliatesRelationFilter, AffiliatesWhereInput>
    bonus?: XOR<BonusRelationFilter, BonusWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "store_id_affiliate_id_bonus_id">

  export type AffiliateBonusOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AffiliateBonusCountOrderByAggregateInput
    _avg?: AffiliateBonusAvgOrderByAggregateInput
    _max?: AffiliateBonusMaxOrderByAggregateInput
    _min?: AffiliateBonusMinOrderByAggregateInput
    _sum?: AffiliateBonusSumOrderByAggregateInput
  }

  export type AffiliateBonusScalarWhereWithAggregatesInput = {
    AND?: AffiliateBonusScalarWhereWithAggregatesInput | AffiliateBonusScalarWhereWithAggregatesInput[]
    OR?: AffiliateBonusScalarWhereWithAggregatesInput[]
    NOT?: AffiliateBonusScalarWhereWithAggregatesInput | AffiliateBonusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AffiliateBonus"> | number
    store_id?: IntWithAggregatesFilter<"AffiliateBonus"> | number
    affiliate_id?: IntWithAggregatesFilter<"AffiliateBonus"> | number
    bonus_id?: IntWithAggregatesFilter<"AffiliateBonus"> | number
    created_at?: BigIntWithAggregatesFilter<"AffiliateBonus"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"AffiliateBonus"> | bigint | number
  }

  export type ProgramBonusWhereInput = {
    AND?: ProgramBonusWhereInput | ProgramBonusWhereInput[]
    OR?: ProgramBonusWhereInput[]
    NOT?: ProgramBonusWhereInput | ProgramBonusWhereInput[]
    id?: IntFilter<"ProgramBonus"> | number
    store_id?: IntFilter<"ProgramBonus"> | number
    program_id?: IntFilter<"ProgramBonus"> | number
    bonus_id?: IntFilter<"ProgramBonus"> | number
    created_at?: BigIntFilter<"ProgramBonus"> | bigint | number
    updated_at?: BigIntFilter<"ProgramBonus"> | bigint | number
    bonus?: XOR<BonusRelationFilter, BonusWhereInput>
    programs?: XOR<ProgramsRelationFilter, ProgramsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type ProgramBonusOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    bonus?: BonusOrderByWithRelationInput
    programs?: ProgramsOrderByWithRelationInput
    stores?: StoresOrderByWithRelationInput
  }

  export type ProgramBonusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id_program_id_bonus_id?: ProgramBonusStore_idProgram_idBonus_idCompoundUniqueInput
    AND?: ProgramBonusWhereInput | ProgramBonusWhereInput[]
    OR?: ProgramBonusWhereInput[]
    NOT?: ProgramBonusWhereInput | ProgramBonusWhereInput[]
    store_id?: IntFilter<"ProgramBonus"> | number
    program_id?: IntFilter<"ProgramBonus"> | number
    bonus_id?: IntFilter<"ProgramBonus"> | number
    created_at?: BigIntFilter<"ProgramBonus"> | bigint | number
    updated_at?: BigIntFilter<"ProgramBonus"> | bigint | number
    bonus?: XOR<BonusRelationFilter, BonusWhereInput>
    programs?: XOR<ProgramsRelationFilter, ProgramsWhereInput>
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "store_id_program_id_bonus_id">

  export type ProgramBonusOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProgramBonusCountOrderByAggregateInput
    _avg?: ProgramBonusAvgOrderByAggregateInput
    _max?: ProgramBonusMaxOrderByAggregateInput
    _min?: ProgramBonusMinOrderByAggregateInput
    _sum?: ProgramBonusSumOrderByAggregateInput
  }

  export type ProgramBonusScalarWhereWithAggregatesInput = {
    AND?: ProgramBonusScalarWhereWithAggregatesInput | ProgramBonusScalarWhereWithAggregatesInput[]
    OR?: ProgramBonusScalarWhereWithAggregatesInput[]
    NOT?: ProgramBonusScalarWhereWithAggregatesInput | ProgramBonusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProgramBonus"> | number
    store_id?: IntWithAggregatesFilter<"ProgramBonus"> | number
    program_id?: IntWithAggregatesFilter<"ProgramBonus"> | number
    bonus_id?: IntWithAggregatesFilter<"ProgramBonus"> | number
    created_at?: BigIntWithAggregatesFilter<"ProgramBonus"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"ProgramBonus"> | bigint | number
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: IntFilter<"Otp"> | number
    code?: IntFilter<"Otp"> | number
    email?: StringFilter<"Otp"> | string
    expire_at?: BigIntFilter<"Otp"> | bigint | number
    created_at?: BigIntFilter<"Otp"> | bigint | number
    updated_at?: BigIntFilter<"Otp"> | bigint | number
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    expire_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: number
    email?: string
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    expire_at?: BigIntFilter<"Otp"> | bigint | number
    created_at?: BigIntFilter<"Otp"> | bigint | number
    updated_at?: BigIntFilter<"Otp"> | bigint | number
  }, "id" | "code" | "email">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    expire_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _avg?: OtpAvgOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
    _sum?: OtpSumOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Otp"> | number
    code?: IntWithAggregatesFilter<"Otp"> | number
    email?: StringWithAggregatesFilter<"Otp"> | string
    expire_at?: BigIntWithAggregatesFilter<"Otp"> | bigint | number
    created_at?: BigIntWithAggregatesFilter<"Otp"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Otp"> | bigint | number
  }

  export type NotificationsWhereInput = {
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    id?: IntFilter<"Notifications"> | number
    notification_id?: StringFilter<"Notifications"> | string
    store_id?: IntFilter<"Notifications"> | number
    type?: EnumNotificationTypeFilter<"Notifications"> | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFilter<"Notifications"> | $Enums.NotificationReceiverType
    subject?: StringFilter<"Notifications"> | string
    status?: EnumNotificationStatusTypeFilter<"Notifications"> | $Enums.NotificationStatusType
    created_at?: BigIntFilter<"Notifications"> | bigint | number
    updated_at?: BigIntFilter<"Notifications"> | bigint | number
    languages?: StringFilter<"Notifications"> | string
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type NotificationsOrderByWithRelationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    store_id?: SortOrder
    type?: SortOrder
    receiver_type?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    languages?: SortOrder
    stores?: StoresOrderByWithRelationInput
  }

  export type NotificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    notification_id?: string
    store_id_type_receiver_type_languages?: NotificationsStore_idTypeReceiver_typeLanguagesCompoundUniqueInput
    AND?: NotificationsWhereInput | NotificationsWhereInput[]
    OR?: NotificationsWhereInput[]
    NOT?: NotificationsWhereInput | NotificationsWhereInput[]
    store_id?: IntFilter<"Notifications"> | number
    type?: EnumNotificationTypeFilter<"Notifications"> | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFilter<"Notifications"> | $Enums.NotificationReceiverType
    subject?: StringFilter<"Notifications"> | string
    status?: EnumNotificationStatusTypeFilter<"Notifications"> | $Enums.NotificationStatusType
    created_at?: BigIntFilter<"Notifications"> | bigint | number
    updated_at?: BigIntFilter<"Notifications"> | bigint | number
    languages?: StringFilter<"Notifications"> | string
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "notification_id" | "store_id_type_receiver_type_languages">

  export type NotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    notification_id?: SortOrder
    store_id?: SortOrder
    type?: SortOrder
    receiver_type?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    languages?: SortOrder
    _count?: NotificationsCountOrderByAggregateInput
    _avg?: NotificationsAvgOrderByAggregateInput
    _max?: NotificationsMaxOrderByAggregateInput
    _min?: NotificationsMinOrderByAggregateInput
    _sum?: NotificationsSumOrderByAggregateInput
  }

  export type NotificationsScalarWhereWithAggregatesInput = {
    AND?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    OR?: NotificationsScalarWhereWithAggregatesInput[]
    NOT?: NotificationsScalarWhereWithAggregatesInput | NotificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notifications"> | number
    notification_id?: StringWithAggregatesFilter<"Notifications"> | string
    store_id?: IntWithAggregatesFilter<"Notifications"> | number
    type?: EnumNotificationTypeWithAggregatesFilter<"Notifications"> | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeWithAggregatesFilter<"Notifications"> | $Enums.NotificationReceiverType
    subject?: StringWithAggregatesFilter<"Notifications"> | string
    status?: EnumNotificationStatusTypeWithAggregatesFilter<"Notifications"> | $Enums.NotificationStatusType
    created_at?: BigIntWithAggregatesFilter<"Notifications"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Notifications"> | bigint | number
    languages?: StringWithAggregatesFilter<"Notifications"> | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    store_id?: IntFilter<"ActivityLog"> | number
    affiliate_id?: IntNullableFilter<"ActivityLog"> | number | null
    program_id?: IntNullableFilter<"ActivityLog"> | number | null
    order_id?: IntNullableFilter<"ActivityLog"> | number | null
    payout_id?: IntNullableFilter<"ActivityLog"> | number | null
    entity_type?: EnumActivityEntityTypeFilter<"ActivityLog"> | $Enums.ActivityEntityType
    message?: StringFilter<"ActivityLog"> | string
    created_at?: BigIntFilter<"ActivityLog"> | bigint | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    affiliates?: XOR<AffiliatesNullableRelationFilter, AffiliatesWhereInput> | null
    programs?: XOR<ProgramsNullableRelationFilter, ProgramsWhereInput> | null
    orders?: XOR<OrdersNullableRelationFilter, OrdersWhereInput> | null
    payouts?: XOR<PayoutsNullableRelationFilter, PayoutsWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrderInput | SortOrder
    program_id?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    payout_id?: SortOrderInput | SortOrder
    entity_type?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    stores?: StoresOrderByWithRelationInput
    affiliates?: AffiliatesOrderByWithRelationInput
    programs?: ProgramsOrderByWithRelationInput
    orders?: OrdersOrderByWithRelationInput
    payouts?: PayoutsOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    store_id?: IntFilter<"ActivityLog"> | number
    affiliate_id?: IntNullableFilter<"ActivityLog"> | number | null
    program_id?: IntNullableFilter<"ActivityLog"> | number | null
    order_id?: IntNullableFilter<"ActivityLog"> | number | null
    payout_id?: IntNullableFilter<"ActivityLog"> | number | null
    entity_type?: EnumActivityEntityTypeFilter<"ActivityLog"> | $Enums.ActivityEntityType
    message?: StringFilter<"ActivityLog"> | string
    created_at?: BigIntFilter<"ActivityLog"> | bigint | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
    affiliates?: XOR<AffiliatesNullableRelationFilter, AffiliatesWhereInput> | null
    programs?: XOR<ProgramsNullableRelationFilter, ProgramsWhereInput> | null
    orders?: XOR<OrdersNullableRelationFilter, OrdersWhereInput> | null
    payouts?: XOR<PayoutsNullableRelationFilter, PayoutsWhereInput> | null
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrderInput | SortOrder
    program_id?: SortOrderInput | SortOrder
    order_id?: SortOrderInput | SortOrder
    payout_id?: SortOrderInput | SortOrder
    entity_type?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityLog"> | number
    store_id?: IntWithAggregatesFilter<"ActivityLog"> | number
    affiliate_id?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    program_id?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    order_id?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    payout_id?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    entity_type?: EnumActivityEntityTypeWithAggregatesFilter<"ActivityLog"> | $Enums.ActivityEntityType
    message?: StringWithAggregatesFilter<"ActivityLog"> | string
    created_at?: BigIntWithAggregatesFilter<"ActivityLog"> | bigint | number
  }

  export type MessageHistoryWhereInput = {
    AND?: MessageHistoryWhereInput | MessageHistoryWhereInput[]
    OR?: MessageHistoryWhereInput[]
    NOT?: MessageHistoryWhereInput | MessageHistoryWhereInput[]
    id?: IntFilter<"MessageHistory"> | number
    status?: EnumMessageHistoryStatusTypeFilter<"MessageHistory"> | $Enums.MessageHistoryStatusType
    referenceId?: StringFilter<"MessageHistory"> | string
    metaData?: JsonFilter<"MessageHistory">
    created_at?: BigIntFilter<"MessageHistory"> | bigint | number
    store_id?: IntFilter<"MessageHistory"> | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type MessageHistoryOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    referenceId?: SortOrder
    metaData?: SortOrder
    created_at?: SortOrder
    store_id?: SortOrder
    stores?: StoresOrderByWithRelationInput
  }

  export type MessageHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MessageHistoryWhereInput | MessageHistoryWhereInput[]
    OR?: MessageHistoryWhereInput[]
    NOT?: MessageHistoryWhereInput | MessageHistoryWhereInput[]
    status?: EnumMessageHistoryStatusTypeFilter<"MessageHistory"> | $Enums.MessageHistoryStatusType
    referenceId?: StringFilter<"MessageHistory"> | string
    metaData?: JsonFilter<"MessageHistory">
    created_at?: BigIntFilter<"MessageHistory"> | bigint | number
    store_id?: IntFilter<"MessageHistory"> | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id">

  export type MessageHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    referenceId?: SortOrder
    metaData?: SortOrder
    created_at?: SortOrder
    store_id?: SortOrder
    _count?: MessageHistoryCountOrderByAggregateInput
    _avg?: MessageHistoryAvgOrderByAggregateInput
    _max?: MessageHistoryMaxOrderByAggregateInput
    _min?: MessageHistoryMinOrderByAggregateInput
    _sum?: MessageHistorySumOrderByAggregateInput
  }

  export type MessageHistoryScalarWhereWithAggregatesInput = {
    AND?: MessageHistoryScalarWhereWithAggregatesInput | MessageHistoryScalarWhereWithAggregatesInput[]
    OR?: MessageHistoryScalarWhereWithAggregatesInput[]
    NOT?: MessageHistoryScalarWhereWithAggregatesInput | MessageHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MessageHistory"> | number
    status?: EnumMessageHistoryStatusTypeWithAggregatesFilter<"MessageHistory"> | $Enums.MessageHistoryStatusType
    referenceId?: StringWithAggregatesFilter<"MessageHistory"> | string
    metaData?: JsonWithAggregatesFilter<"MessageHistory">
    created_at?: BigIntWithAggregatesFilter<"MessageHistory"> | bigint | number
    store_id?: IntWithAggregatesFilter<"MessageHistory"> | number
  }

  export type PaymentGatewayWhereInput = {
    AND?: PaymentGatewayWhereInput | PaymentGatewayWhereInput[]
    OR?: PaymentGatewayWhereInput[]
    NOT?: PaymentGatewayWhereInput | PaymentGatewayWhereInput[]
    id?: IntFilter<"PaymentGateway"> | number
    store_id?: IntFilter<"PaymentGateway"> | number
    payment_uuid?: StringFilter<"PaymentGateway"> | string
    provider?: EnumPaymentTypeFilter<"PaymentGateway"> | $Enums.PaymentType
    credentials?: JsonFilter<"PaymentGateway">
    webhook_id?: StringNullableFilter<"PaymentGateway"> | string | null
    status?: EnumNotificationStatusTypeFilter<"PaymentGateway"> | $Enums.NotificationStatusType
    created_at?: BigIntFilter<"PaymentGateway"> | bigint | number
    updated_at?: BigIntFilter<"PaymentGateway"> | bigint | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type PaymentGatewayOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    payment_uuid?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    webhook_id?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stores?: StoresOrderByWithRelationInput
  }

  export type PaymentGatewayWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id_provider?: PaymentGatewayStore_idProviderCompoundUniqueInput
    AND?: PaymentGatewayWhereInput | PaymentGatewayWhereInput[]
    OR?: PaymentGatewayWhereInput[]
    NOT?: PaymentGatewayWhereInput | PaymentGatewayWhereInput[]
    store_id?: IntFilter<"PaymentGateway"> | number
    payment_uuid?: StringFilter<"PaymentGateway"> | string
    provider?: EnumPaymentTypeFilter<"PaymentGateway"> | $Enums.PaymentType
    credentials?: JsonFilter<"PaymentGateway">
    webhook_id?: StringNullableFilter<"PaymentGateway"> | string | null
    status?: EnumNotificationStatusTypeFilter<"PaymentGateway"> | $Enums.NotificationStatusType
    created_at?: BigIntFilter<"PaymentGateway"> | bigint | number
    updated_at?: BigIntFilter<"PaymentGateway"> | bigint | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "store_id_provider">

  export type PaymentGatewayOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    payment_uuid?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    webhook_id?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PaymentGatewayCountOrderByAggregateInput
    _avg?: PaymentGatewayAvgOrderByAggregateInput
    _max?: PaymentGatewayMaxOrderByAggregateInput
    _min?: PaymentGatewayMinOrderByAggregateInput
    _sum?: PaymentGatewaySumOrderByAggregateInput
  }

  export type PaymentGatewayScalarWhereWithAggregatesInput = {
    AND?: PaymentGatewayScalarWhereWithAggregatesInput | PaymentGatewayScalarWhereWithAggregatesInput[]
    OR?: PaymentGatewayScalarWhereWithAggregatesInput[]
    NOT?: PaymentGatewayScalarWhereWithAggregatesInput | PaymentGatewayScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PaymentGateway"> | number
    store_id?: IntWithAggregatesFilter<"PaymentGateway"> | number
    payment_uuid?: StringWithAggregatesFilter<"PaymentGateway"> | string
    provider?: EnumPaymentTypeWithAggregatesFilter<"PaymentGateway"> | $Enums.PaymentType
    credentials?: JsonWithAggregatesFilter<"PaymentGateway">
    webhook_id?: StringNullableWithAggregatesFilter<"PaymentGateway"> | string | null
    status?: EnumNotificationStatusTypeWithAggregatesFilter<"PaymentGateway"> | $Enums.NotificationStatusType
    created_at?: BigIntWithAggregatesFilter<"PaymentGateway"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"PaymentGateway"> | bigint | number
  }

  export type AppSubscriptionWhereInput = {
    AND?: AppSubscriptionWhereInput | AppSubscriptionWhereInput[]
    OR?: AppSubscriptionWhereInput[]
    NOT?: AppSubscriptionWhereInput | AppSubscriptionWhereInput[]
    id?: IntFilter<"AppSubscription"> | number
    store_id?: IntFilter<"AppSubscription"> | number
    plan_id?: StringNullableFilter<"AppSubscription"> | string | null
    name?: StringFilter<"AppSubscription"> | string
    price?: IntFilter<"AppSubscription"> | number
    status?: EnumAppSubscriptionTypeFilter<"AppSubscription"> | $Enums.AppSubscriptionType
    currency_code?: StringFilter<"AppSubscription"> | string
    created_at?: BigIntFilter<"AppSubscription"> | bigint | number
    updated_at?: BigIntFilter<"AppSubscription"> | bigint | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type AppSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    plan_id?: SortOrderInput | SortOrder
    name?: SortOrder
    price?: SortOrder
    status?: SortOrder
    currency_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stores?: StoresOrderByWithRelationInput
  }

  export type AppSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id?: number
    plan_id?: string
    AND?: AppSubscriptionWhereInput | AppSubscriptionWhereInput[]
    OR?: AppSubscriptionWhereInput[]
    NOT?: AppSubscriptionWhereInput | AppSubscriptionWhereInput[]
    name?: StringFilter<"AppSubscription"> | string
    price?: IntFilter<"AppSubscription"> | number
    status?: EnumAppSubscriptionTypeFilter<"AppSubscription"> | $Enums.AppSubscriptionType
    currency_code?: StringFilter<"AppSubscription"> | string
    created_at?: BigIntFilter<"AppSubscription"> | bigint | number
    updated_at?: BigIntFilter<"AppSubscription"> | bigint | number
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "store_id" | "plan_id">

  export type AppSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    plan_id?: SortOrderInput | SortOrder
    name?: SortOrder
    price?: SortOrder
    status?: SortOrder
    currency_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: AppSubscriptionCountOrderByAggregateInput
    _avg?: AppSubscriptionAvgOrderByAggregateInput
    _max?: AppSubscriptionMaxOrderByAggregateInput
    _min?: AppSubscriptionMinOrderByAggregateInput
    _sum?: AppSubscriptionSumOrderByAggregateInput
  }

  export type AppSubscriptionScalarWhereWithAggregatesInput = {
    AND?: AppSubscriptionScalarWhereWithAggregatesInput | AppSubscriptionScalarWhereWithAggregatesInput[]
    OR?: AppSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: AppSubscriptionScalarWhereWithAggregatesInput | AppSubscriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppSubscription"> | number
    store_id?: IntWithAggregatesFilter<"AppSubscription"> | number
    plan_id?: StringNullableWithAggregatesFilter<"AppSubscription"> | string | null
    name?: StringWithAggregatesFilter<"AppSubscription"> | string
    price?: IntWithAggregatesFilter<"AppSubscription"> | number
    status?: EnumAppSubscriptionTypeWithAggregatesFilter<"AppSubscription"> | $Enums.AppSubscriptionType
    currency_code?: StringWithAggregatesFilter<"AppSubscription"> | string
    created_at?: BigIntWithAggregatesFilter<"AppSubscription"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"AppSubscription"> | bigint | number
  }

  export type IntegrationsWhereInput = {
    AND?: IntegrationsWhereInput | IntegrationsWhereInput[]
    OR?: IntegrationsWhereInput[]
    NOT?: IntegrationsWhereInput | IntegrationsWhereInput[]
    id?: IntFilter<"Integrations"> | number
    store_id?: IntFilter<"Integrations"> | number
    integration_type?: EnumIntegrationTypeFilter<"Integrations"> | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFilter<"Integrations"> | $Enums.NotificationStatusType
    api_key?: StringFilter<"Integrations"> | string
    api_secret?: StringNullableFilter<"Integrations"> | string | null
    created_at?: BigIntFilter<"Integrations"> | bigint | number
    updated_at?: BigIntFilter<"Integrations"> | bigint | number
    integration_details?: JsonNullableFilter<"Integrations">
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type IntegrationsOrderByWithRelationInput = {
    id?: SortOrder
    store_id?: SortOrder
    integration_type?: SortOrder
    status?: SortOrder
    api_key?: SortOrder
    api_secret?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    integration_details?: SortOrderInput | SortOrder
    stores?: StoresOrderByWithRelationInput
  }

  export type IntegrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    store_id_integration_type?: IntegrationsStore_idIntegration_typeCompoundUniqueInput
    AND?: IntegrationsWhereInput | IntegrationsWhereInput[]
    OR?: IntegrationsWhereInput[]
    NOT?: IntegrationsWhereInput | IntegrationsWhereInput[]
    store_id?: IntFilter<"Integrations"> | number
    integration_type?: EnumIntegrationTypeFilter<"Integrations"> | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFilter<"Integrations"> | $Enums.NotificationStatusType
    api_key?: StringFilter<"Integrations"> | string
    api_secret?: StringNullableFilter<"Integrations"> | string | null
    created_at?: BigIntFilter<"Integrations"> | bigint | number
    updated_at?: BigIntFilter<"Integrations"> | bigint | number
    integration_details?: JsonNullableFilter<"Integrations">
    stores?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id" | "store_id_integration_type">

  export type IntegrationsOrderByWithAggregationInput = {
    id?: SortOrder
    store_id?: SortOrder
    integration_type?: SortOrder
    status?: SortOrder
    api_key?: SortOrder
    api_secret?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    integration_details?: SortOrderInput | SortOrder
    _count?: IntegrationsCountOrderByAggregateInput
    _avg?: IntegrationsAvgOrderByAggregateInput
    _max?: IntegrationsMaxOrderByAggregateInput
    _min?: IntegrationsMinOrderByAggregateInput
    _sum?: IntegrationsSumOrderByAggregateInput
  }

  export type IntegrationsScalarWhereWithAggregatesInput = {
    AND?: IntegrationsScalarWhereWithAggregatesInput | IntegrationsScalarWhereWithAggregatesInput[]
    OR?: IntegrationsScalarWhereWithAggregatesInput[]
    NOT?: IntegrationsScalarWhereWithAggregatesInput | IntegrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Integrations"> | number
    store_id?: IntWithAggregatesFilter<"Integrations"> | number
    integration_type?: EnumIntegrationTypeWithAggregatesFilter<"Integrations"> | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeWithAggregatesFilter<"Integrations"> | $Enums.NotificationStatusType
    api_key?: StringWithAggregatesFilter<"Integrations"> | string
    api_secret?: StringNullableWithAggregatesFilter<"Integrations"> | string | null
    created_at?: BigIntWithAggregatesFilter<"Integrations"> | bigint | number
    updated_at?: BigIntWithAggregatesFilter<"Integrations"> | bigint | number
    integration_details?: JsonNullableWithAggregatesFilter<"Integrations">
  }

  export type StoresCreateInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresUpdateInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type StoresCreateManyInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
  }

  export type StoresUpdateManyMutationInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type StoresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type MembersCreateInput = {
    member_id?: string
    first_name: string
    last_name: string
    email: string
    phone?: string | null
    member_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates?: AffiliatesCreateNestedManyWithoutMembersInput
  }

  export type MembersUncheckedCreateInput = {
    id?: number
    member_id?: string
    first_name: string
    last_name: string
    email: string
    phone?: string | null
    member_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutMembersInput
  }

  export type MembersUpdateInput = {
    member_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    member_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateManyWithoutMembersNestedInput
  }

  export type MembersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    member_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    member_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUncheckedUpdateManyWithoutMembersNestedInput
  }

  export type MembersCreateManyInput = {
    id?: number
    member_id?: string
    first_name: string
    last_name: string
    email: string
    phone?: string | null
    member_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type MembersUpdateManyMutationInput = {
    member_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    member_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MembersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    member_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    member_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramsCreateInput = {
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsCreateNestedOneWithoutProgramsInput
    Orders?: OrdersCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutProgramsInput
    stores: StoresCreateNestedOneWithoutProgramsInput
    tiers?: TiersCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsUncheckedCreateInput = {
    id?: number
    store_id: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedOneWithoutProgramsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutProgramsInput
    tiers?: TiersUncheckedCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutProgramsNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgramsNestedInput
    tiers?: TiersUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutProgramsNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsCreateManyInput = {
    id?: number
    store_id: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ProgramsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TiersCreateInput = {
    tier_type: $Enums.TierType
    min_value: number
    max_value?: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint | number
    updated_at: bigint | number
    programs: ProgramsCreateNestedOneWithoutTiersInput
    stores: StoresCreateNestedOneWithoutTiersInput
  }

  export type TiersUncheckedCreateInput = {
    id?: number
    store_id: number
    program_id: number
    tier_type: $Enums.TierType
    min_value: number
    max_value?: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TiersUpdateInput = {
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    programs?: ProgramsUpdateOneRequiredWithoutTiersNestedInput
    stores?: StoresUpdateOneRequiredWithoutTiersNestedInput
  }

  export type TiersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TiersCreateManyInput = {
    id?: number
    store_id: number
    program_id: number
    tier_type: $Enums.TierType
    min_value: number
    max_value?: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TiersUpdateManyMutationInput = {
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TiersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CustomerDiscountsCreateInput = {
    discount_rate: number
    discount_options: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    discount_type: $Enums.CustomerDiscountType
    programs: ProgramsCreateNestedOneWithoutCustomer_discountsInput
    stores: StoresCreateNestedOneWithoutCustomer_discountsInput
  }

  export type CustomerDiscountsUncheckedCreateInput = {
    id?: number
    store_id: number
    program_id: number
    discount_rate: number
    discount_options: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    discount_type: $Enums.CustomerDiscountType
  }

  export type CustomerDiscountsUpdateInput = {
    discount_rate?: FloatFieldUpdateOperationsInput | number
    discount_options?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_type?: EnumCustomerDiscountTypeFieldUpdateOperationsInput | $Enums.CustomerDiscountType
    programs?: ProgramsUpdateOneRequiredWithoutCustomer_discountsNestedInput
    stores?: StoresUpdateOneRequiredWithoutCustomer_discountsNestedInput
  }

  export type CustomerDiscountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    discount_rate?: FloatFieldUpdateOperationsInput | number
    discount_options?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_type?: EnumCustomerDiscountTypeFieldUpdateOperationsInput | $Enums.CustomerDiscountType
  }

  export type CustomerDiscountsCreateManyInput = {
    id?: number
    store_id: number
    program_id: number
    discount_rate: number
    discount_options: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    discount_type: $Enums.CustomerDiscountType
  }

  export type CustomerDiscountsUpdateManyMutationInput = {
    discount_rate?: FloatFieldUpdateOperationsInput | number
    discount_options?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_type?: EnumCustomerDiscountTypeFieldUpdateOperationsInput | $Enums.CustomerDiscountType
  }

  export type CustomerDiscountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    discount_rate?: FloatFieldUpdateOperationsInput | number
    discount_options?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_type?: EnumCustomerDiscountTypeFieldUpdateOperationsInput | $Enums.CustomerDiscountType
  }

  export type OrdersCreateInput = {
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    commissions?: CommissionsCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsCreateNestedManyWithoutOrdersInput
    affiliates: AffiliatesCreateNestedOneWithoutOrdersInput
    customers: CustomersCreateNestedOneWithoutOrdersInput
    programs?: ProgramsCreateNestedOneWithoutOrdersInput
    stores: StoresCreateNestedOneWithoutOrdersInput
    activity_log?: ActivityLogCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
    commissions?: CommissionsUncheckedCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutOrdersInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUpdateInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    commissions?: CommissionsUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUpdateManyWithoutOrdersNestedInput
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrdersNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrdersNestedInput
    programs?: ProgramsUpdateOneWithoutOrdersNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrdersNestedInput
    activity_log?: ActivityLogUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    commissions?: CommissionsUncheckedUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutOrdersNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
  }

  export type OrdersUpdateManyMutationInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrdersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemsCreateInput = {
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutOrder_itemsInput
    customers: CustomersCreateNestedOneWithoutOrder_itemsInput
    orders: OrdersCreateNestedOneWithoutOrder_itemsInput
    stores: StoresCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemsUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrderItemsUpdateInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrder_itemsNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrder_itemsNestedInput
    orders?: OrdersUpdateOneRequiredWithoutOrder_itemsNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrderItemsUpdateManyMutationInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommissionsCreateInput = {
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutCommissionsInput
    orders: OrdersCreateNestedOneWithoutCommissionsInput
    stores: StoresCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionsUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    order_id: number
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CommissionsUpdateInput = {
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutCommissionsNestedInput
    orders?: OrdersUpdateOneRequiredWithoutCommissionsNestedInput
    stores?: StoresUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type CommissionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommissionsCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    order_id: number
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CommissionsUpdateManyMutationInput = {
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommissionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PayoutsCreateInput = {
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    affiliates: AffiliatesCreateNestedOneWithoutPayoutsInput
    jobs: JobsCreateNestedOneWithoutPayoutsInput
    stores: StoresCreateNestedOneWithoutPayoutsInput
    activity_log?: ActivityLogCreateNestedManyWithoutPayoutsInput
  }

  export type PayoutsUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    job_id: number
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutPayoutsInput
  }

  export type PayoutsUpdateInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    affiliates?: AffiliatesUpdateOneRequiredWithoutPayoutsNestedInput
    jobs?: JobsUpdateOneRequiredWithoutPayoutsNestedInput
    stores?: StoresUpdateOneRequiredWithoutPayoutsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutPayoutsNestedInput
  }

  export type PayoutsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    job_id?: IntFieldUpdateOperationsInput | number
    activity_log?: ActivityLogUncheckedUpdateManyWithoutPayoutsNestedInput
  }

  export type PayoutsCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    job_id: number
  }

  export type PayoutsUpdateManyMutationInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type PayoutsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    job_id?: IntFieldUpdateOperationsInput | number
  }

  export type BonusCreateInput = {
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutBonusInput
    stores: StoresCreateNestedOneWithoutBonusInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutBonusInput
  }

  export type BonusUncheckedCreateInput = {
    id?: number
    store_id: number
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutBonusInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutBonusInput
  }

  export type BonusUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutBonusNestedInput
    stores?: StoresUpdateOneRequiredWithoutBonusNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutBonusNestedInput
  }

  export type BonusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutBonusNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutBonusNestedInput
  }

  export type BonusCreateManyInput = {
    id?: number
    store_id: number
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type BonusUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type BonusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type GiftsCreateInput = {
    title: string
    description: string
    products: JsonNullValueInput | InputJsonValue
    gift_type: $Enums.GiftType
    status: $Enums.StatusType
    shipping_method: $Enums.ShippingType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutGiftsInput
    stores: StoresCreateNestedOneWithoutGiftsInput
  }

  export type GiftsUncheckedCreateInput = {
    id?: number
    store_id: number
    title: string
    description: string
    products: JsonNullValueInput | InputJsonValue
    gift_type: $Enums.GiftType
    status: $Enums.StatusType
    shipping_method: $Enums.ShippingType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutGiftsInput
  }

  export type GiftsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    products?: JsonNullValueInput | InputJsonValue
    gift_type?: EnumGiftTypeFieldUpdateOperationsInput | $Enums.GiftType
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    shipping_method?: EnumShippingTypeFieldUpdateOperationsInput | $Enums.ShippingType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutGiftsNestedInput
    stores?: StoresUpdateOneRequiredWithoutGiftsNestedInput
  }

  export type GiftsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    products?: JsonNullValueInput | InputJsonValue
    gift_type?: EnumGiftTypeFieldUpdateOperationsInput | $Enums.GiftType
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    shipping_method?: EnumShippingTypeFieldUpdateOperationsInput | $Enums.ShippingType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutGiftsNestedInput
  }

  export type GiftsCreateManyInput = {
    id?: number
    store_id: number
    title: string
    description: string
    products: JsonNullValueInput | InputJsonValue
    gift_type: $Enums.GiftType
    status: $Enums.StatusType
    shipping_method: $Enums.ShippingType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type GiftsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    products?: JsonNullValueInput | InputJsonValue
    gift_type?: EnumGiftTypeFieldUpdateOperationsInput | $Enums.GiftType
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    shipping_method?: EnumShippingTypeFieldUpdateOperationsInput | $Enums.ShippingType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type GiftsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    products?: JsonNullValueInput | InputJsonValue
    gift_type?: EnumGiftTypeFieldUpdateOperationsInput | $Enums.GiftType
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    shipping_method?: EnumShippingTypeFieldUpdateOperationsInput | $Enums.ShippingType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TransactionsCreateInput = {
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted?: boolean
    amount: number
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutTransactionsInput
    stores: StoresCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted?: boolean
    amount: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TransactionsUpdateInput = {
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutTransactionsNestedInput
    stores?: StoresUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TransactionsCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted?: boolean
    amount: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TransactionsUpdateManyMutationInput = {
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TransactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type SettingsCreateInput = {
    commission_delay?: number
    commission_approval_mode: $Enums.ApprovalModeType
    commission_calculation: $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: number | null
    primary_color?: string
    secondary_color?: string
    created_at: bigint | number
    updated_at: bigint | number
    current_email_lang?: string
    email_limit?: number
    notify_once?: boolean
    stores: StoresCreateNestedOneWithoutSettingsInput
  }

  export type SettingsUncheckedCreateInput = {
    id?: number
    store_id: number
    commission_delay?: number
    commission_approval_mode: $Enums.ApprovalModeType
    commission_calculation: $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: number | null
    primary_color?: string
    secondary_color?: string
    created_at: bigint | number
    updated_at: bigint | number
    current_email_lang?: string
    email_limit?: number
    notify_once?: boolean
  }

  export type SettingsUpdateInput = {
    commission_delay?: IntFieldUpdateOperationsInput | number
    commission_approval_mode?: EnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType
    commission_calculation?: EnumCommissionCalculationTypeFieldUpdateOperationsInput | $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    current_email_lang?: StringFieldUpdateOperationsInput | string
    email_limit?: IntFieldUpdateOperationsInput | number
    notify_once?: BoolFieldUpdateOperationsInput | boolean
    stores?: StoresUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type SettingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    commission_delay?: IntFieldUpdateOperationsInput | number
    commission_approval_mode?: EnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType
    commission_calculation?: EnumCommissionCalculationTypeFieldUpdateOperationsInput | $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    current_email_lang?: StringFieldUpdateOperationsInput | string
    email_limit?: IntFieldUpdateOperationsInput | number
    notify_once?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingsCreateManyInput = {
    id?: number
    store_id: number
    commission_delay?: number
    commission_approval_mode: $Enums.ApprovalModeType
    commission_calculation: $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: number | null
    primary_color?: string
    secondary_color?: string
    created_at: bigint | number
    updated_at: bigint | number
    current_email_lang?: string
    email_limit?: number
    notify_once?: boolean
  }

  export type SettingsUpdateManyMutationInput = {
    commission_delay?: IntFieldUpdateOperationsInput | number
    commission_approval_mode?: EnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType
    commission_calculation?: EnumCommissionCalculationTypeFieldUpdateOperationsInput | $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    current_email_lang?: StringFieldUpdateOperationsInput | string
    email_limit?: IntFieldUpdateOperationsInput | number
    notify_once?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    commission_delay?: IntFieldUpdateOperationsInput | number
    commission_approval_mode?: EnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType
    commission_calculation?: EnumCommissionCalculationTypeFieldUpdateOperationsInput | $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    current_email_lang?: StringFieldUpdateOperationsInput | string
    email_limit?: IntFieldUpdateOperationsInput | number
    notify_once?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JobsCreateInput = {
    job_metadata: JsonNullValueInput | InputJsonValue
    status: $Enums.JobsStatusType
    type: $Enums.JobType
    job_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutJobsInput
    payouts?: PayoutsCreateNestedOneWithoutJobsInput
  }

  export type JobsUncheckedCreateInput = {
    id?: number
    store_id: number
    job_metadata: JsonNullValueInput | InputJsonValue
    status: $Enums.JobsStatusType
    type: $Enums.JobType
    job_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    payouts?: PayoutsUncheckedCreateNestedOneWithoutJobsInput
  }

  export type JobsUpdateInput = {
    job_metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumJobsStatusTypeFieldUpdateOperationsInput | $Enums.JobsStatusType
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    job_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutJobsNestedInput
    payouts?: PayoutsUpdateOneWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    job_metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumJobsStatusTypeFieldUpdateOperationsInput | $Enums.JobsStatusType
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    job_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    payouts?: PayoutsUncheckedUpdateOneWithoutJobsNestedInput
  }

  export type JobsCreateManyInput = {
    id?: number
    store_id: number
    job_metadata: JsonNullValueInput | InputJsonValue
    status: $Enums.JobsStatusType
    type: $Enums.JobType
    job_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type JobsUpdateManyMutationInput = {
    job_metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumJobsStatusTypeFieldUpdateOperationsInput | $Enums.JobsStatusType
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    job_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type JobsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    job_metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumJobsStatusTypeFieldUpdateOperationsInput | $Enums.JobsStatusType
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    job_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CustomersCreateInput = {
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutCustomersInput
    stores: StoresCreateNestedOneWithoutCustomersInput
    order_items?: OrderItemsCreateNestedManyWithoutCustomersInput
    orders?: OrdersCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutCustomersInput
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUpdateInput = {
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutCustomersNestedInput
    stores?: StoresUpdateOneRequiredWithoutCustomersNestedInput
    order_items?: OrderItemsUpdateManyWithoutCustomersNestedInput
    orders?: OrdersUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    order_items?: OrderItemsUncheckedUpdateManyWithoutCustomersNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CustomersUpdateManyMutationInput = {
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CustomersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliatesCreateInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUpdateInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesCreateManyInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
  }

  export type AffiliatesUpdateManyMutationInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
  }

  export type AffiliatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
  }

  export type AffiliateProgramsCreateInput = {
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_programsInput
    programs: ProgramsCreateNestedOneWithoutAffiliate_programsInput
    stores: StoresCreateNestedOneWithoutAffiliate_programsInput
  }

  export type AffiliateProgramsUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    program_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramsUpdateInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_programsNestedInput
    programs?: ProgramsUpdateOneRequiredWithoutAffiliate_programsNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_programsNestedInput
  }

  export type AffiliateProgramsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramsCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    program_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramsUpdateManyMutationInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramHistoryCreateInput = {
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_program_historyInput
    stores: StoresCreateNestedOneWithoutAffiliate_program_historyInput
  }

  export type AffiliateProgramHistoryUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramHistoryUpdateInput = {
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_program_historyNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_program_historyNestedInput
  }

  export type AffiliateProgramHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramHistoryCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramHistoryUpdateManyMutationInput = {
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateDiscountsCreateInput = {
    discount_id: bigint | number
    discount_code: string
    is_deleted?: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_discountsInput
    stores: StoresCreateNestedOneWithoutAffiliate_discountsInput
  }

  export type AffiliateDiscountsUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    discount_id: bigint | number
    discount_code: string
    is_deleted?: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateDiscountsUpdateInput = {
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_discountsNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_discountsNestedInput
  }

  export type AffiliateDiscountsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateDiscountsCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    discount_id: bigint | number
    discount_code: string
    is_deleted?: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateDiscountsUpdateManyMutationInput = {
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateDiscountsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateGiftsCreateInput = {
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_giftsInput
    gifts: GiftsCreateNestedOneWithoutAffiliate_giftsInput
    stores: StoresCreateNestedOneWithoutAffiliate_giftsInput
  }

  export type AffiliateGiftsUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    gift_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateGiftsUpdateInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_giftsNestedInput
    gifts?: GiftsUpdateOneRequiredWithoutAffiliate_giftsNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_giftsNestedInput
  }

  export type AffiliateGiftsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    gift_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateGiftsCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    gift_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateGiftsUpdateManyMutationInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateGiftsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    gift_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateBonusCreateInput = {
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_bonusInput
    bonus: BonusCreateNestedOneWithoutAffiliate_bonusInput
    stores: StoresCreateNestedOneWithoutAffiliate_bonusInput
  }

  export type AffiliateBonusUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateBonusUpdateInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_bonusNestedInput
    bonus?: BonusUpdateOneRequiredWithoutAffiliate_bonusNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_bonusNestedInput
  }

  export type AffiliateBonusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateBonusCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateBonusUpdateManyMutationInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateBonusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramBonusCreateInput = {
    created_at: bigint | number
    updated_at: bigint | number
    bonus: BonusCreateNestedOneWithoutProgram_bonusInput
    programs: ProgramsCreateNestedOneWithoutProgram_bonusInput
    stores: StoresCreateNestedOneWithoutProgram_bonusInput
  }

  export type ProgramBonusUncheckedCreateInput = {
    id?: number
    store_id: number
    program_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ProgramBonusUpdateInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    bonus?: BonusUpdateOneRequiredWithoutProgram_bonusNestedInput
    programs?: ProgramsUpdateOneRequiredWithoutProgram_bonusNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgram_bonusNestedInput
  }

  export type ProgramBonusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramBonusCreateManyInput = {
    id?: number
    store_id: number
    program_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ProgramBonusUpdateManyMutationInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramBonusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OtpCreateInput = {
    code: number
    email: string
    expire_at: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OtpUncheckedCreateInput = {
    id?: number
    code: number
    email: string
    expire_at: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OtpUpdateInput = {
    code?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    expire_at?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OtpUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    expire_at?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OtpCreateManyInput = {
    id?: number
    code: number
    email: string
    expire_at: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OtpUpdateManyMutationInput = {
    code?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    expire_at?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    expire_at?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type NotificationsCreateInput = {
    notification_id?: string
    type: $Enums.NotificationType
    receiver_type: $Enums.NotificationReceiverType
    subject: string
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
    languages?: string
    stores: StoresCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationsUncheckedCreateInput = {
    id?: number
    notification_id?: string
    store_id: number
    type: $Enums.NotificationType
    receiver_type: $Enums.NotificationReceiverType
    subject: string
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
    languages?: string
  }

  export type NotificationsUpdateInput = {
    notification_id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFieldUpdateOperationsInput | $Enums.NotificationReceiverType
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    languages?: StringFieldUpdateOperationsInput | string
    stores?: StoresUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    notification_id?: StringFieldUpdateOperationsInput | string
    store_id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFieldUpdateOperationsInput | $Enums.NotificationReceiverType
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    languages?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationsCreateManyInput = {
    id?: number
    notification_id?: string
    store_id: number
    type: $Enums.NotificationType
    receiver_type: $Enums.NotificationReceiverType
    subject: string
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
    languages?: string
  }

  export type NotificationsUpdateManyMutationInput = {
    notification_id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFieldUpdateOperationsInput | $Enums.NotificationReceiverType
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    languages?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    notification_id?: StringFieldUpdateOperationsInput | string
    store_id?: IntFieldUpdateOperationsInput | number
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFieldUpdateOperationsInput | $Enums.NotificationReceiverType
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    languages?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityLogCreateInput = {
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
    stores: StoresCreateNestedOneWithoutActivity_logInput
    affiliates?: AffiliatesCreateNestedOneWithoutActivity_logInput
    programs?: ProgramsCreateNestedOneWithoutActivity_logInput
    orders?: OrdersCreateNestedOneWithoutActivity_logInput
    payouts?: PayoutsCreateNestedOneWithoutActivity_logInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    store_id: number
    affiliate_id?: number | null
    program_id?: number | null
    order_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type ActivityLogUpdateInput = {
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutActivity_logNestedInput
    affiliates?: AffiliatesUpdateOneWithoutActivity_logNestedInput
    programs?: ProgramsUpdateOneWithoutActivity_logNestedInput
    orders?: OrdersUpdateOneWithoutActivity_logNestedInput
    payouts?: PayoutsUpdateOneWithoutActivity_logNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    store_id: number
    affiliate_id?: number | null
    program_id?: number | null
    order_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type ActivityLogUpdateManyMutationInput = {
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MessageHistoryCreateInput = {
    status: $Enums.MessageHistoryStatusType
    referenceId: string
    metaData: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    stores: StoresCreateNestedOneWithoutMessageHistoryInput
  }

  export type MessageHistoryUncheckedCreateInput = {
    id?: number
    status: $Enums.MessageHistoryStatusType
    referenceId: string
    metaData: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    store_id: number
  }

  export type MessageHistoryUpdateInput = {
    status?: EnumMessageHistoryStatusTypeFieldUpdateOperationsInput | $Enums.MessageHistoryStatusType
    referenceId?: StringFieldUpdateOperationsInput | string
    metaData?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutMessageHistoryNestedInput
  }

  export type MessageHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumMessageHistoryStatusTypeFieldUpdateOperationsInput | $Enums.MessageHistoryStatusType
    referenceId?: StringFieldUpdateOperationsInput | string
    metaData?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    store_id?: IntFieldUpdateOperationsInput | number
  }

  export type MessageHistoryCreateManyInput = {
    id?: number
    status: $Enums.MessageHistoryStatusType
    referenceId: string
    metaData: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    store_id: number
  }

  export type MessageHistoryUpdateManyMutationInput = {
    status?: EnumMessageHistoryStatusTypeFieldUpdateOperationsInput | $Enums.MessageHistoryStatusType
    referenceId?: StringFieldUpdateOperationsInput | string
    metaData?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MessageHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumMessageHistoryStatusTypeFieldUpdateOperationsInput | $Enums.MessageHistoryStatusType
    referenceId?: StringFieldUpdateOperationsInput | string
    metaData?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    store_id?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentGatewayCreateInput = {
    payment_uuid?: string
    provider: $Enums.PaymentType
    credentials: JsonNullValueInput | InputJsonValue
    webhook_id?: string | null
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutPaymentGatewayInput
  }

  export type PaymentGatewayUncheckedCreateInput = {
    id?: number
    store_id: number
    payment_uuid?: string
    provider: $Enums.PaymentType
    credentials: JsonNullValueInput | InputJsonValue
    webhook_id?: string | null
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type PaymentGatewayUpdateInput = {
    payment_uuid?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    credentials?: JsonNullValueInput | InputJsonValue
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutPaymentGatewayNestedInput
  }

  export type PaymentGatewayUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    payment_uuid?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    credentials?: JsonNullValueInput | InputJsonValue
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PaymentGatewayCreateManyInput = {
    id?: number
    store_id: number
    payment_uuid?: string
    provider: $Enums.PaymentType
    credentials: JsonNullValueInput | InputJsonValue
    webhook_id?: string | null
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type PaymentGatewayUpdateManyMutationInput = {
    payment_uuid?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    credentials?: JsonNullValueInput | InputJsonValue
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PaymentGatewayUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    payment_uuid?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    credentials?: JsonNullValueInput | InputJsonValue
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AppSubscriptionCreateInput = {
    plan_id?: string | null
    name: string
    price: number
    status: $Enums.AppSubscriptionType
    currency_code: string
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutAppSubscriptionInput
  }

  export type AppSubscriptionUncheckedCreateInput = {
    id?: number
    store_id: number
    plan_id?: string | null
    name: string
    price: number
    status: $Enums.AppSubscriptionType
    currency_code: string
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AppSubscriptionUpdateInput = {
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumAppSubscriptionTypeFieldUpdateOperationsInput | $Enums.AppSubscriptionType
    currency_code?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutAppSubscriptionNestedInput
  }

  export type AppSubscriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumAppSubscriptionTypeFieldUpdateOperationsInput | $Enums.AppSubscriptionType
    currency_code?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AppSubscriptionCreateManyInput = {
    id?: number
    store_id: number
    plan_id?: string | null
    name: string
    price: number
    status: $Enums.AppSubscriptionType
    currency_code: string
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AppSubscriptionUpdateManyMutationInput = {
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumAppSubscriptionTypeFieldUpdateOperationsInput | $Enums.AppSubscriptionType
    currency_code?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AppSubscriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumAppSubscriptionTypeFieldUpdateOperationsInput | $Enums.AppSubscriptionType
    currency_code?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type IntegrationsCreateInput = {
    integration_type: $Enums.IntegrationType
    status: $Enums.NotificationStatusType
    api_key: string
    api_secret?: string | null
    created_at: bigint | number
    updated_at: bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
    stores: StoresCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationsUncheckedCreateInput = {
    id?: number
    store_id: number
    integration_type: $Enums.IntegrationType
    status: $Enums.NotificationStatusType
    api_key: string
    api_secret?: string | null
    created_at: bigint | number
    updated_at: bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationsUpdateInput = {
    integration_type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
    stores?: StoresUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    integration_type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationsCreateManyInput = {
    id?: number
    store_id: number
    integration_type: $Enums.IntegrationType
    status: $Enums.NotificationStatusType
    api_key: string
    api_secret?: string | null
    created_at: bigint | number
    updated_at: bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationsUpdateManyMutationInput = {
    integration_type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    integration_type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumStoreStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreStatusType | EnumStoreStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreStatusType[] | ListEnumStoreStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreStatusType[] | ListEnumStoreStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreStatusTypeFilter<$PrismaModel> | $Enums.StoreStatusType
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type AffiliateBonusListRelationFilter = {
    every?: AffiliateBonusWhereInput
    some?: AffiliateBonusWhereInput
    none?: AffiliateBonusWhereInput
  }

  export type AffiliateDiscountsListRelationFilter = {
    every?: AffiliateDiscountsWhereInput
    some?: AffiliateDiscountsWhereInput
    none?: AffiliateDiscountsWhereInput
  }

  export type AffiliateGiftsListRelationFilter = {
    every?: AffiliateGiftsWhereInput
    some?: AffiliateGiftsWhereInput
    none?: AffiliateGiftsWhereInput
  }

  export type AffiliateProgramHistoryListRelationFilter = {
    every?: AffiliateProgramHistoryWhereInput
    some?: AffiliateProgramHistoryWhereInput
    none?: AffiliateProgramHistoryWhereInput
  }

  export type AffiliateProgramsListRelationFilter = {
    every?: AffiliateProgramsWhereInput
    some?: AffiliateProgramsWhereInput
    none?: AffiliateProgramsWhereInput
  }

  export type AffiliatesListRelationFilter = {
    every?: AffiliatesWhereInput
    some?: AffiliatesWhereInput
    none?: AffiliatesWhereInput
  }

  export type AppSubscriptionNullableRelationFilter = {
    is?: AppSubscriptionWhereInput | null
    isNot?: AppSubscriptionWhereInput | null
  }

  export type BonusListRelationFilter = {
    every?: BonusWhereInput
    some?: BonusWhereInput
    none?: BonusWhereInput
  }

  export type CommissionsListRelationFilter = {
    every?: CommissionsWhereInput
    some?: CommissionsWhereInput
    none?: CommissionsWhereInput
  }

  export type CustomerDiscountsListRelationFilter = {
    every?: CustomerDiscountsWhereInput
    some?: CustomerDiscountsWhereInput
    none?: CustomerDiscountsWhereInput
  }

  export type CustomersListRelationFilter = {
    every?: CustomersWhereInput
    some?: CustomersWhereInput
    none?: CustomersWhereInput
  }

  export type GiftsListRelationFilter = {
    every?: GiftsWhereInput
    some?: GiftsWhereInput
    none?: GiftsWhereInput
  }

  export type IntegrationsListRelationFilter = {
    every?: IntegrationsWhereInput
    some?: IntegrationsWhereInput
    none?: IntegrationsWhereInput
  }

  export type JobsListRelationFilter = {
    every?: JobsWhereInput
    some?: JobsWhereInput
    none?: JobsWhereInput
  }

  export type MessageHistoryListRelationFilter = {
    every?: MessageHistoryWhereInput
    some?: MessageHistoryWhereInput
    none?: MessageHistoryWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: NotificationsWhereInput
    some?: NotificationsWhereInput
    none?: NotificationsWhereInput
  }

  export type OrderItemsListRelationFilter = {
    every?: OrderItemsWhereInput
    some?: OrderItemsWhereInput
    none?: OrderItemsWhereInput
  }

  export type OrdersListRelationFilter = {
    every?: OrdersWhereInput
    some?: OrdersWhereInput
    none?: OrdersWhereInput
  }

  export type PaymentGatewayListRelationFilter = {
    every?: PaymentGatewayWhereInput
    some?: PaymentGatewayWhereInput
    none?: PaymentGatewayWhereInput
  }

  export type PayoutsListRelationFilter = {
    every?: PayoutsWhereInput
    some?: PayoutsWhereInput
    none?: PayoutsWhereInput
  }

  export type ProgramBonusListRelationFilter = {
    every?: ProgramBonusWhereInput
    some?: ProgramBonusWhereInput
    none?: ProgramBonusWhereInput
  }

  export type ProgramsListRelationFilter = {
    every?: ProgramsWhereInput
    some?: ProgramsWhereInput
    none?: ProgramsWhereInput
  }

  export type SettingsNullableRelationFilter = {
    is?: SettingsWhereInput | null
    isNot?: SettingsWhereInput | null
  }

  export type TiersListRelationFilter = {
    every?: TiersWhereInput
    some?: TiersWhereInput
    none?: TiersWhereInput
  }

  export type TransactionsListRelationFilter = {
    every?: TransactionsWhereInput
    some?: TransactionsWhereInput
    none?: TransactionsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateBonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateDiscountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateGiftsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateProgramHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliateProgramsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AffiliatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerDiscountsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GiftsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderItemsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrdersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentGatewayOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayoutsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramBonusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TiersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoresCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    domain?: SortOrder
    myshopify_domain?: SortOrder
    email?: SortOrder
    blacklisted?: SortOrder
    currency_code?: SortOrder
    country_code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    store_details?: SortOrder
    remote_details?: SortOrder
    admin_access_token?: SortOrder
    storefront_access_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shopify_store_id?: SortOrder
    landing_page_id?: SortOrder
    portal_page_id?: SortOrder
    contact_email?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    webhook_registration_check?: SortOrder
  }

  export type StoresAvgOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shopify_store_id?: SortOrder
    landing_page_id?: SortOrder
    portal_page_id?: SortOrder
  }

  export type StoresMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    domain?: SortOrder
    myshopify_domain?: SortOrder
    email?: SortOrder
    blacklisted?: SortOrder
    currency_code?: SortOrder
    country_code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    admin_access_token?: SortOrder
    storefront_access_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shopify_store_id?: SortOrder
    landing_page_id?: SortOrder
    portal_page_id?: SortOrder
    contact_email?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    webhook_registration_check?: SortOrder
  }

  export type StoresMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    domain?: SortOrder
    myshopify_domain?: SortOrder
    email?: SortOrder
    blacklisted?: SortOrder
    currency_code?: SortOrder
    country_code?: SortOrder
    language?: SortOrder
    status?: SortOrder
    admin_access_token?: SortOrder
    storefront_access_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shopify_store_id?: SortOrder
    landing_page_id?: SortOrder
    portal_page_id?: SortOrder
    contact_email?: SortOrder
    contact_name?: SortOrder
    contact_phone?: SortOrder
    webhook_registration_check?: SortOrder
  }

  export type StoresSumOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    shopify_store_id?: SortOrder
    landing_page_id?: SortOrder
    portal_page_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumStoreStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreStatusType | EnumStoreStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreStatusType[] | ListEnumStoreStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreStatusType[] | ListEnumStoreStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoreStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumStoreStatusTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type MembersCountOrderByAggregateInput = {
    id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    member_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MembersAvgOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MembersMaxOrderByAggregateInput = {
    id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MembersMinOrderByAggregateInput = {
    id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MembersSumOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumProgramStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramStatusType | EnumProgramStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProgramStatusType[] | ListEnumProgramStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgramStatusType[] | ListEnumProgramStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProgramStatusTypeFilter<$PrismaModel> | $Enums.ProgramStatusType
  }

  export type CustomerDiscountsNullableRelationFilter = {
    is?: CustomerDiscountsWhereInput | null
    isNot?: CustomerDiscountsWhereInput | null
  }

  export type StoresRelationFilter = {
    is?: StoresWhereInput
    isNot?: StoresWhereInput
  }

  export type ProgramsStore_idTitleCompoundUniqueInput = {
    store_id: number
    title: string
  }

  export type ProgramsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currency_code?: SortOrder
    program_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProgramsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProgramsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currency_code?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProgramsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    currency_code?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProgramsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumProgramStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramStatusType | EnumProgramStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProgramStatusType[] | ListEnumProgramStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgramStatusType[] | ListEnumProgramStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProgramStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProgramStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProgramStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumProgramStatusTypeFilter<$PrismaModel>
  }

  export type EnumTierTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TierType | EnumTierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TierType[] | ListEnumTierTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TierType[] | ListEnumTierTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTierTypeFilter<$PrismaModel> | $Enums.TierType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EnumEarningTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EarningType | EnumEarningTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EarningType[] | ListEnumEarningTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EarningType[] | ListEnumEarningTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEarningTypeFilter<$PrismaModel> | $Enums.EarningType
  }

  export type ProgramsRelationFilter = {
    is?: ProgramsWhereInput
    isNot?: ProgramsWhereInput
  }

  export type TiersCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    tier_type?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    commission_type?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TiersAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TiersMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    tier_type?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    commission_type?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TiersMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    tier_type?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    commission_type?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TiersSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    min_value?: SortOrder
    max_value?: SortOrder
    commission_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumTierTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TierType | EnumTierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TierType[] | ListEnumTierTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TierType[] | ListEnumTierTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTierTypeWithAggregatesFilter<$PrismaModel> | $Enums.TierType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTierTypeFilter<$PrismaModel>
    _max?: NestedEnumTierTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumEarningTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EarningType | EnumEarningTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EarningType[] | ListEnumEarningTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EarningType[] | ListEnumEarningTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEarningTypeWithAggregatesFilter<$PrismaModel> | $Enums.EarningType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEarningTypeFilter<$PrismaModel>
    _max?: NestedEnumEarningTypeFilter<$PrismaModel>
  }

  export type EnumCustomerDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerDiscountType | EnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerDiscountType[] | ListEnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerDiscountType[] | ListEnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerDiscountTypeFilter<$PrismaModel> | $Enums.CustomerDiscountType
  }

  export type CustomerDiscountsStore_idProgram_idCompoundUniqueInput = {
    store_id: number
    program_id: number
  }

  export type CustomerDiscountsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    discount_rate?: SortOrder
    discount_options?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    discount_type?: SortOrder
  }

  export type CustomerDiscountsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    discount_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomerDiscountsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    discount_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    discount_type?: SortOrder
  }

  export type CustomerDiscountsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    discount_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    discount_type?: SortOrder
  }

  export type CustomerDiscountsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    discount_rate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumCustomerDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerDiscountType | EnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerDiscountType[] | ListEnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerDiscountType[] | ListEnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerDiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerDiscountTypeFilter<$PrismaModel>
  }

  export type EnumOrderAttributeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAttributeType | EnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAttributeType[] | ListEnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAttributeType[] | ListEnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAttributeTypeFilter<$PrismaModel> | $Enums.OrderAttributeType
  }

  export type EnumOrderStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusTypeFilter<$PrismaModel> | $Enums.OrderStatusType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CommissionsNullableRelationFilter = {
    is?: CommissionsWhereInput | null
    isNot?: CommissionsWhereInput | null
  }

  export type AffiliatesRelationFilter = {
    is?: AffiliatesWhereInput
    isNot?: AffiliatesWhereInput
  }

  export type CustomersRelationFilter = {
    is?: CustomersWhereInput
    isNot?: CustomersWhereInput
  }

  export type ProgramsNullableRelationFilter = {
    is?: ProgramsWhereInput | null
    isNot?: ProgramsWhereInput | null
  }

  export type OrdersCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    shopify_order_number?: SortOrder
    shop_order_currency_code?: SortOrder
    shop_order_amount?: SortOrder
    customer_order_currency_code?: SortOrder
    customer_order_amount?: SortOrder
    financial_status?: SortOrder
    order_details?: SortOrder
    attribute_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    program_id?: SortOrder
  }

  export type OrdersAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    shopify_order_number?: SortOrder
    shop_order_amount?: SortOrder
    customer_order_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    program_id?: SortOrder
  }

  export type OrdersMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    shopify_order_number?: SortOrder
    shop_order_currency_code?: SortOrder
    shop_order_amount?: SortOrder
    customer_order_currency_code?: SortOrder
    customer_order_amount?: SortOrder
    financial_status?: SortOrder
    attribute_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    program_id?: SortOrder
  }

  export type OrdersMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    shopify_order_number?: SortOrder
    shop_order_currency_code?: SortOrder
    shop_order_amount?: SortOrder
    customer_order_currency_code?: SortOrder
    customer_order_amount?: SortOrder
    financial_status?: SortOrder
    attribute_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    program_id?: SortOrder
  }

  export type OrdersSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    shopify_order_number?: SortOrder
    shop_order_amount?: SortOrder
    customer_order_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    program_id?: SortOrder
  }

  export type EnumOrderAttributeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAttributeType | EnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAttributeType[] | ListEnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAttributeType[] | ListEnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAttributeTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderAttributeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderAttributeTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderAttributeTypeFilter<$PrismaModel>
  }

  export type EnumOrderStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrdersRelationFilter = {
    is?: OrdersWhereInput
    isNot?: OrdersWhereInput
  }

  export type OrderItemsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    item_id?: SortOrder
    product_id?: SortOrder
    variant_id?: SortOrder
    product_title?: SortOrder
    variant_title?: SortOrder
    quantity?: SortOrder
    shop_item_currency_code?: SortOrder
    shop_item_amount?: SortOrder
    customer_item_currency_code?: SortOrder
    customer_item_amount?: SortOrder
    item_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderItemsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    item_id?: SortOrder
    product_id?: SortOrder
    variant_id?: SortOrder
    quantity?: SortOrder
    shop_item_amount?: SortOrder
    customer_item_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderItemsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    item_id?: SortOrder
    product_id?: SortOrder
    variant_id?: SortOrder
    product_title?: SortOrder
    variant_title?: SortOrder
    quantity?: SortOrder
    shop_item_currency_code?: SortOrder
    shop_item_amount?: SortOrder
    customer_item_currency_code?: SortOrder
    customer_item_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderItemsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    item_id?: SortOrder
    product_id?: SortOrder
    variant_id?: SortOrder
    product_title?: SortOrder
    variant_title?: SortOrder
    quantity?: SortOrder
    shop_item_currency_code?: SortOrder
    shop_item_amount?: SortOrder
    customer_item_currency_code?: SortOrder
    customer_item_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OrderItemsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    customer_id?: SortOrder
    order_id?: SortOrder
    item_id?: SortOrder
    product_id?: SortOrder
    variant_id?: SortOrder
    quantity?: SortOrder
    shop_item_amount?: SortOrder
    customer_item_amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeFilter<$PrismaModel> | $Enums.StatusType
  }

  export type EnumApprovalModeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalModeType | EnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumApprovalModeTypeNullableFilter<$PrismaModel> | $Enums.ApprovalModeType | null
  }

  export type CommissionsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    order_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    approval_mode?: SortOrder
    review_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommissionsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    review_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    order_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    approval_mode?: SortOrder
    review_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommissionsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    order_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    approval_mode?: SortOrder
    review_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CommissionsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    order_id?: SortOrder
    amount?: SortOrder
    review_on?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumStatusTypeFilter<$PrismaModel>
  }

  export type EnumApprovalModeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalModeType | EnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumApprovalModeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalModeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumApprovalModeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumApprovalModeTypeNullableFilter<$PrismaModel>
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type JobsRelationFilter = {
    is?: JobsWhereInput
    isNot?: JobsWhereInput
  }

  export type PayoutsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    transaction_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    payment_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
  }

  export type PayoutsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
  }

  export type PayoutsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    transaction_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
  }

  export type PayoutsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    transaction_id?: SortOrder
    currency_code?: SortOrder
    amount?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
  }

  export type PayoutsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    job_id?: SortOrder
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type EnumBonusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BonusType | EnumBonusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BonusType[] | ListEnumBonusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BonusType[] | ListEnumBonusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBonusTypeFilter<$PrismaModel> | $Enums.BonusType
  }

  export type BonusCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    bonus_associate?: SortOrder
    target_type?: SortOrder
    target_goal?: SortOrder
    bonus_type?: SortOrder
    bonus_rate?: SortOrder
    status?: SortOrder
    begin_datetime?: SortOrder
    expire_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BonusAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    target_goal?: SortOrder
    bonus_rate?: SortOrder
    begin_datetime?: SortOrder
    expire_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BonusMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    bonus_associate?: SortOrder
    target_type?: SortOrder
    target_goal?: SortOrder
    bonus_type?: SortOrder
    bonus_rate?: SortOrder
    status?: SortOrder
    begin_datetime?: SortOrder
    expire_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BonusMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    bonus_associate?: SortOrder
    target_type?: SortOrder
    target_goal?: SortOrder
    bonus_type?: SortOrder
    bonus_rate?: SortOrder
    status?: SortOrder
    begin_datetime?: SortOrder
    expire_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BonusSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    target_goal?: SortOrder
    bonus_rate?: SortOrder
    begin_datetime?: SortOrder
    expire_datetime?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumBonusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BonusType | EnumBonusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BonusType[] | ListEnumBonusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BonusType[] | ListEnumBonusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBonusTypeWithAggregatesFilter<$PrismaModel> | $Enums.BonusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBonusTypeFilter<$PrismaModel>
    _max?: NestedEnumBonusTypeFilter<$PrismaModel>
  }

  export type EnumGiftTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GiftType | EnumGiftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GiftType[] | ListEnumGiftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GiftType[] | ListEnumGiftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGiftTypeFilter<$PrismaModel> | $Enums.GiftType
  }

  export type EnumShippingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingType | EnumShippingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingType[] | ListEnumShippingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingType[] | ListEnumShippingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingTypeFilter<$PrismaModel> | $Enums.ShippingType
  }

  export type GiftsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    products?: SortOrder
    gift_type?: SortOrder
    status?: SortOrder
    shipping_method?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type GiftsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type GiftsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    gift_type?: SortOrder
    status?: SortOrder
    shipping_method?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type GiftsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    gift_type?: SortOrder
    status?: SortOrder
    shipping_method?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type GiftsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumGiftTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GiftType | EnumGiftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GiftType[] | ListEnumGiftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GiftType[] | ListEnumGiftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGiftTypeWithAggregatesFilter<$PrismaModel> | $Enums.GiftType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGiftTypeFilter<$PrismaModel>
    _max?: NestedEnumGiftTypeFilter<$PrismaModel>
  }

  export type EnumShippingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingType | EnumShippingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingType[] | ListEnumShippingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingType[] | ListEnumShippingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShippingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShippingTypeFilter<$PrismaModel>
    _max?: NestedEnumShippingTypeFilter<$PrismaModel>
  }

  export type EnumTransactionReferenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReferenceType | EnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReferenceType[] | ListEnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionReferenceType[] | ListEnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionReferenceTypeFilter<$PrismaModel> | $Enums.TransactionReferenceType
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type TransactionsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    reference_type?: SortOrder
    reference_id?: SortOrder
    currency_code?: SortOrder
    type?: SortOrder
    is_reverted?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    reference_type?: SortOrder
    reference_id?: SortOrder
    currency_code?: SortOrder
    type?: SortOrder
    is_reverted?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    reference_type?: SortOrder
    reference_id?: SortOrder
    currency_code?: SortOrder
    type?: SortOrder
    is_reverted?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumTransactionReferenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReferenceType | EnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReferenceType[] | ListEnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionReferenceType[] | ListEnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionReferenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionReferenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionReferenceTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionReferenceTypeFilter<$PrismaModel>
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumApprovalModeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalModeType | EnumApprovalModeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalModeTypeFilter<$PrismaModel> | $Enums.ApprovalModeType
  }

  export type EnumCommissionCalculationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionCalculationType | EnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionCalculationType[] | ListEnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionCalculationType[] | ListEnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionCalculationTypeFilter<$PrismaModel> | $Enums.CommissionCalculationType
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    commission_delay?: SortOrder
    commission_approval_mode?: SortOrder
    commission_calculation?: SortOrder
    details?: SortOrder
    min_threshold?: SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    current_email_lang?: SortOrder
    email_limit?: SortOrder
    notify_once?: SortOrder
  }

  export type SettingsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    commission_delay?: SortOrder
    min_threshold?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_limit?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    commission_delay?: SortOrder
    commission_approval_mode?: SortOrder
    commission_calculation?: SortOrder
    min_threshold?: SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    current_email_lang?: SortOrder
    email_limit?: SortOrder
    notify_once?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    commission_delay?: SortOrder
    commission_approval_mode?: SortOrder
    commission_calculation?: SortOrder
    min_threshold?: SortOrder
    primary_color?: SortOrder
    secondary_color?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    current_email_lang?: SortOrder
    email_limit?: SortOrder
    notify_once?: SortOrder
  }

  export type SettingsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    commission_delay?: SortOrder
    min_threshold?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email_limit?: SortOrder
  }

  export type EnumApprovalModeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalModeType | EnumApprovalModeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalModeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalModeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalModeTypeFilter<$PrismaModel>
    _max?: NestedEnumApprovalModeTypeFilter<$PrismaModel>
  }

  export type EnumCommissionCalculationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionCalculationType | EnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionCalculationType[] | ListEnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionCalculationType[] | ListEnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionCalculationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommissionCalculationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommissionCalculationTypeFilter<$PrismaModel>
    _max?: NestedEnumCommissionCalculationTypeFilter<$PrismaModel>
  }

  export type EnumJobsStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsStatusType | EnumJobsStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobsStatusType[] | ListEnumJobsStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobsStatusType[] | ListEnumJobsStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobsStatusTypeFilter<$PrismaModel> | $Enums.JobsStatusType
  }

  export type EnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type PayoutsNullableRelationFilter = {
    is?: PayoutsWhereInput | null
    isNot?: PayoutsWhereInput | null
  }

  export type JobsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    job_metadata?: SortOrder
    status?: SortOrder
    type?: SortOrder
    job_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type JobsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type JobsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type JobsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    status?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type JobsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumJobsStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsStatusType | EnumJobsStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobsStatusType[] | ListEnumJobsStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobsStatusType[] | ListEnumJobsStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobsStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobsStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumJobsStatusTypeFilter<$PrismaModel>
  }

  export type EnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type EnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type CustomersStore_idAffiliate_idEmailCompoundUniqueInput = {
    store_id: number
    affiliate_id: number
    email: string
  }

  export type CustomersStore_idAffiliate_idPhoneCompoundUniqueInput = {
    store_id: number
    affiliate_id: number
    phone: string
  }

  export type CustomersCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    shopify_customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    contact_type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    customer_details?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomersAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    shopify_customer_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomersMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    shopify_customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    contact_type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomersMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    shopify_customer_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    contact_type?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type CustomersSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    shopify_customer_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type EnumAffiliateStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateStatusType | EnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateStatusType[] | ListEnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateStatusType[] | ListEnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateStatusTypeFilter<$PrismaModel> | $Enums.AffiliateStatusType
  }

  export type EnumAffiliateSourceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateSourceType | EnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AffiliateSourceType[] | ListEnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AffiliateSourceType[] | ListEnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAffiliateSourceTypeNullableFilter<$PrismaModel> | $Enums.AffiliateSourceType | null
  }

  export type MembersRelationFilter = {
    is?: MembersWhereInput
    isNot?: MembersWhereInput
  }

  export type AffiliatesStore_idPhoneCompoundUniqueInput = {
    store_id: number
    phone: string
  }

  export type AffiliatesStore_idMember_idCompoundUniqueInput = {
    store_id: number
    member_id: number
  }

  export type AffiliatesStore_idReferral_codeCompoundUniqueInput = {
    store_id: number
    referral_code: string
  }

  export type AffiliatesCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    referral_code?: SortOrder
    status?: SortOrder
    affiliate_details?: SortOrder
    payout_requested?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    source?: SortOrder
  }

  export type AffiliatesAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    member_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliatesMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    referral_code?: SortOrder
    status?: SortOrder
    payout_requested?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    source?: SortOrder
  }

  export type AffiliatesMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    member_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    phone?: SortOrder
    referral_code?: SortOrder
    status?: SortOrder
    payout_requested?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    source?: SortOrder
  }

  export type AffiliatesSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    member_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumAffiliateStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateStatusType | EnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateStatusType[] | ListEnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateStatusType[] | ListEnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAffiliateStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumAffiliateStatusTypeFilter<$PrismaModel>
  }

  export type EnumAffiliateSourceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateSourceType | EnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AffiliateSourceType[] | ListEnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AffiliateSourceType[] | ListEnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAffiliateSourceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateSourceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAffiliateSourceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAffiliateSourceTypeNullableFilter<$PrismaModel>
  }

  export type AffiliateProgramsStore_idAffiliate_idCompoundUniqueInput = {
    store_id: number
    affiliate_id: number
  }

  export type AffiliateProgramsStore_idAffiliate_idProgram_idCompoundUniqueInput = {
    store_id: number
    affiliate_id: number
    program_id: number
  }

  export type AffiliateProgramsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProgramsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProgramsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProgramsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProgramsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumProgramHistoryStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramHistoryStatusType | EnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProgramHistoryStatusType[] | ListEnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgramHistoryStatusType[] | ListEnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProgramHistoryStatusTypeFilter<$PrismaModel> | $Enums.ProgramHistoryStatusType
  }

  export type AffiliateProgramHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    program_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProgramHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProgramHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    program_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProgramHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    program_name?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateProgramHistorySumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumProgramHistoryStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramHistoryStatusType | EnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProgramHistoryStatusType[] | ListEnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgramHistoryStatusType[] | ListEnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProgramHistoryStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProgramHistoryStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProgramHistoryStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumProgramHistoryStatusTypeFilter<$PrismaModel>
  }

  export type EnumDiscountStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountStatusType | EnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountStatusType[] | ListEnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountStatusType[] | ListEnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountStatusTypeFilter<$PrismaModel> | $Enums.DiscountStatusType
  }

  export type AffiliateDiscountsStore_idAffiliate_idDiscount_idCompoundUniqueInput = {
    store_id: number
    affiliate_id: number
    discount_id: bigint | number
  }

  export type AffiliateDiscountsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    discount_id?: SortOrder
    discount_code?: SortOrder
    is_deleted?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateDiscountsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    discount_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateDiscountsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    discount_id?: SortOrder
    discount_code?: SortOrder
    is_deleted?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateDiscountsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    discount_id?: SortOrder
    discount_code?: SortOrder
    is_deleted?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateDiscountsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    discount_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumDiscountStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountStatusType | EnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountStatusType[] | ListEnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountStatusType[] | ListEnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountStatusTypeFilter<$PrismaModel>
  }

  export type GiftsRelationFilter = {
    is?: GiftsWhereInput
    isNot?: GiftsWhereInput
  }

  export type AffiliateGiftsStore_idAffiliate_idGift_idCompoundUniqueInput = {
    store_id: number
    affiliate_id: number
    gift_id: number
  }

  export type AffiliateGiftsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    gift_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateGiftsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    gift_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateGiftsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    gift_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateGiftsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    gift_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateGiftsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    gift_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BonusRelationFilter = {
    is?: BonusWhereInput
    isNot?: BonusWhereInput
  }

  export type AffiliateBonusStore_idAffiliate_idBonus_idCompoundUniqueInput = {
    store_id: number
    affiliate_id: number
    bonus_id: number
  }

  export type AffiliateBonusCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateBonusAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateBonusMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AffiliateBonusSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProgramBonusStore_idProgram_idBonus_idCompoundUniqueInput = {
    store_id: number
    program_id: number
    bonus_id: number
  }

  export type ProgramBonusCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProgramBonusAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProgramBonusMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProgramBonusMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProgramBonusSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    program_id?: SortOrder
    bonus_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    expire_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OtpAvgOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expire_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    expire_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    email?: SortOrder
    expire_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type OtpSumOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    expire_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type EnumNotificationReceiverTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationReceiverType | EnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationReceiverType[] | ListEnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationReceiverType[] | ListEnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationReceiverTypeFilter<$PrismaModel> | $Enums.NotificationReceiverType
  }

  export type EnumNotificationStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatusType | EnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatusType[] | ListEnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatusType[] | ListEnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusTypeFilter<$PrismaModel> | $Enums.NotificationStatusType
  }

  export type NotificationsStore_idTypeReceiver_typeLanguagesCompoundUniqueInput = {
    store_id: number
    type: $Enums.NotificationType
    receiver_type: $Enums.NotificationReceiverType
    languages: string
  }

  export type NotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    store_id?: SortOrder
    type?: SortOrder
    receiver_type?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    languages?: SortOrder
  }

  export type NotificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type NotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    store_id?: SortOrder
    type?: SortOrder
    receiver_type?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    languages?: SortOrder
  }

  export type NotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    notification_id?: SortOrder
    store_id?: SortOrder
    type?: SortOrder
    receiver_type?: SortOrder
    subject?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    languages?: SortOrder
  }

  export type NotificationsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumNotificationReceiverTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationReceiverType | EnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationReceiverType[] | ListEnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationReceiverType[] | ListEnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationReceiverTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationReceiverType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationReceiverTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationReceiverTypeFilter<$PrismaModel>
  }

  export type EnumNotificationStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatusType | EnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatusType[] | ListEnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatusType[] | ListEnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusTypeFilter<$PrismaModel>
  }

  export type EnumActivityEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityEntityType | EnumActivityEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityEntityTypeFilter<$PrismaModel> | $Enums.ActivityEntityType
  }

  export type AffiliatesNullableRelationFilter = {
    is?: AffiliatesWhereInput | null
    isNot?: AffiliatesWhereInput | null
  }

  export type OrdersNullableRelationFilter = {
    is?: OrdersWhereInput | null
    isNot?: OrdersWhereInput | null
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    order_id?: SortOrder
    payout_id?: SortOrder
    entity_type?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    order_id?: SortOrder
    payout_id?: SortOrder
    created_at?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    order_id?: SortOrder
    payout_id?: SortOrder
    entity_type?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    order_id?: SortOrder
    payout_id?: SortOrder
    entity_type?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    affiliate_id?: SortOrder
    program_id?: SortOrder
    order_id?: SortOrder
    payout_id?: SortOrder
    created_at?: SortOrder
  }

  export type EnumActivityEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityEntityType | EnumActivityEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityEntityTypeFilter<$PrismaModel>
  }

  export type EnumMessageHistoryStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageHistoryStatusType | EnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageHistoryStatusType[] | ListEnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageHistoryStatusType[] | ListEnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageHistoryStatusTypeFilter<$PrismaModel> | $Enums.MessageHistoryStatusType
  }

  export type MessageHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    referenceId?: SortOrder
    metaData?: SortOrder
    created_at?: SortOrder
    store_id?: SortOrder
  }

  export type MessageHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    store_id?: SortOrder
  }

  export type MessageHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    referenceId?: SortOrder
    created_at?: SortOrder
    store_id?: SortOrder
  }

  export type MessageHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    referenceId?: SortOrder
    created_at?: SortOrder
    store_id?: SortOrder
  }

  export type MessageHistorySumOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    store_id?: SortOrder
  }

  export type EnumMessageHistoryStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageHistoryStatusType | EnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageHistoryStatusType[] | ListEnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageHistoryStatusType[] | ListEnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageHistoryStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageHistoryStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageHistoryStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageHistoryStatusTypeFilter<$PrismaModel>
  }

  export type PaymentGatewayStore_idProviderCompoundUniqueInput = {
    store_id: number
    provider: $Enums.PaymentType
  }

  export type PaymentGatewayCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    payment_uuid?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    webhook_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentGatewayAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentGatewayMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    payment_uuid?: SortOrder
    provider?: SortOrder
    webhook_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentGatewayMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    payment_uuid?: SortOrder
    provider?: SortOrder
    webhook_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentGatewaySumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumAppSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppSubscriptionType | EnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppSubscriptionType[] | ListEnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppSubscriptionType[] | ListEnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppSubscriptionTypeFilter<$PrismaModel> | $Enums.AppSubscriptionType
  }

  export type AppSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    plan_id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    status?: SortOrder
    currency_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AppSubscriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AppSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    plan_id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    status?: SortOrder
    currency_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AppSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    plan_id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    status?: SortOrder
    currency_code?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type AppSubscriptionSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumAppSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppSubscriptionType | EnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppSubscriptionType[] | ListEnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppSubscriptionType[] | ListEnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppSubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumAppSubscriptionTypeFilter<$PrismaModel>
  }

  export type EnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type IntegrationsStore_idIntegration_typeCompoundUniqueInput = {
    store_id: number
    integration_type: $Enums.IntegrationType
  }

  export type IntegrationsCountOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    integration_type?: SortOrder
    status?: SortOrder
    api_key?: SortOrder
    api_secret?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    integration_details?: SortOrder
  }

  export type IntegrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntegrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    integration_type?: SortOrder
    status?: SortOrder
    api_key?: SortOrder
    api_secret?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntegrationsMinOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    integration_type?: SortOrder
    status?: SortOrder
    api_key?: SortOrder
    api_secret?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type IntegrationsSumOrderByAggregateInput = {
    id?: SortOrder
    store_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type ActivityLogCreateNestedManyWithoutStoresInput = {
    create?: XOR<ActivityLogCreateWithoutStoresInput, ActivityLogUncheckedCreateWithoutStoresInput> | ActivityLogCreateWithoutStoresInput[] | ActivityLogUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutStoresInput | ActivityLogCreateOrConnectWithoutStoresInput[]
    createMany?: ActivityLogCreateManyStoresInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AffiliateBonusCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateBonusCreateWithoutStoresInput, AffiliateBonusUncheckedCreateWithoutStoresInput> | AffiliateBonusCreateWithoutStoresInput[] | AffiliateBonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutStoresInput | AffiliateBonusCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateBonusCreateManyStoresInputEnvelope
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
  }

  export type AffiliateDiscountsCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateDiscountsCreateWithoutStoresInput, AffiliateDiscountsUncheckedCreateWithoutStoresInput> | AffiliateDiscountsCreateWithoutStoresInput[] | AffiliateDiscountsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateDiscountsCreateOrConnectWithoutStoresInput | AffiliateDiscountsCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateDiscountsCreateManyStoresInputEnvelope
    connect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
  }

  export type AffiliateGiftsCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateGiftsCreateWithoutStoresInput, AffiliateGiftsUncheckedCreateWithoutStoresInput> | AffiliateGiftsCreateWithoutStoresInput[] | AffiliateGiftsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutStoresInput | AffiliateGiftsCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateGiftsCreateManyStoresInputEnvelope
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
  }

  export type AffiliateProgramHistoryCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateProgramHistoryCreateWithoutStoresInput, AffiliateProgramHistoryUncheckedCreateWithoutStoresInput> | AffiliateProgramHistoryCreateWithoutStoresInput[] | AffiliateProgramHistoryUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateProgramHistoryCreateOrConnectWithoutStoresInput | AffiliateProgramHistoryCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateProgramHistoryCreateManyStoresInputEnvelope
    connect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
  }

  export type AffiliateProgramsCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateProgramsCreateWithoutStoresInput, AffiliateProgramsUncheckedCreateWithoutStoresInput> | AffiliateProgramsCreateWithoutStoresInput[] | AffiliateProgramsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutStoresInput | AffiliateProgramsCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateProgramsCreateManyStoresInputEnvelope
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
  }

  export type AffiliatesCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliatesCreateWithoutStoresInput, AffiliatesUncheckedCreateWithoutStoresInput> | AffiliatesCreateWithoutStoresInput[] | AffiliatesUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliatesCreateOrConnectWithoutStoresInput | AffiliatesCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliatesCreateManyStoresInputEnvelope
    connect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
  }

  export type AppSubscriptionCreateNestedOneWithoutStoresInput = {
    create?: XOR<AppSubscriptionCreateWithoutStoresInput, AppSubscriptionUncheckedCreateWithoutStoresInput>
    connectOrCreate?: AppSubscriptionCreateOrConnectWithoutStoresInput
    connect?: AppSubscriptionWhereUniqueInput
  }

  export type BonusCreateNestedManyWithoutStoresInput = {
    create?: XOR<BonusCreateWithoutStoresInput, BonusUncheckedCreateWithoutStoresInput> | BonusCreateWithoutStoresInput[] | BonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutStoresInput | BonusCreateOrConnectWithoutStoresInput[]
    createMany?: BonusCreateManyStoresInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type CommissionsCreateNestedManyWithoutStoresInput = {
    create?: XOR<CommissionsCreateWithoutStoresInput, CommissionsUncheckedCreateWithoutStoresInput> | CommissionsCreateWithoutStoresInput[] | CommissionsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CommissionsCreateOrConnectWithoutStoresInput | CommissionsCreateOrConnectWithoutStoresInput[]
    createMany?: CommissionsCreateManyStoresInputEnvelope
    connect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
  }

  export type CustomerDiscountsCreateNestedManyWithoutStoresInput = {
    create?: XOR<CustomerDiscountsCreateWithoutStoresInput, CustomerDiscountsUncheckedCreateWithoutStoresInput> | CustomerDiscountsCreateWithoutStoresInput[] | CustomerDiscountsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CustomerDiscountsCreateOrConnectWithoutStoresInput | CustomerDiscountsCreateOrConnectWithoutStoresInput[]
    createMany?: CustomerDiscountsCreateManyStoresInputEnvelope
    connect?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
  }

  export type CustomersCreateNestedManyWithoutStoresInput = {
    create?: XOR<CustomersCreateWithoutStoresInput, CustomersUncheckedCreateWithoutStoresInput> | CustomersCreateWithoutStoresInput[] | CustomersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutStoresInput | CustomersCreateOrConnectWithoutStoresInput[]
    createMany?: CustomersCreateManyStoresInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type GiftsCreateNestedManyWithoutStoresInput = {
    create?: XOR<GiftsCreateWithoutStoresInput, GiftsUncheckedCreateWithoutStoresInput> | GiftsCreateWithoutStoresInput[] | GiftsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: GiftsCreateOrConnectWithoutStoresInput | GiftsCreateOrConnectWithoutStoresInput[]
    createMany?: GiftsCreateManyStoresInputEnvelope
    connect?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
  }

  export type IntegrationsCreateNestedManyWithoutStoresInput = {
    create?: XOR<IntegrationsCreateWithoutStoresInput, IntegrationsUncheckedCreateWithoutStoresInput> | IntegrationsCreateWithoutStoresInput[] | IntegrationsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: IntegrationsCreateOrConnectWithoutStoresInput | IntegrationsCreateOrConnectWithoutStoresInput[]
    createMany?: IntegrationsCreateManyStoresInputEnvelope
    connect?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
  }

  export type JobsCreateNestedManyWithoutStoresInput = {
    create?: XOR<JobsCreateWithoutStoresInput, JobsUncheckedCreateWithoutStoresInput> | JobsCreateWithoutStoresInput[] | JobsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutStoresInput | JobsCreateOrConnectWithoutStoresInput[]
    createMany?: JobsCreateManyStoresInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type MessageHistoryCreateNestedManyWithoutStoresInput = {
    create?: XOR<MessageHistoryCreateWithoutStoresInput, MessageHistoryUncheckedCreateWithoutStoresInput> | MessageHistoryCreateWithoutStoresInput[] | MessageHistoryUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: MessageHistoryCreateOrConnectWithoutStoresInput | MessageHistoryCreateOrConnectWithoutStoresInput[]
    createMany?: MessageHistoryCreateManyStoresInputEnvelope
    connect?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
  }

  export type NotificationsCreateNestedManyWithoutStoresInput = {
    create?: XOR<NotificationsCreateWithoutStoresInput, NotificationsUncheckedCreateWithoutStoresInput> | NotificationsCreateWithoutStoresInput[] | NotificationsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutStoresInput | NotificationsCreateOrConnectWithoutStoresInput[]
    createMany?: NotificationsCreateManyStoresInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type OrderItemsCreateNestedManyWithoutStoresInput = {
    create?: XOR<OrderItemsCreateWithoutStoresInput, OrderItemsUncheckedCreateWithoutStoresInput> | OrderItemsCreateWithoutStoresInput[] | OrderItemsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutStoresInput | OrderItemsCreateOrConnectWithoutStoresInput[]
    createMany?: OrderItemsCreateManyStoresInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type OrdersCreateNestedManyWithoutStoresInput = {
    create?: XOR<OrdersCreateWithoutStoresInput, OrdersUncheckedCreateWithoutStoresInput> | OrdersCreateWithoutStoresInput[] | OrdersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutStoresInput | OrdersCreateOrConnectWithoutStoresInput[]
    createMany?: OrdersCreateManyStoresInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type PaymentGatewayCreateNestedManyWithoutStoresInput = {
    create?: XOR<PaymentGatewayCreateWithoutStoresInput, PaymentGatewayUncheckedCreateWithoutStoresInput> | PaymentGatewayCreateWithoutStoresInput[] | PaymentGatewayUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: PaymentGatewayCreateOrConnectWithoutStoresInput | PaymentGatewayCreateOrConnectWithoutStoresInput[]
    createMany?: PaymentGatewayCreateManyStoresInputEnvelope
    connect?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
  }

  export type PayoutsCreateNestedManyWithoutStoresInput = {
    create?: XOR<PayoutsCreateWithoutStoresInput, PayoutsUncheckedCreateWithoutStoresInput> | PayoutsCreateWithoutStoresInput[] | PayoutsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: PayoutsCreateOrConnectWithoutStoresInput | PayoutsCreateOrConnectWithoutStoresInput[]
    createMany?: PayoutsCreateManyStoresInputEnvelope
    connect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
  }

  export type ProgramBonusCreateNestedManyWithoutStoresInput = {
    create?: XOR<ProgramBonusCreateWithoutStoresInput, ProgramBonusUncheckedCreateWithoutStoresInput> | ProgramBonusCreateWithoutStoresInput[] | ProgramBonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutStoresInput | ProgramBonusCreateOrConnectWithoutStoresInput[]
    createMany?: ProgramBonusCreateManyStoresInputEnvelope
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
  }

  export type ProgramsCreateNestedManyWithoutStoresInput = {
    create?: XOR<ProgramsCreateWithoutStoresInput, ProgramsUncheckedCreateWithoutStoresInput> | ProgramsCreateWithoutStoresInput[] | ProgramsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ProgramsCreateOrConnectWithoutStoresInput | ProgramsCreateOrConnectWithoutStoresInput[]
    createMany?: ProgramsCreateManyStoresInputEnvelope
    connect?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
  }

  export type SettingsCreateNestedOneWithoutStoresInput = {
    create?: XOR<SettingsCreateWithoutStoresInput, SettingsUncheckedCreateWithoutStoresInput>
    connectOrCreate?: SettingsCreateOrConnectWithoutStoresInput
    connect?: SettingsWhereUniqueInput
  }

  export type TiersCreateNestedManyWithoutStoresInput = {
    create?: XOR<TiersCreateWithoutStoresInput, TiersUncheckedCreateWithoutStoresInput> | TiersCreateWithoutStoresInput[] | TiersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: TiersCreateOrConnectWithoutStoresInput | TiersCreateOrConnectWithoutStoresInput[]
    createMany?: TiersCreateManyStoresInputEnvelope
    connect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
  }

  export type TransactionsCreateNestedManyWithoutStoresInput = {
    create?: XOR<TransactionsCreateWithoutStoresInput, TransactionsUncheckedCreateWithoutStoresInput> | TransactionsCreateWithoutStoresInput[] | TransactionsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutStoresInput | TransactionsCreateOrConnectWithoutStoresInput[]
    createMany?: TransactionsCreateManyStoresInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<ActivityLogCreateWithoutStoresInput, ActivityLogUncheckedCreateWithoutStoresInput> | ActivityLogCreateWithoutStoresInput[] | ActivityLogUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutStoresInput | ActivityLogCreateOrConnectWithoutStoresInput[]
    createMany?: ActivityLogCreateManyStoresInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateBonusCreateWithoutStoresInput, AffiliateBonusUncheckedCreateWithoutStoresInput> | AffiliateBonusCreateWithoutStoresInput[] | AffiliateBonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutStoresInput | AffiliateBonusCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateBonusCreateManyStoresInputEnvelope
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
  }

  export type AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateDiscountsCreateWithoutStoresInput, AffiliateDiscountsUncheckedCreateWithoutStoresInput> | AffiliateDiscountsCreateWithoutStoresInput[] | AffiliateDiscountsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateDiscountsCreateOrConnectWithoutStoresInput | AffiliateDiscountsCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateDiscountsCreateManyStoresInputEnvelope
    connect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
  }

  export type AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateGiftsCreateWithoutStoresInput, AffiliateGiftsUncheckedCreateWithoutStoresInput> | AffiliateGiftsCreateWithoutStoresInput[] | AffiliateGiftsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutStoresInput | AffiliateGiftsCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateGiftsCreateManyStoresInputEnvelope
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
  }

  export type AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateProgramHistoryCreateWithoutStoresInput, AffiliateProgramHistoryUncheckedCreateWithoutStoresInput> | AffiliateProgramHistoryCreateWithoutStoresInput[] | AffiliateProgramHistoryUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateProgramHistoryCreateOrConnectWithoutStoresInput | AffiliateProgramHistoryCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateProgramHistoryCreateManyStoresInputEnvelope
    connect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
  }

  export type AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliateProgramsCreateWithoutStoresInput, AffiliateProgramsUncheckedCreateWithoutStoresInput> | AffiliateProgramsCreateWithoutStoresInput[] | AffiliateProgramsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutStoresInput | AffiliateProgramsCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliateProgramsCreateManyStoresInputEnvelope
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
  }

  export type AffiliatesUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<AffiliatesCreateWithoutStoresInput, AffiliatesUncheckedCreateWithoutStoresInput> | AffiliatesCreateWithoutStoresInput[] | AffiliatesUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliatesCreateOrConnectWithoutStoresInput | AffiliatesCreateOrConnectWithoutStoresInput[]
    createMany?: AffiliatesCreateManyStoresInputEnvelope
    connect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
  }

  export type AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput = {
    create?: XOR<AppSubscriptionCreateWithoutStoresInput, AppSubscriptionUncheckedCreateWithoutStoresInput>
    connectOrCreate?: AppSubscriptionCreateOrConnectWithoutStoresInput
    connect?: AppSubscriptionWhereUniqueInput
  }

  export type BonusUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<BonusCreateWithoutStoresInput, BonusUncheckedCreateWithoutStoresInput> | BonusCreateWithoutStoresInput[] | BonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutStoresInput | BonusCreateOrConnectWithoutStoresInput[]
    createMany?: BonusCreateManyStoresInputEnvelope
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
  }

  export type CommissionsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<CommissionsCreateWithoutStoresInput, CommissionsUncheckedCreateWithoutStoresInput> | CommissionsCreateWithoutStoresInput[] | CommissionsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CommissionsCreateOrConnectWithoutStoresInput | CommissionsCreateOrConnectWithoutStoresInput[]
    createMany?: CommissionsCreateManyStoresInputEnvelope
    connect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
  }

  export type CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<CustomerDiscountsCreateWithoutStoresInput, CustomerDiscountsUncheckedCreateWithoutStoresInput> | CustomerDiscountsCreateWithoutStoresInput[] | CustomerDiscountsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CustomerDiscountsCreateOrConnectWithoutStoresInput | CustomerDiscountsCreateOrConnectWithoutStoresInput[]
    createMany?: CustomerDiscountsCreateManyStoresInputEnvelope
    connect?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
  }

  export type CustomersUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<CustomersCreateWithoutStoresInput, CustomersUncheckedCreateWithoutStoresInput> | CustomersCreateWithoutStoresInput[] | CustomersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutStoresInput | CustomersCreateOrConnectWithoutStoresInput[]
    createMany?: CustomersCreateManyStoresInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type GiftsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<GiftsCreateWithoutStoresInput, GiftsUncheckedCreateWithoutStoresInput> | GiftsCreateWithoutStoresInput[] | GiftsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: GiftsCreateOrConnectWithoutStoresInput | GiftsCreateOrConnectWithoutStoresInput[]
    createMany?: GiftsCreateManyStoresInputEnvelope
    connect?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
  }

  export type IntegrationsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<IntegrationsCreateWithoutStoresInput, IntegrationsUncheckedCreateWithoutStoresInput> | IntegrationsCreateWithoutStoresInput[] | IntegrationsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: IntegrationsCreateOrConnectWithoutStoresInput | IntegrationsCreateOrConnectWithoutStoresInput[]
    createMany?: IntegrationsCreateManyStoresInputEnvelope
    connect?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
  }

  export type JobsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<JobsCreateWithoutStoresInput, JobsUncheckedCreateWithoutStoresInput> | JobsCreateWithoutStoresInput[] | JobsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutStoresInput | JobsCreateOrConnectWithoutStoresInput[]
    createMany?: JobsCreateManyStoresInputEnvelope
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
  }

  export type MessageHistoryUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<MessageHistoryCreateWithoutStoresInput, MessageHistoryUncheckedCreateWithoutStoresInput> | MessageHistoryCreateWithoutStoresInput[] | MessageHistoryUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: MessageHistoryCreateOrConnectWithoutStoresInput | MessageHistoryCreateOrConnectWithoutStoresInput[]
    createMany?: MessageHistoryCreateManyStoresInputEnvelope
    connect?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
  }

  export type NotificationsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<NotificationsCreateWithoutStoresInput, NotificationsUncheckedCreateWithoutStoresInput> | NotificationsCreateWithoutStoresInput[] | NotificationsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutStoresInput | NotificationsCreateOrConnectWithoutStoresInput[]
    createMany?: NotificationsCreateManyStoresInputEnvelope
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
  }

  export type OrderItemsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<OrderItemsCreateWithoutStoresInput, OrderItemsUncheckedCreateWithoutStoresInput> | OrderItemsCreateWithoutStoresInput[] | OrderItemsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutStoresInput | OrderItemsCreateOrConnectWithoutStoresInput[]
    createMany?: OrderItemsCreateManyStoresInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<OrdersCreateWithoutStoresInput, OrdersUncheckedCreateWithoutStoresInput> | OrdersCreateWithoutStoresInput[] | OrdersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutStoresInput | OrdersCreateOrConnectWithoutStoresInput[]
    createMany?: OrdersCreateManyStoresInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<PaymentGatewayCreateWithoutStoresInput, PaymentGatewayUncheckedCreateWithoutStoresInput> | PaymentGatewayCreateWithoutStoresInput[] | PaymentGatewayUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: PaymentGatewayCreateOrConnectWithoutStoresInput | PaymentGatewayCreateOrConnectWithoutStoresInput[]
    createMany?: PaymentGatewayCreateManyStoresInputEnvelope
    connect?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
  }

  export type PayoutsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<PayoutsCreateWithoutStoresInput, PayoutsUncheckedCreateWithoutStoresInput> | PayoutsCreateWithoutStoresInput[] | PayoutsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: PayoutsCreateOrConnectWithoutStoresInput | PayoutsCreateOrConnectWithoutStoresInput[]
    createMany?: PayoutsCreateManyStoresInputEnvelope
    connect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
  }

  export type ProgramBonusUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<ProgramBonusCreateWithoutStoresInput, ProgramBonusUncheckedCreateWithoutStoresInput> | ProgramBonusCreateWithoutStoresInput[] | ProgramBonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutStoresInput | ProgramBonusCreateOrConnectWithoutStoresInput[]
    createMany?: ProgramBonusCreateManyStoresInputEnvelope
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
  }

  export type ProgramsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<ProgramsCreateWithoutStoresInput, ProgramsUncheckedCreateWithoutStoresInput> | ProgramsCreateWithoutStoresInput[] | ProgramsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ProgramsCreateOrConnectWithoutStoresInput | ProgramsCreateOrConnectWithoutStoresInput[]
    createMany?: ProgramsCreateManyStoresInputEnvelope
    connect?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
  }

  export type SettingsUncheckedCreateNestedOneWithoutStoresInput = {
    create?: XOR<SettingsCreateWithoutStoresInput, SettingsUncheckedCreateWithoutStoresInput>
    connectOrCreate?: SettingsCreateOrConnectWithoutStoresInput
    connect?: SettingsWhereUniqueInput
  }

  export type TiersUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<TiersCreateWithoutStoresInput, TiersUncheckedCreateWithoutStoresInput> | TiersCreateWithoutStoresInput[] | TiersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: TiersCreateOrConnectWithoutStoresInput | TiersCreateOrConnectWithoutStoresInput[]
    createMany?: TiersCreateManyStoresInputEnvelope
    connect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<TransactionsCreateWithoutStoresInput, TransactionsUncheckedCreateWithoutStoresInput> | TransactionsCreateWithoutStoresInput[] | TransactionsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutStoresInput | TransactionsCreateOrConnectWithoutStoresInput[]
    createMany?: TransactionsCreateManyStoresInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumStoreStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.StoreStatusType
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type ActivityLogUpdateManyWithoutStoresNestedInput = {
    create?: XOR<ActivityLogCreateWithoutStoresInput, ActivityLogUncheckedCreateWithoutStoresInput> | ActivityLogCreateWithoutStoresInput[] | ActivityLogUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutStoresInput | ActivityLogCreateOrConnectWithoutStoresInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutStoresInput | ActivityLogUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: ActivityLogCreateManyStoresInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutStoresInput | ActivityLogUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutStoresInput | ActivityLogUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AffiliateBonusUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateBonusCreateWithoutStoresInput, AffiliateBonusUncheckedCreateWithoutStoresInput> | AffiliateBonusCreateWithoutStoresInput[] | AffiliateBonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutStoresInput | AffiliateBonusCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateBonusUpsertWithWhereUniqueWithoutStoresInput | AffiliateBonusUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateBonusCreateManyStoresInputEnvelope
    set?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    disconnect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    delete?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    update?: AffiliateBonusUpdateWithWhereUniqueWithoutStoresInput | AffiliateBonusUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateBonusUpdateManyWithWhereWithoutStoresInput | AffiliateBonusUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateBonusScalarWhereInput | AffiliateBonusScalarWhereInput[]
  }

  export type AffiliateDiscountsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateDiscountsCreateWithoutStoresInput, AffiliateDiscountsUncheckedCreateWithoutStoresInput> | AffiliateDiscountsCreateWithoutStoresInput[] | AffiliateDiscountsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateDiscountsCreateOrConnectWithoutStoresInput | AffiliateDiscountsCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateDiscountsUpsertWithWhereUniqueWithoutStoresInput | AffiliateDiscountsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateDiscountsCreateManyStoresInputEnvelope
    set?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    disconnect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    delete?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    connect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    update?: AffiliateDiscountsUpdateWithWhereUniqueWithoutStoresInput | AffiliateDiscountsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateDiscountsUpdateManyWithWhereWithoutStoresInput | AffiliateDiscountsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateDiscountsScalarWhereInput | AffiliateDiscountsScalarWhereInput[]
  }

  export type AffiliateGiftsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateGiftsCreateWithoutStoresInput, AffiliateGiftsUncheckedCreateWithoutStoresInput> | AffiliateGiftsCreateWithoutStoresInput[] | AffiliateGiftsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutStoresInput | AffiliateGiftsCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateGiftsUpsertWithWhereUniqueWithoutStoresInput | AffiliateGiftsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateGiftsCreateManyStoresInputEnvelope
    set?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    disconnect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    delete?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    update?: AffiliateGiftsUpdateWithWhereUniqueWithoutStoresInput | AffiliateGiftsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateGiftsUpdateManyWithWhereWithoutStoresInput | AffiliateGiftsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateGiftsScalarWhereInput | AffiliateGiftsScalarWhereInput[]
  }

  export type AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateProgramHistoryCreateWithoutStoresInput, AffiliateProgramHistoryUncheckedCreateWithoutStoresInput> | AffiliateProgramHistoryCreateWithoutStoresInput[] | AffiliateProgramHistoryUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateProgramHistoryCreateOrConnectWithoutStoresInput | AffiliateProgramHistoryCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateProgramHistoryUpsertWithWhereUniqueWithoutStoresInput | AffiliateProgramHistoryUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateProgramHistoryCreateManyStoresInputEnvelope
    set?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    disconnect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    delete?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    connect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    update?: AffiliateProgramHistoryUpdateWithWhereUniqueWithoutStoresInput | AffiliateProgramHistoryUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateProgramHistoryUpdateManyWithWhereWithoutStoresInput | AffiliateProgramHistoryUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateProgramHistoryScalarWhereInput | AffiliateProgramHistoryScalarWhereInput[]
  }

  export type AffiliateProgramsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateProgramsCreateWithoutStoresInput, AffiliateProgramsUncheckedCreateWithoutStoresInput> | AffiliateProgramsCreateWithoutStoresInput[] | AffiliateProgramsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutStoresInput | AffiliateProgramsCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateProgramsUpsertWithWhereUniqueWithoutStoresInput | AffiliateProgramsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateProgramsCreateManyStoresInputEnvelope
    set?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    disconnect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    delete?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    update?: AffiliateProgramsUpdateWithWhereUniqueWithoutStoresInput | AffiliateProgramsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateProgramsUpdateManyWithWhereWithoutStoresInput | AffiliateProgramsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateProgramsScalarWhereInput | AffiliateProgramsScalarWhereInput[]
  }

  export type AffiliatesUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliatesCreateWithoutStoresInput, AffiliatesUncheckedCreateWithoutStoresInput> | AffiliatesCreateWithoutStoresInput[] | AffiliatesUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliatesCreateOrConnectWithoutStoresInput | AffiliatesCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliatesUpsertWithWhereUniqueWithoutStoresInput | AffiliatesUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliatesCreateManyStoresInputEnvelope
    set?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    disconnect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    delete?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    connect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    update?: AffiliatesUpdateWithWhereUniqueWithoutStoresInput | AffiliatesUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliatesUpdateManyWithWhereWithoutStoresInput | AffiliatesUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliatesScalarWhereInput | AffiliatesScalarWhereInput[]
  }

  export type AppSubscriptionUpdateOneWithoutStoresNestedInput = {
    create?: XOR<AppSubscriptionCreateWithoutStoresInput, AppSubscriptionUncheckedCreateWithoutStoresInput>
    connectOrCreate?: AppSubscriptionCreateOrConnectWithoutStoresInput
    upsert?: AppSubscriptionUpsertWithoutStoresInput
    disconnect?: AppSubscriptionWhereInput | boolean
    delete?: AppSubscriptionWhereInput | boolean
    connect?: AppSubscriptionWhereUniqueInput
    update?: XOR<XOR<AppSubscriptionUpdateToOneWithWhereWithoutStoresInput, AppSubscriptionUpdateWithoutStoresInput>, AppSubscriptionUncheckedUpdateWithoutStoresInput>
  }

  export type BonusUpdateManyWithoutStoresNestedInput = {
    create?: XOR<BonusCreateWithoutStoresInput, BonusUncheckedCreateWithoutStoresInput> | BonusCreateWithoutStoresInput[] | BonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutStoresInput | BonusCreateOrConnectWithoutStoresInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutStoresInput | BonusUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: BonusCreateManyStoresInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutStoresInput | BonusUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutStoresInput | BonusUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type CommissionsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<CommissionsCreateWithoutStoresInput, CommissionsUncheckedCreateWithoutStoresInput> | CommissionsCreateWithoutStoresInput[] | CommissionsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CommissionsCreateOrConnectWithoutStoresInput | CommissionsCreateOrConnectWithoutStoresInput[]
    upsert?: CommissionsUpsertWithWhereUniqueWithoutStoresInput | CommissionsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: CommissionsCreateManyStoresInputEnvelope
    set?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    disconnect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    delete?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    connect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    update?: CommissionsUpdateWithWhereUniqueWithoutStoresInput | CommissionsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: CommissionsUpdateManyWithWhereWithoutStoresInput | CommissionsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: CommissionsScalarWhereInput | CommissionsScalarWhereInput[]
  }

  export type CustomerDiscountsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<CustomerDiscountsCreateWithoutStoresInput, CustomerDiscountsUncheckedCreateWithoutStoresInput> | CustomerDiscountsCreateWithoutStoresInput[] | CustomerDiscountsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CustomerDiscountsCreateOrConnectWithoutStoresInput | CustomerDiscountsCreateOrConnectWithoutStoresInput[]
    upsert?: CustomerDiscountsUpsertWithWhereUniqueWithoutStoresInput | CustomerDiscountsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: CustomerDiscountsCreateManyStoresInputEnvelope
    set?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
    disconnect?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
    delete?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
    connect?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
    update?: CustomerDiscountsUpdateWithWhereUniqueWithoutStoresInput | CustomerDiscountsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: CustomerDiscountsUpdateManyWithWhereWithoutStoresInput | CustomerDiscountsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: CustomerDiscountsScalarWhereInput | CustomerDiscountsScalarWhereInput[]
  }

  export type CustomersUpdateManyWithoutStoresNestedInput = {
    create?: XOR<CustomersCreateWithoutStoresInput, CustomersUncheckedCreateWithoutStoresInput> | CustomersCreateWithoutStoresInput[] | CustomersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutStoresInput | CustomersCreateOrConnectWithoutStoresInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutStoresInput | CustomersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: CustomersCreateManyStoresInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutStoresInput | CustomersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutStoresInput | CustomersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type GiftsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<GiftsCreateWithoutStoresInput, GiftsUncheckedCreateWithoutStoresInput> | GiftsCreateWithoutStoresInput[] | GiftsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: GiftsCreateOrConnectWithoutStoresInput | GiftsCreateOrConnectWithoutStoresInput[]
    upsert?: GiftsUpsertWithWhereUniqueWithoutStoresInput | GiftsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: GiftsCreateManyStoresInputEnvelope
    set?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
    disconnect?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
    delete?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
    connect?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
    update?: GiftsUpdateWithWhereUniqueWithoutStoresInput | GiftsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: GiftsUpdateManyWithWhereWithoutStoresInput | GiftsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: GiftsScalarWhereInput | GiftsScalarWhereInput[]
  }

  export type IntegrationsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<IntegrationsCreateWithoutStoresInput, IntegrationsUncheckedCreateWithoutStoresInput> | IntegrationsCreateWithoutStoresInput[] | IntegrationsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: IntegrationsCreateOrConnectWithoutStoresInput | IntegrationsCreateOrConnectWithoutStoresInput[]
    upsert?: IntegrationsUpsertWithWhereUniqueWithoutStoresInput | IntegrationsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: IntegrationsCreateManyStoresInputEnvelope
    set?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
    disconnect?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
    delete?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
    connect?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
    update?: IntegrationsUpdateWithWhereUniqueWithoutStoresInput | IntegrationsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: IntegrationsUpdateManyWithWhereWithoutStoresInput | IntegrationsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: IntegrationsScalarWhereInput | IntegrationsScalarWhereInput[]
  }

  export type JobsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<JobsCreateWithoutStoresInput, JobsUncheckedCreateWithoutStoresInput> | JobsCreateWithoutStoresInput[] | JobsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutStoresInput | JobsCreateOrConnectWithoutStoresInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutStoresInput | JobsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: JobsCreateManyStoresInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutStoresInput | JobsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutStoresInput | JobsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type MessageHistoryUpdateManyWithoutStoresNestedInput = {
    create?: XOR<MessageHistoryCreateWithoutStoresInput, MessageHistoryUncheckedCreateWithoutStoresInput> | MessageHistoryCreateWithoutStoresInput[] | MessageHistoryUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: MessageHistoryCreateOrConnectWithoutStoresInput | MessageHistoryCreateOrConnectWithoutStoresInput[]
    upsert?: MessageHistoryUpsertWithWhereUniqueWithoutStoresInput | MessageHistoryUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: MessageHistoryCreateManyStoresInputEnvelope
    set?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
    disconnect?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
    delete?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
    connect?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
    update?: MessageHistoryUpdateWithWhereUniqueWithoutStoresInput | MessageHistoryUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: MessageHistoryUpdateManyWithWhereWithoutStoresInput | MessageHistoryUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: MessageHistoryScalarWhereInput | MessageHistoryScalarWhereInput[]
  }

  export type NotificationsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<NotificationsCreateWithoutStoresInput, NotificationsUncheckedCreateWithoutStoresInput> | NotificationsCreateWithoutStoresInput[] | NotificationsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutStoresInput | NotificationsCreateOrConnectWithoutStoresInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutStoresInput | NotificationsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: NotificationsCreateManyStoresInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutStoresInput | NotificationsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutStoresInput | NotificationsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type OrderItemsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<OrderItemsCreateWithoutStoresInput, OrderItemsUncheckedCreateWithoutStoresInput> | OrderItemsCreateWithoutStoresInput[] | OrderItemsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutStoresInput | OrderItemsCreateOrConnectWithoutStoresInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutStoresInput | OrderItemsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: OrderItemsCreateManyStoresInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutStoresInput | OrderItemsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutStoresInput | OrderItemsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type OrdersUpdateManyWithoutStoresNestedInput = {
    create?: XOR<OrdersCreateWithoutStoresInput, OrdersUncheckedCreateWithoutStoresInput> | OrdersCreateWithoutStoresInput[] | OrdersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutStoresInput | OrdersCreateOrConnectWithoutStoresInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutStoresInput | OrdersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: OrdersCreateManyStoresInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutStoresInput | OrdersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutStoresInput | OrdersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type PaymentGatewayUpdateManyWithoutStoresNestedInput = {
    create?: XOR<PaymentGatewayCreateWithoutStoresInput, PaymentGatewayUncheckedCreateWithoutStoresInput> | PaymentGatewayCreateWithoutStoresInput[] | PaymentGatewayUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: PaymentGatewayCreateOrConnectWithoutStoresInput | PaymentGatewayCreateOrConnectWithoutStoresInput[]
    upsert?: PaymentGatewayUpsertWithWhereUniqueWithoutStoresInput | PaymentGatewayUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: PaymentGatewayCreateManyStoresInputEnvelope
    set?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
    disconnect?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
    delete?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
    connect?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
    update?: PaymentGatewayUpdateWithWhereUniqueWithoutStoresInput | PaymentGatewayUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: PaymentGatewayUpdateManyWithWhereWithoutStoresInput | PaymentGatewayUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: PaymentGatewayScalarWhereInput | PaymentGatewayScalarWhereInput[]
  }

  export type PayoutsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<PayoutsCreateWithoutStoresInput, PayoutsUncheckedCreateWithoutStoresInput> | PayoutsCreateWithoutStoresInput[] | PayoutsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: PayoutsCreateOrConnectWithoutStoresInput | PayoutsCreateOrConnectWithoutStoresInput[]
    upsert?: PayoutsUpsertWithWhereUniqueWithoutStoresInput | PayoutsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: PayoutsCreateManyStoresInputEnvelope
    set?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    disconnect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    delete?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    connect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    update?: PayoutsUpdateWithWhereUniqueWithoutStoresInput | PayoutsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: PayoutsUpdateManyWithWhereWithoutStoresInput | PayoutsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: PayoutsScalarWhereInput | PayoutsScalarWhereInput[]
  }

  export type ProgramBonusUpdateManyWithoutStoresNestedInput = {
    create?: XOR<ProgramBonusCreateWithoutStoresInput, ProgramBonusUncheckedCreateWithoutStoresInput> | ProgramBonusCreateWithoutStoresInput[] | ProgramBonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutStoresInput | ProgramBonusCreateOrConnectWithoutStoresInput[]
    upsert?: ProgramBonusUpsertWithWhereUniqueWithoutStoresInput | ProgramBonusUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: ProgramBonusCreateManyStoresInputEnvelope
    set?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    disconnect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    delete?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    update?: ProgramBonusUpdateWithWhereUniqueWithoutStoresInput | ProgramBonusUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: ProgramBonusUpdateManyWithWhereWithoutStoresInput | ProgramBonusUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: ProgramBonusScalarWhereInput | ProgramBonusScalarWhereInput[]
  }

  export type ProgramsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<ProgramsCreateWithoutStoresInput, ProgramsUncheckedCreateWithoutStoresInput> | ProgramsCreateWithoutStoresInput[] | ProgramsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ProgramsCreateOrConnectWithoutStoresInput | ProgramsCreateOrConnectWithoutStoresInput[]
    upsert?: ProgramsUpsertWithWhereUniqueWithoutStoresInput | ProgramsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: ProgramsCreateManyStoresInputEnvelope
    set?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
    disconnect?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
    delete?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
    connect?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
    update?: ProgramsUpdateWithWhereUniqueWithoutStoresInput | ProgramsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: ProgramsUpdateManyWithWhereWithoutStoresInput | ProgramsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: ProgramsScalarWhereInput | ProgramsScalarWhereInput[]
  }

  export type SettingsUpdateOneWithoutStoresNestedInput = {
    create?: XOR<SettingsCreateWithoutStoresInput, SettingsUncheckedCreateWithoutStoresInput>
    connectOrCreate?: SettingsCreateOrConnectWithoutStoresInput
    upsert?: SettingsUpsertWithoutStoresInput
    disconnect?: SettingsWhereInput | boolean
    delete?: SettingsWhereInput | boolean
    connect?: SettingsWhereUniqueInput
    update?: XOR<XOR<SettingsUpdateToOneWithWhereWithoutStoresInput, SettingsUpdateWithoutStoresInput>, SettingsUncheckedUpdateWithoutStoresInput>
  }

  export type TiersUpdateManyWithoutStoresNestedInput = {
    create?: XOR<TiersCreateWithoutStoresInput, TiersUncheckedCreateWithoutStoresInput> | TiersCreateWithoutStoresInput[] | TiersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: TiersCreateOrConnectWithoutStoresInput | TiersCreateOrConnectWithoutStoresInput[]
    upsert?: TiersUpsertWithWhereUniqueWithoutStoresInput | TiersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: TiersCreateManyStoresInputEnvelope
    set?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    disconnect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    delete?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    connect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    update?: TiersUpdateWithWhereUniqueWithoutStoresInput | TiersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: TiersUpdateManyWithWhereWithoutStoresInput | TiersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: TiersScalarWhereInput | TiersScalarWhereInput[]
  }

  export type TransactionsUpdateManyWithoutStoresNestedInput = {
    create?: XOR<TransactionsCreateWithoutStoresInput, TransactionsUncheckedCreateWithoutStoresInput> | TransactionsCreateWithoutStoresInput[] | TransactionsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutStoresInput | TransactionsCreateOrConnectWithoutStoresInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutStoresInput | TransactionsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: TransactionsCreateManyStoresInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutStoresInput | TransactionsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutStoresInput | TransactionsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ActivityLogUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<ActivityLogCreateWithoutStoresInput, ActivityLogUncheckedCreateWithoutStoresInput> | ActivityLogCreateWithoutStoresInput[] | ActivityLogUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutStoresInput | ActivityLogCreateOrConnectWithoutStoresInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutStoresInput | ActivityLogUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: ActivityLogCreateManyStoresInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutStoresInput | ActivityLogUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutStoresInput | ActivityLogUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateBonusCreateWithoutStoresInput, AffiliateBonusUncheckedCreateWithoutStoresInput> | AffiliateBonusCreateWithoutStoresInput[] | AffiliateBonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutStoresInput | AffiliateBonusCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateBonusUpsertWithWhereUniqueWithoutStoresInput | AffiliateBonusUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateBonusCreateManyStoresInputEnvelope
    set?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    disconnect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    delete?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    update?: AffiliateBonusUpdateWithWhereUniqueWithoutStoresInput | AffiliateBonusUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateBonusUpdateManyWithWhereWithoutStoresInput | AffiliateBonusUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateBonusScalarWhereInput | AffiliateBonusScalarWhereInput[]
  }

  export type AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateDiscountsCreateWithoutStoresInput, AffiliateDiscountsUncheckedCreateWithoutStoresInput> | AffiliateDiscountsCreateWithoutStoresInput[] | AffiliateDiscountsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateDiscountsCreateOrConnectWithoutStoresInput | AffiliateDiscountsCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateDiscountsUpsertWithWhereUniqueWithoutStoresInput | AffiliateDiscountsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateDiscountsCreateManyStoresInputEnvelope
    set?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    disconnect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    delete?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    connect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    update?: AffiliateDiscountsUpdateWithWhereUniqueWithoutStoresInput | AffiliateDiscountsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateDiscountsUpdateManyWithWhereWithoutStoresInput | AffiliateDiscountsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateDiscountsScalarWhereInput | AffiliateDiscountsScalarWhereInput[]
  }

  export type AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateGiftsCreateWithoutStoresInput, AffiliateGiftsUncheckedCreateWithoutStoresInput> | AffiliateGiftsCreateWithoutStoresInput[] | AffiliateGiftsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutStoresInput | AffiliateGiftsCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateGiftsUpsertWithWhereUniqueWithoutStoresInput | AffiliateGiftsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateGiftsCreateManyStoresInputEnvelope
    set?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    disconnect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    delete?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    update?: AffiliateGiftsUpdateWithWhereUniqueWithoutStoresInput | AffiliateGiftsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateGiftsUpdateManyWithWhereWithoutStoresInput | AffiliateGiftsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateGiftsScalarWhereInput | AffiliateGiftsScalarWhereInput[]
  }

  export type AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateProgramHistoryCreateWithoutStoresInput, AffiliateProgramHistoryUncheckedCreateWithoutStoresInput> | AffiliateProgramHistoryCreateWithoutStoresInput[] | AffiliateProgramHistoryUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateProgramHistoryCreateOrConnectWithoutStoresInput | AffiliateProgramHistoryCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateProgramHistoryUpsertWithWhereUniqueWithoutStoresInput | AffiliateProgramHistoryUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateProgramHistoryCreateManyStoresInputEnvelope
    set?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    disconnect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    delete?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    connect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    update?: AffiliateProgramHistoryUpdateWithWhereUniqueWithoutStoresInput | AffiliateProgramHistoryUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateProgramHistoryUpdateManyWithWhereWithoutStoresInput | AffiliateProgramHistoryUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateProgramHistoryScalarWhereInput | AffiliateProgramHistoryScalarWhereInput[]
  }

  export type AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliateProgramsCreateWithoutStoresInput, AffiliateProgramsUncheckedCreateWithoutStoresInput> | AffiliateProgramsCreateWithoutStoresInput[] | AffiliateProgramsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutStoresInput | AffiliateProgramsCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliateProgramsUpsertWithWhereUniqueWithoutStoresInput | AffiliateProgramsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliateProgramsCreateManyStoresInputEnvelope
    set?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    disconnect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    delete?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    update?: AffiliateProgramsUpdateWithWhereUniqueWithoutStoresInput | AffiliateProgramsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliateProgramsUpdateManyWithWhereWithoutStoresInput | AffiliateProgramsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliateProgramsScalarWhereInput | AffiliateProgramsScalarWhereInput[]
  }

  export type AffiliatesUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<AffiliatesCreateWithoutStoresInput, AffiliatesUncheckedCreateWithoutStoresInput> | AffiliatesCreateWithoutStoresInput[] | AffiliatesUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: AffiliatesCreateOrConnectWithoutStoresInput | AffiliatesCreateOrConnectWithoutStoresInput[]
    upsert?: AffiliatesUpsertWithWhereUniqueWithoutStoresInput | AffiliatesUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: AffiliatesCreateManyStoresInputEnvelope
    set?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    disconnect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    delete?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    connect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    update?: AffiliatesUpdateWithWhereUniqueWithoutStoresInput | AffiliatesUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: AffiliatesUpdateManyWithWhereWithoutStoresInput | AffiliatesUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: AffiliatesScalarWhereInput | AffiliatesScalarWhereInput[]
  }

  export type AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput = {
    create?: XOR<AppSubscriptionCreateWithoutStoresInput, AppSubscriptionUncheckedCreateWithoutStoresInput>
    connectOrCreate?: AppSubscriptionCreateOrConnectWithoutStoresInput
    upsert?: AppSubscriptionUpsertWithoutStoresInput
    disconnect?: AppSubscriptionWhereInput | boolean
    delete?: AppSubscriptionWhereInput | boolean
    connect?: AppSubscriptionWhereUniqueInput
    update?: XOR<XOR<AppSubscriptionUpdateToOneWithWhereWithoutStoresInput, AppSubscriptionUpdateWithoutStoresInput>, AppSubscriptionUncheckedUpdateWithoutStoresInput>
  }

  export type BonusUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<BonusCreateWithoutStoresInput, BonusUncheckedCreateWithoutStoresInput> | BonusCreateWithoutStoresInput[] | BonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: BonusCreateOrConnectWithoutStoresInput | BonusCreateOrConnectWithoutStoresInput[]
    upsert?: BonusUpsertWithWhereUniqueWithoutStoresInput | BonusUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: BonusCreateManyStoresInputEnvelope
    set?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    disconnect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    delete?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    connect?: BonusWhereUniqueInput | BonusWhereUniqueInput[]
    update?: BonusUpdateWithWhereUniqueWithoutStoresInput | BonusUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: BonusUpdateManyWithWhereWithoutStoresInput | BonusUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: BonusScalarWhereInput | BonusScalarWhereInput[]
  }

  export type CommissionsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<CommissionsCreateWithoutStoresInput, CommissionsUncheckedCreateWithoutStoresInput> | CommissionsCreateWithoutStoresInput[] | CommissionsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CommissionsCreateOrConnectWithoutStoresInput | CommissionsCreateOrConnectWithoutStoresInput[]
    upsert?: CommissionsUpsertWithWhereUniqueWithoutStoresInput | CommissionsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: CommissionsCreateManyStoresInputEnvelope
    set?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    disconnect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    delete?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    connect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    update?: CommissionsUpdateWithWhereUniqueWithoutStoresInput | CommissionsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: CommissionsUpdateManyWithWhereWithoutStoresInput | CommissionsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: CommissionsScalarWhereInput | CommissionsScalarWhereInput[]
  }

  export type CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<CustomerDiscountsCreateWithoutStoresInput, CustomerDiscountsUncheckedCreateWithoutStoresInput> | CustomerDiscountsCreateWithoutStoresInput[] | CustomerDiscountsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CustomerDiscountsCreateOrConnectWithoutStoresInput | CustomerDiscountsCreateOrConnectWithoutStoresInput[]
    upsert?: CustomerDiscountsUpsertWithWhereUniqueWithoutStoresInput | CustomerDiscountsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: CustomerDiscountsCreateManyStoresInputEnvelope
    set?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
    disconnect?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
    delete?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
    connect?: CustomerDiscountsWhereUniqueInput | CustomerDiscountsWhereUniqueInput[]
    update?: CustomerDiscountsUpdateWithWhereUniqueWithoutStoresInput | CustomerDiscountsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: CustomerDiscountsUpdateManyWithWhereWithoutStoresInput | CustomerDiscountsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: CustomerDiscountsScalarWhereInput | CustomerDiscountsScalarWhereInput[]
  }

  export type CustomersUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<CustomersCreateWithoutStoresInput, CustomersUncheckedCreateWithoutStoresInput> | CustomersCreateWithoutStoresInput[] | CustomersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutStoresInput | CustomersCreateOrConnectWithoutStoresInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutStoresInput | CustomersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: CustomersCreateManyStoresInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutStoresInput | CustomersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutStoresInput | CustomersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type GiftsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<GiftsCreateWithoutStoresInput, GiftsUncheckedCreateWithoutStoresInput> | GiftsCreateWithoutStoresInput[] | GiftsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: GiftsCreateOrConnectWithoutStoresInput | GiftsCreateOrConnectWithoutStoresInput[]
    upsert?: GiftsUpsertWithWhereUniqueWithoutStoresInput | GiftsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: GiftsCreateManyStoresInputEnvelope
    set?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
    disconnect?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
    delete?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
    connect?: GiftsWhereUniqueInput | GiftsWhereUniqueInput[]
    update?: GiftsUpdateWithWhereUniqueWithoutStoresInput | GiftsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: GiftsUpdateManyWithWhereWithoutStoresInput | GiftsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: GiftsScalarWhereInput | GiftsScalarWhereInput[]
  }

  export type IntegrationsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<IntegrationsCreateWithoutStoresInput, IntegrationsUncheckedCreateWithoutStoresInput> | IntegrationsCreateWithoutStoresInput[] | IntegrationsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: IntegrationsCreateOrConnectWithoutStoresInput | IntegrationsCreateOrConnectWithoutStoresInput[]
    upsert?: IntegrationsUpsertWithWhereUniqueWithoutStoresInput | IntegrationsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: IntegrationsCreateManyStoresInputEnvelope
    set?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
    disconnect?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
    delete?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
    connect?: IntegrationsWhereUniqueInput | IntegrationsWhereUniqueInput[]
    update?: IntegrationsUpdateWithWhereUniqueWithoutStoresInput | IntegrationsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: IntegrationsUpdateManyWithWhereWithoutStoresInput | IntegrationsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: IntegrationsScalarWhereInput | IntegrationsScalarWhereInput[]
  }

  export type JobsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<JobsCreateWithoutStoresInput, JobsUncheckedCreateWithoutStoresInput> | JobsCreateWithoutStoresInput[] | JobsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: JobsCreateOrConnectWithoutStoresInput | JobsCreateOrConnectWithoutStoresInput[]
    upsert?: JobsUpsertWithWhereUniqueWithoutStoresInput | JobsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: JobsCreateManyStoresInputEnvelope
    set?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    disconnect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    delete?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    connect?: JobsWhereUniqueInput | JobsWhereUniqueInput[]
    update?: JobsUpdateWithWhereUniqueWithoutStoresInput | JobsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: JobsUpdateManyWithWhereWithoutStoresInput | JobsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: JobsScalarWhereInput | JobsScalarWhereInput[]
  }

  export type MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<MessageHistoryCreateWithoutStoresInput, MessageHistoryUncheckedCreateWithoutStoresInput> | MessageHistoryCreateWithoutStoresInput[] | MessageHistoryUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: MessageHistoryCreateOrConnectWithoutStoresInput | MessageHistoryCreateOrConnectWithoutStoresInput[]
    upsert?: MessageHistoryUpsertWithWhereUniqueWithoutStoresInput | MessageHistoryUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: MessageHistoryCreateManyStoresInputEnvelope
    set?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
    disconnect?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
    delete?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
    connect?: MessageHistoryWhereUniqueInput | MessageHistoryWhereUniqueInput[]
    update?: MessageHistoryUpdateWithWhereUniqueWithoutStoresInput | MessageHistoryUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: MessageHistoryUpdateManyWithWhereWithoutStoresInput | MessageHistoryUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: MessageHistoryScalarWhereInput | MessageHistoryScalarWhereInput[]
  }

  export type NotificationsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<NotificationsCreateWithoutStoresInput, NotificationsUncheckedCreateWithoutStoresInput> | NotificationsCreateWithoutStoresInput[] | NotificationsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: NotificationsCreateOrConnectWithoutStoresInput | NotificationsCreateOrConnectWithoutStoresInput[]
    upsert?: NotificationsUpsertWithWhereUniqueWithoutStoresInput | NotificationsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: NotificationsCreateManyStoresInputEnvelope
    set?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    disconnect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    delete?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    connect?: NotificationsWhereUniqueInput | NotificationsWhereUniqueInput[]
    update?: NotificationsUpdateWithWhereUniqueWithoutStoresInput | NotificationsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: NotificationsUpdateManyWithWhereWithoutStoresInput | NotificationsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
  }

  export type OrderItemsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<OrderItemsCreateWithoutStoresInput, OrderItemsUncheckedCreateWithoutStoresInput> | OrderItemsCreateWithoutStoresInput[] | OrderItemsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutStoresInput | OrderItemsCreateOrConnectWithoutStoresInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutStoresInput | OrderItemsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: OrderItemsCreateManyStoresInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutStoresInput | OrderItemsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutStoresInput | OrderItemsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<OrdersCreateWithoutStoresInput, OrdersUncheckedCreateWithoutStoresInput> | OrdersCreateWithoutStoresInput[] | OrdersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutStoresInput | OrdersCreateOrConnectWithoutStoresInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutStoresInput | OrdersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: OrdersCreateManyStoresInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutStoresInput | OrdersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutStoresInput | OrdersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<PaymentGatewayCreateWithoutStoresInput, PaymentGatewayUncheckedCreateWithoutStoresInput> | PaymentGatewayCreateWithoutStoresInput[] | PaymentGatewayUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: PaymentGatewayCreateOrConnectWithoutStoresInput | PaymentGatewayCreateOrConnectWithoutStoresInput[]
    upsert?: PaymentGatewayUpsertWithWhereUniqueWithoutStoresInput | PaymentGatewayUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: PaymentGatewayCreateManyStoresInputEnvelope
    set?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
    disconnect?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
    delete?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
    connect?: PaymentGatewayWhereUniqueInput | PaymentGatewayWhereUniqueInput[]
    update?: PaymentGatewayUpdateWithWhereUniqueWithoutStoresInput | PaymentGatewayUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: PaymentGatewayUpdateManyWithWhereWithoutStoresInput | PaymentGatewayUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: PaymentGatewayScalarWhereInput | PaymentGatewayScalarWhereInput[]
  }

  export type PayoutsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<PayoutsCreateWithoutStoresInput, PayoutsUncheckedCreateWithoutStoresInput> | PayoutsCreateWithoutStoresInput[] | PayoutsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: PayoutsCreateOrConnectWithoutStoresInput | PayoutsCreateOrConnectWithoutStoresInput[]
    upsert?: PayoutsUpsertWithWhereUniqueWithoutStoresInput | PayoutsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: PayoutsCreateManyStoresInputEnvelope
    set?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    disconnect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    delete?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    connect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    update?: PayoutsUpdateWithWhereUniqueWithoutStoresInput | PayoutsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: PayoutsUpdateManyWithWhereWithoutStoresInput | PayoutsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: PayoutsScalarWhereInput | PayoutsScalarWhereInput[]
  }

  export type ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<ProgramBonusCreateWithoutStoresInput, ProgramBonusUncheckedCreateWithoutStoresInput> | ProgramBonusCreateWithoutStoresInput[] | ProgramBonusUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutStoresInput | ProgramBonusCreateOrConnectWithoutStoresInput[]
    upsert?: ProgramBonusUpsertWithWhereUniqueWithoutStoresInput | ProgramBonusUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: ProgramBonusCreateManyStoresInputEnvelope
    set?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    disconnect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    delete?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    update?: ProgramBonusUpdateWithWhereUniqueWithoutStoresInput | ProgramBonusUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: ProgramBonusUpdateManyWithWhereWithoutStoresInput | ProgramBonusUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: ProgramBonusScalarWhereInput | ProgramBonusScalarWhereInput[]
  }

  export type ProgramsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<ProgramsCreateWithoutStoresInput, ProgramsUncheckedCreateWithoutStoresInput> | ProgramsCreateWithoutStoresInput[] | ProgramsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: ProgramsCreateOrConnectWithoutStoresInput | ProgramsCreateOrConnectWithoutStoresInput[]
    upsert?: ProgramsUpsertWithWhereUniqueWithoutStoresInput | ProgramsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: ProgramsCreateManyStoresInputEnvelope
    set?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
    disconnect?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
    delete?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
    connect?: ProgramsWhereUniqueInput | ProgramsWhereUniqueInput[]
    update?: ProgramsUpdateWithWhereUniqueWithoutStoresInput | ProgramsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: ProgramsUpdateManyWithWhereWithoutStoresInput | ProgramsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: ProgramsScalarWhereInput | ProgramsScalarWhereInput[]
  }

  export type SettingsUncheckedUpdateOneWithoutStoresNestedInput = {
    create?: XOR<SettingsCreateWithoutStoresInput, SettingsUncheckedCreateWithoutStoresInput>
    connectOrCreate?: SettingsCreateOrConnectWithoutStoresInput
    upsert?: SettingsUpsertWithoutStoresInput
    disconnect?: SettingsWhereInput | boolean
    delete?: SettingsWhereInput | boolean
    connect?: SettingsWhereUniqueInput
    update?: XOR<XOR<SettingsUpdateToOneWithWhereWithoutStoresInput, SettingsUpdateWithoutStoresInput>, SettingsUncheckedUpdateWithoutStoresInput>
  }

  export type TiersUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<TiersCreateWithoutStoresInput, TiersUncheckedCreateWithoutStoresInput> | TiersCreateWithoutStoresInput[] | TiersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: TiersCreateOrConnectWithoutStoresInput | TiersCreateOrConnectWithoutStoresInput[]
    upsert?: TiersUpsertWithWhereUniqueWithoutStoresInput | TiersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: TiersCreateManyStoresInputEnvelope
    set?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    disconnect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    delete?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    connect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    update?: TiersUpdateWithWhereUniqueWithoutStoresInput | TiersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: TiersUpdateManyWithWhereWithoutStoresInput | TiersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: TiersScalarWhereInput | TiersScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<TransactionsCreateWithoutStoresInput, TransactionsUncheckedCreateWithoutStoresInput> | TransactionsCreateWithoutStoresInput[] | TransactionsUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutStoresInput | TransactionsCreateOrConnectWithoutStoresInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutStoresInput | TransactionsUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: TransactionsCreateManyStoresInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutStoresInput | TransactionsUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutStoresInput | TransactionsUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type AffiliatesCreateNestedManyWithoutMembersInput = {
    create?: XOR<AffiliatesCreateWithoutMembersInput, AffiliatesUncheckedCreateWithoutMembersInput> | AffiliatesCreateWithoutMembersInput[] | AffiliatesUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: AffiliatesCreateOrConnectWithoutMembersInput | AffiliatesCreateOrConnectWithoutMembersInput[]
    createMany?: AffiliatesCreateManyMembersInputEnvelope
    connect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
  }

  export type AffiliatesUncheckedCreateNestedManyWithoutMembersInput = {
    create?: XOR<AffiliatesCreateWithoutMembersInput, AffiliatesUncheckedCreateWithoutMembersInput> | AffiliatesCreateWithoutMembersInput[] | AffiliatesUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: AffiliatesCreateOrConnectWithoutMembersInput | AffiliatesCreateOrConnectWithoutMembersInput[]
    createMany?: AffiliatesCreateManyMembersInputEnvelope
    connect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
  }

  export type AffiliatesUpdateManyWithoutMembersNestedInput = {
    create?: XOR<AffiliatesCreateWithoutMembersInput, AffiliatesUncheckedCreateWithoutMembersInput> | AffiliatesCreateWithoutMembersInput[] | AffiliatesUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: AffiliatesCreateOrConnectWithoutMembersInput | AffiliatesCreateOrConnectWithoutMembersInput[]
    upsert?: AffiliatesUpsertWithWhereUniqueWithoutMembersInput | AffiliatesUpsertWithWhereUniqueWithoutMembersInput[]
    createMany?: AffiliatesCreateManyMembersInputEnvelope
    set?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    disconnect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    delete?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    connect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    update?: AffiliatesUpdateWithWhereUniqueWithoutMembersInput | AffiliatesUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: AffiliatesUpdateManyWithWhereWithoutMembersInput | AffiliatesUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: AffiliatesScalarWhereInput | AffiliatesScalarWhereInput[]
  }

  export type AffiliatesUncheckedUpdateManyWithoutMembersNestedInput = {
    create?: XOR<AffiliatesCreateWithoutMembersInput, AffiliatesUncheckedCreateWithoutMembersInput> | AffiliatesCreateWithoutMembersInput[] | AffiliatesUncheckedCreateWithoutMembersInput[]
    connectOrCreate?: AffiliatesCreateOrConnectWithoutMembersInput | AffiliatesCreateOrConnectWithoutMembersInput[]
    upsert?: AffiliatesUpsertWithWhereUniqueWithoutMembersInput | AffiliatesUpsertWithWhereUniqueWithoutMembersInput[]
    createMany?: AffiliatesCreateManyMembersInputEnvelope
    set?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    disconnect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    delete?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    connect?: AffiliatesWhereUniqueInput | AffiliatesWhereUniqueInput[]
    update?: AffiliatesUpdateWithWhereUniqueWithoutMembersInput | AffiliatesUpdateWithWhereUniqueWithoutMembersInput[]
    updateMany?: AffiliatesUpdateManyWithWhereWithoutMembersInput | AffiliatesUpdateManyWithWhereWithoutMembersInput[]
    deleteMany?: AffiliatesScalarWhereInput | AffiliatesScalarWhereInput[]
  }

  export type AffiliateProgramsCreateNestedManyWithoutProgramsInput = {
    create?: XOR<AffiliateProgramsCreateWithoutProgramsInput, AffiliateProgramsUncheckedCreateWithoutProgramsInput> | AffiliateProgramsCreateWithoutProgramsInput[] | AffiliateProgramsUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutProgramsInput | AffiliateProgramsCreateOrConnectWithoutProgramsInput[]
    createMany?: AffiliateProgramsCreateManyProgramsInputEnvelope
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
  }

  export type CustomerDiscountsCreateNestedOneWithoutProgramsInput = {
    create?: XOR<CustomerDiscountsCreateWithoutProgramsInput, CustomerDiscountsUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: CustomerDiscountsCreateOrConnectWithoutProgramsInput
    connect?: CustomerDiscountsWhereUniqueInput
  }

  export type OrdersCreateNestedManyWithoutProgramsInput = {
    create?: XOR<OrdersCreateWithoutProgramsInput, OrdersUncheckedCreateWithoutProgramsInput> | OrdersCreateWithoutProgramsInput[] | OrdersUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutProgramsInput | OrdersCreateOrConnectWithoutProgramsInput[]
    createMany?: OrdersCreateManyProgramsInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type ProgramBonusCreateNestedManyWithoutProgramsInput = {
    create?: XOR<ProgramBonusCreateWithoutProgramsInput, ProgramBonusUncheckedCreateWithoutProgramsInput> | ProgramBonusCreateWithoutProgramsInput[] | ProgramBonusUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutProgramsInput | ProgramBonusCreateOrConnectWithoutProgramsInput[]
    createMany?: ProgramBonusCreateManyProgramsInputEnvelope
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
  }

  export type StoresCreateNestedOneWithoutProgramsInput = {
    create?: XOR<StoresCreateWithoutProgramsInput, StoresUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutProgramsInput
    connect?: StoresWhereUniqueInput
  }

  export type TiersCreateNestedManyWithoutProgramsInput = {
    create?: XOR<TiersCreateWithoutProgramsInput, TiersUncheckedCreateWithoutProgramsInput> | TiersCreateWithoutProgramsInput[] | TiersUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: TiersCreateOrConnectWithoutProgramsInput | TiersCreateOrConnectWithoutProgramsInput[]
    createMany?: TiersCreateManyProgramsInputEnvelope
    connect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutProgramsInput = {
    create?: XOR<ActivityLogCreateWithoutProgramsInput, ActivityLogUncheckedCreateWithoutProgramsInput> | ActivityLogCreateWithoutProgramsInput[] | ActivityLogUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutProgramsInput | ActivityLogCreateOrConnectWithoutProgramsInput[]
    createMany?: ActivityLogCreateManyProgramsInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AffiliateProgramsUncheckedCreateNestedManyWithoutProgramsInput = {
    create?: XOR<AffiliateProgramsCreateWithoutProgramsInput, AffiliateProgramsUncheckedCreateWithoutProgramsInput> | AffiliateProgramsCreateWithoutProgramsInput[] | AffiliateProgramsUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutProgramsInput | AffiliateProgramsCreateOrConnectWithoutProgramsInput[]
    createMany?: AffiliateProgramsCreateManyProgramsInputEnvelope
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
  }

  export type CustomerDiscountsUncheckedCreateNestedOneWithoutProgramsInput = {
    create?: XOR<CustomerDiscountsCreateWithoutProgramsInput, CustomerDiscountsUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: CustomerDiscountsCreateOrConnectWithoutProgramsInput
    connect?: CustomerDiscountsWhereUniqueInput
  }

  export type OrdersUncheckedCreateNestedManyWithoutProgramsInput = {
    create?: XOR<OrdersCreateWithoutProgramsInput, OrdersUncheckedCreateWithoutProgramsInput> | OrdersCreateWithoutProgramsInput[] | OrdersUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutProgramsInput | OrdersCreateOrConnectWithoutProgramsInput[]
    createMany?: OrdersCreateManyProgramsInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type ProgramBonusUncheckedCreateNestedManyWithoutProgramsInput = {
    create?: XOR<ProgramBonusCreateWithoutProgramsInput, ProgramBonusUncheckedCreateWithoutProgramsInput> | ProgramBonusCreateWithoutProgramsInput[] | ProgramBonusUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutProgramsInput | ProgramBonusCreateOrConnectWithoutProgramsInput[]
    createMany?: ProgramBonusCreateManyProgramsInputEnvelope
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
  }

  export type TiersUncheckedCreateNestedManyWithoutProgramsInput = {
    create?: XOR<TiersCreateWithoutProgramsInput, TiersUncheckedCreateWithoutProgramsInput> | TiersCreateWithoutProgramsInput[] | TiersUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: TiersCreateOrConnectWithoutProgramsInput | TiersCreateOrConnectWithoutProgramsInput[]
    createMany?: TiersCreateManyProgramsInputEnvelope
    connect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutProgramsInput = {
    create?: XOR<ActivityLogCreateWithoutProgramsInput, ActivityLogUncheckedCreateWithoutProgramsInput> | ActivityLogCreateWithoutProgramsInput[] | ActivityLogUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutProgramsInput | ActivityLogCreateOrConnectWithoutProgramsInput[]
    createMany?: ActivityLogCreateManyProgramsInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type EnumProgramStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProgramStatusType
  }

  export type AffiliateProgramsUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<AffiliateProgramsCreateWithoutProgramsInput, AffiliateProgramsUncheckedCreateWithoutProgramsInput> | AffiliateProgramsCreateWithoutProgramsInput[] | AffiliateProgramsUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutProgramsInput | AffiliateProgramsCreateOrConnectWithoutProgramsInput[]
    upsert?: AffiliateProgramsUpsertWithWhereUniqueWithoutProgramsInput | AffiliateProgramsUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: AffiliateProgramsCreateManyProgramsInputEnvelope
    set?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    disconnect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    delete?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    update?: AffiliateProgramsUpdateWithWhereUniqueWithoutProgramsInput | AffiliateProgramsUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: AffiliateProgramsUpdateManyWithWhereWithoutProgramsInput | AffiliateProgramsUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: AffiliateProgramsScalarWhereInput | AffiliateProgramsScalarWhereInput[]
  }

  export type CustomerDiscountsUpdateOneWithoutProgramsNestedInput = {
    create?: XOR<CustomerDiscountsCreateWithoutProgramsInput, CustomerDiscountsUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: CustomerDiscountsCreateOrConnectWithoutProgramsInput
    upsert?: CustomerDiscountsUpsertWithoutProgramsInput
    disconnect?: CustomerDiscountsWhereInput | boolean
    delete?: CustomerDiscountsWhereInput | boolean
    connect?: CustomerDiscountsWhereUniqueInput
    update?: XOR<XOR<CustomerDiscountsUpdateToOneWithWhereWithoutProgramsInput, CustomerDiscountsUpdateWithoutProgramsInput>, CustomerDiscountsUncheckedUpdateWithoutProgramsInput>
  }

  export type OrdersUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<OrdersCreateWithoutProgramsInput, OrdersUncheckedCreateWithoutProgramsInput> | OrdersCreateWithoutProgramsInput[] | OrdersUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutProgramsInput | OrdersCreateOrConnectWithoutProgramsInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutProgramsInput | OrdersUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: OrdersCreateManyProgramsInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutProgramsInput | OrdersUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutProgramsInput | OrdersUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type ProgramBonusUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<ProgramBonusCreateWithoutProgramsInput, ProgramBonusUncheckedCreateWithoutProgramsInput> | ProgramBonusCreateWithoutProgramsInput[] | ProgramBonusUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutProgramsInput | ProgramBonusCreateOrConnectWithoutProgramsInput[]
    upsert?: ProgramBonusUpsertWithWhereUniqueWithoutProgramsInput | ProgramBonusUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: ProgramBonusCreateManyProgramsInputEnvelope
    set?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    disconnect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    delete?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    update?: ProgramBonusUpdateWithWhereUniqueWithoutProgramsInput | ProgramBonusUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: ProgramBonusUpdateManyWithWhereWithoutProgramsInput | ProgramBonusUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: ProgramBonusScalarWhereInput | ProgramBonusScalarWhereInput[]
  }

  export type StoresUpdateOneRequiredWithoutProgramsNestedInput = {
    create?: XOR<StoresCreateWithoutProgramsInput, StoresUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutProgramsInput
    upsert?: StoresUpsertWithoutProgramsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutProgramsInput, StoresUpdateWithoutProgramsInput>, StoresUncheckedUpdateWithoutProgramsInput>
  }

  export type TiersUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<TiersCreateWithoutProgramsInput, TiersUncheckedCreateWithoutProgramsInput> | TiersCreateWithoutProgramsInput[] | TiersUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: TiersCreateOrConnectWithoutProgramsInput | TiersCreateOrConnectWithoutProgramsInput[]
    upsert?: TiersUpsertWithWhereUniqueWithoutProgramsInput | TiersUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: TiersCreateManyProgramsInputEnvelope
    set?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    disconnect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    delete?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    connect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    update?: TiersUpdateWithWhereUniqueWithoutProgramsInput | TiersUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: TiersUpdateManyWithWhereWithoutProgramsInput | TiersUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: TiersScalarWhereInput | TiersScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<ActivityLogCreateWithoutProgramsInput, ActivityLogUncheckedCreateWithoutProgramsInput> | ActivityLogCreateWithoutProgramsInput[] | ActivityLogUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutProgramsInput | ActivityLogCreateOrConnectWithoutProgramsInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutProgramsInput | ActivityLogUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: ActivityLogCreateManyProgramsInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutProgramsInput | ActivityLogUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutProgramsInput | ActivityLogUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AffiliateProgramsUncheckedUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<AffiliateProgramsCreateWithoutProgramsInput, AffiliateProgramsUncheckedCreateWithoutProgramsInput> | AffiliateProgramsCreateWithoutProgramsInput[] | AffiliateProgramsUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutProgramsInput | AffiliateProgramsCreateOrConnectWithoutProgramsInput[]
    upsert?: AffiliateProgramsUpsertWithWhereUniqueWithoutProgramsInput | AffiliateProgramsUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: AffiliateProgramsCreateManyProgramsInputEnvelope
    set?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    disconnect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    delete?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    update?: AffiliateProgramsUpdateWithWhereUniqueWithoutProgramsInput | AffiliateProgramsUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: AffiliateProgramsUpdateManyWithWhereWithoutProgramsInput | AffiliateProgramsUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: AffiliateProgramsScalarWhereInput | AffiliateProgramsScalarWhereInput[]
  }

  export type CustomerDiscountsUncheckedUpdateOneWithoutProgramsNestedInput = {
    create?: XOR<CustomerDiscountsCreateWithoutProgramsInput, CustomerDiscountsUncheckedCreateWithoutProgramsInput>
    connectOrCreate?: CustomerDiscountsCreateOrConnectWithoutProgramsInput
    upsert?: CustomerDiscountsUpsertWithoutProgramsInput
    disconnect?: CustomerDiscountsWhereInput | boolean
    delete?: CustomerDiscountsWhereInput | boolean
    connect?: CustomerDiscountsWhereUniqueInput
    update?: XOR<XOR<CustomerDiscountsUpdateToOneWithWhereWithoutProgramsInput, CustomerDiscountsUpdateWithoutProgramsInput>, CustomerDiscountsUncheckedUpdateWithoutProgramsInput>
  }

  export type OrdersUncheckedUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<OrdersCreateWithoutProgramsInput, OrdersUncheckedCreateWithoutProgramsInput> | OrdersCreateWithoutProgramsInput[] | OrdersUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutProgramsInput | OrdersCreateOrConnectWithoutProgramsInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutProgramsInput | OrdersUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: OrdersCreateManyProgramsInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutProgramsInput | OrdersUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutProgramsInput | OrdersUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type ProgramBonusUncheckedUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<ProgramBonusCreateWithoutProgramsInput, ProgramBonusUncheckedCreateWithoutProgramsInput> | ProgramBonusCreateWithoutProgramsInput[] | ProgramBonusUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutProgramsInput | ProgramBonusCreateOrConnectWithoutProgramsInput[]
    upsert?: ProgramBonusUpsertWithWhereUniqueWithoutProgramsInput | ProgramBonusUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: ProgramBonusCreateManyProgramsInputEnvelope
    set?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    disconnect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    delete?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    update?: ProgramBonusUpdateWithWhereUniqueWithoutProgramsInput | ProgramBonusUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: ProgramBonusUpdateManyWithWhereWithoutProgramsInput | ProgramBonusUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: ProgramBonusScalarWhereInput | ProgramBonusScalarWhereInput[]
  }

  export type TiersUncheckedUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<TiersCreateWithoutProgramsInput, TiersUncheckedCreateWithoutProgramsInput> | TiersCreateWithoutProgramsInput[] | TiersUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: TiersCreateOrConnectWithoutProgramsInput | TiersCreateOrConnectWithoutProgramsInput[]
    upsert?: TiersUpsertWithWhereUniqueWithoutProgramsInput | TiersUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: TiersCreateManyProgramsInputEnvelope
    set?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    disconnect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    delete?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    connect?: TiersWhereUniqueInput | TiersWhereUniqueInput[]
    update?: TiersUpdateWithWhereUniqueWithoutProgramsInput | TiersUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: TiersUpdateManyWithWhereWithoutProgramsInput | TiersUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: TiersScalarWhereInput | TiersScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutProgramsNestedInput = {
    create?: XOR<ActivityLogCreateWithoutProgramsInput, ActivityLogUncheckedCreateWithoutProgramsInput> | ActivityLogCreateWithoutProgramsInput[] | ActivityLogUncheckedCreateWithoutProgramsInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutProgramsInput | ActivityLogCreateOrConnectWithoutProgramsInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutProgramsInput | ActivityLogUpsertWithWhereUniqueWithoutProgramsInput[]
    createMany?: ActivityLogCreateManyProgramsInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutProgramsInput | ActivityLogUpdateWithWhereUniqueWithoutProgramsInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutProgramsInput | ActivityLogUpdateManyWithWhereWithoutProgramsInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ProgramsCreateNestedOneWithoutTiersInput = {
    create?: XOR<ProgramsCreateWithoutTiersInput, ProgramsUncheckedCreateWithoutTiersInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutTiersInput
    connect?: ProgramsWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutTiersInput = {
    create?: XOR<StoresCreateWithoutTiersInput, StoresUncheckedCreateWithoutTiersInput>
    connectOrCreate?: StoresCreateOrConnectWithoutTiersInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumTierTypeFieldUpdateOperationsInput = {
    set?: $Enums.TierType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumEarningTypeFieldUpdateOperationsInput = {
    set?: $Enums.EarningType
  }

  export type ProgramsUpdateOneRequiredWithoutTiersNestedInput = {
    create?: XOR<ProgramsCreateWithoutTiersInput, ProgramsUncheckedCreateWithoutTiersInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutTiersInput
    upsert?: ProgramsUpsertWithoutTiersInput
    connect?: ProgramsWhereUniqueInput
    update?: XOR<XOR<ProgramsUpdateToOneWithWhereWithoutTiersInput, ProgramsUpdateWithoutTiersInput>, ProgramsUncheckedUpdateWithoutTiersInput>
  }

  export type StoresUpdateOneRequiredWithoutTiersNestedInput = {
    create?: XOR<StoresCreateWithoutTiersInput, StoresUncheckedCreateWithoutTiersInput>
    connectOrCreate?: StoresCreateOrConnectWithoutTiersInput
    upsert?: StoresUpsertWithoutTiersInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutTiersInput, StoresUpdateWithoutTiersInput>, StoresUncheckedUpdateWithoutTiersInput>
  }

  export type ProgramsCreateNestedOneWithoutCustomer_discountsInput = {
    create?: XOR<ProgramsCreateWithoutCustomer_discountsInput, ProgramsUncheckedCreateWithoutCustomer_discountsInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutCustomer_discountsInput
    connect?: ProgramsWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutCustomer_discountsInput = {
    create?: XOR<StoresCreateWithoutCustomer_discountsInput, StoresUncheckedCreateWithoutCustomer_discountsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCustomer_discountsInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumCustomerDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.CustomerDiscountType
  }

  export type ProgramsUpdateOneRequiredWithoutCustomer_discountsNestedInput = {
    create?: XOR<ProgramsCreateWithoutCustomer_discountsInput, ProgramsUncheckedCreateWithoutCustomer_discountsInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutCustomer_discountsInput
    upsert?: ProgramsUpsertWithoutCustomer_discountsInput
    connect?: ProgramsWhereUniqueInput
    update?: XOR<XOR<ProgramsUpdateToOneWithWhereWithoutCustomer_discountsInput, ProgramsUpdateWithoutCustomer_discountsInput>, ProgramsUncheckedUpdateWithoutCustomer_discountsInput>
  }

  export type StoresUpdateOneRequiredWithoutCustomer_discountsNestedInput = {
    create?: XOR<StoresCreateWithoutCustomer_discountsInput, StoresUncheckedCreateWithoutCustomer_discountsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCustomer_discountsInput
    upsert?: StoresUpsertWithoutCustomer_discountsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutCustomer_discountsInput, StoresUpdateWithoutCustomer_discountsInput>, StoresUncheckedUpdateWithoutCustomer_discountsInput>
  }

  export type CommissionsCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CommissionsCreateWithoutOrdersInput, CommissionsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CommissionsCreateOrConnectWithoutOrdersInput
    connect?: CommissionsWhereUniqueInput
  }

  export type OrderItemsCreateNestedManyWithoutOrdersInput = {
    create?: XOR<OrderItemsCreateWithoutOrdersInput, OrderItemsUncheckedCreateWithoutOrdersInput> | OrderItemsCreateWithoutOrdersInput[] | OrderItemsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutOrdersInput | OrderItemsCreateOrConnectWithoutOrdersInput[]
    createMany?: OrderItemsCreateManyOrdersInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type AffiliatesCreateNestedOneWithoutOrdersInput = {
    create?: XOR<AffiliatesCreateWithoutOrdersInput, AffiliatesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutOrdersInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CustomersCreateWithoutOrdersInput, CustomersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutOrdersInput
    connect?: CustomersWhereUniqueInput
  }

  export type ProgramsCreateNestedOneWithoutOrdersInput = {
    create?: XOR<ProgramsCreateWithoutOrdersInput, ProgramsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutOrdersInput
    connect?: ProgramsWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutOrdersInput = {
    create?: XOR<StoresCreateWithoutOrdersInput, StoresUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: StoresCreateOrConnectWithoutOrdersInput
    connect?: StoresWhereUniqueInput
  }

  export type ActivityLogCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ActivityLogCreateWithoutOrdersInput, ActivityLogUncheckedCreateWithoutOrdersInput> | ActivityLogCreateWithoutOrdersInput[] | ActivityLogUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOrdersInput | ActivityLogCreateOrConnectWithoutOrdersInput[]
    createMany?: ActivityLogCreateManyOrdersInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type CommissionsUncheckedCreateNestedOneWithoutOrdersInput = {
    create?: XOR<CommissionsCreateWithoutOrdersInput, CommissionsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CommissionsCreateOrConnectWithoutOrdersInput
    connect?: CommissionsWhereUniqueInput
  }

  export type OrderItemsUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<OrderItemsCreateWithoutOrdersInput, OrderItemsUncheckedCreateWithoutOrdersInput> | OrderItemsCreateWithoutOrdersInput[] | OrderItemsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutOrdersInput | OrderItemsCreateOrConnectWithoutOrdersInput[]
    createMany?: OrderItemsCreateManyOrdersInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutOrdersInput = {
    create?: XOR<ActivityLogCreateWithoutOrdersInput, ActivityLogUncheckedCreateWithoutOrdersInput> | ActivityLogCreateWithoutOrdersInput[] | ActivityLogUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOrdersInput | ActivityLogCreateOrConnectWithoutOrdersInput[]
    createMany?: ActivityLogCreateManyOrdersInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type EnumOrderAttributeTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderAttributeType
  }

  export type EnumOrderStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.OrderStatusType
  }

  export type CommissionsUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CommissionsCreateWithoutOrdersInput, CommissionsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CommissionsCreateOrConnectWithoutOrdersInput
    upsert?: CommissionsUpsertWithoutOrdersInput
    disconnect?: CommissionsWhereInput | boolean
    delete?: CommissionsWhereInput | boolean
    connect?: CommissionsWhereUniqueInput
    update?: XOR<XOR<CommissionsUpdateToOneWithWhereWithoutOrdersInput, CommissionsUpdateWithoutOrdersInput>, CommissionsUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemsUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<OrderItemsCreateWithoutOrdersInput, OrderItemsUncheckedCreateWithoutOrdersInput> | OrderItemsCreateWithoutOrdersInput[] | OrderItemsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutOrdersInput | OrderItemsCreateOrConnectWithoutOrdersInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutOrdersInput | OrderItemsUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: OrderItemsCreateManyOrdersInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutOrdersInput | OrderItemsUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutOrdersInput | OrderItemsUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type AffiliatesUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<AffiliatesCreateWithoutOrdersInput, AffiliatesUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutOrdersInput
    upsert?: AffiliatesUpsertWithoutOrdersInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutOrdersInput, AffiliatesUpdateWithoutOrdersInput>, AffiliatesUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomersUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<CustomersCreateWithoutOrdersInput, CustomersUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutOrdersInput
    upsert?: CustomersUpsertWithoutOrdersInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutOrdersInput, CustomersUpdateWithoutOrdersInput>, CustomersUncheckedUpdateWithoutOrdersInput>
  }

  export type ProgramsUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<ProgramsCreateWithoutOrdersInput, ProgramsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutOrdersInput
    upsert?: ProgramsUpsertWithoutOrdersInput
    disconnect?: ProgramsWhereInput | boolean
    delete?: ProgramsWhereInput | boolean
    connect?: ProgramsWhereUniqueInput
    update?: XOR<XOR<ProgramsUpdateToOneWithWhereWithoutOrdersInput, ProgramsUpdateWithoutOrdersInput>, ProgramsUncheckedUpdateWithoutOrdersInput>
  }

  export type StoresUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<StoresCreateWithoutOrdersInput, StoresUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: StoresCreateOrConnectWithoutOrdersInput
    upsert?: StoresUpsertWithoutOrdersInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutOrdersInput, StoresUpdateWithoutOrdersInput>, StoresUncheckedUpdateWithoutOrdersInput>
  }

  export type ActivityLogUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ActivityLogCreateWithoutOrdersInput, ActivityLogUncheckedCreateWithoutOrdersInput> | ActivityLogCreateWithoutOrdersInput[] | ActivityLogUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOrdersInput | ActivityLogCreateOrConnectWithoutOrdersInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutOrdersInput | ActivityLogUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: ActivityLogCreateManyOrdersInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutOrdersInput | ActivityLogUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutOrdersInput | ActivityLogUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CommissionsUncheckedUpdateOneWithoutOrdersNestedInput = {
    create?: XOR<CommissionsCreateWithoutOrdersInput, CommissionsUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: CommissionsCreateOrConnectWithoutOrdersInput
    upsert?: CommissionsUpsertWithoutOrdersInput
    disconnect?: CommissionsWhereInput | boolean
    delete?: CommissionsWhereInput | boolean
    connect?: CommissionsWhereUniqueInput
    update?: XOR<XOR<CommissionsUpdateToOneWithWhereWithoutOrdersInput, CommissionsUpdateWithoutOrdersInput>, CommissionsUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemsUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<OrderItemsCreateWithoutOrdersInput, OrderItemsUncheckedCreateWithoutOrdersInput> | OrderItemsCreateWithoutOrdersInput[] | OrderItemsUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutOrdersInput | OrderItemsCreateOrConnectWithoutOrdersInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutOrdersInput | OrderItemsUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: OrderItemsCreateManyOrdersInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutOrdersInput | OrderItemsUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutOrdersInput | OrderItemsUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutOrdersNestedInput = {
    create?: XOR<ActivityLogCreateWithoutOrdersInput, ActivityLogUncheckedCreateWithoutOrdersInput> | ActivityLogCreateWithoutOrdersInput[] | ActivityLogUncheckedCreateWithoutOrdersInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOrdersInput | ActivityLogCreateOrConnectWithoutOrdersInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutOrdersInput | ActivityLogUpsertWithWhereUniqueWithoutOrdersInput[]
    createMany?: ActivityLogCreateManyOrdersInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutOrdersInput | ActivityLogUpdateWithWhereUniqueWithoutOrdersInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutOrdersInput | ActivityLogUpdateManyWithWhereWithoutOrdersInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AffiliatesCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<AffiliatesCreateWithoutOrder_itemsInput, AffiliatesUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutOrder_itemsInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type CustomersCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<CustomersCreateWithoutOrder_itemsInput, CustomersUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutOrder_itemsInput
    connect?: CustomersWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutOrder_itemsInput = {
    create?: XOR<OrdersCreateWithoutOrder_itemsInput, OrdersUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrder_itemsInput
    connect?: OrdersWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<StoresCreateWithoutOrderItemsInput, StoresUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutOrderItemsInput
    connect?: StoresWhereUniqueInput
  }

  export type AffiliatesUpdateOneRequiredWithoutOrder_itemsNestedInput = {
    create?: XOR<AffiliatesCreateWithoutOrder_itemsInput, AffiliatesUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutOrder_itemsInput
    upsert?: AffiliatesUpsertWithoutOrder_itemsInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutOrder_itemsInput, AffiliatesUpdateWithoutOrder_itemsInput>, AffiliatesUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type CustomersUpdateOneRequiredWithoutOrder_itemsNestedInput = {
    create?: XOR<CustomersCreateWithoutOrder_itemsInput, CustomersUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: CustomersCreateOrConnectWithoutOrder_itemsInput
    upsert?: CustomersUpsertWithoutOrder_itemsInput
    connect?: CustomersWhereUniqueInput
    update?: XOR<XOR<CustomersUpdateToOneWithWhereWithoutOrder_itemsInput, CustomersUpdateWithoutOrder_itemsInput>, CustomersUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type OrdersUpdateOneRequiredWithoutOrder_itemsNestedInput = {
    create?: XOR<OrdersCreateWithoutOrder_itemsInput, OrdersUncheckedCreateWithoutOrder_itemsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutOrder_itemsInput
    upsert?: OrdersUpsertWithoutOrder_itemsInput
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutOrder_itemsInput, OrdersUpdateWithoutOrder_itemsInput>, OrdersUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type StoresUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<StoresCreateWithoutOrderItemsInput, StoresUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutOrderItemsInput
    upsert?: StoresUpsertWithoutOrderItemsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutOrderItemsInput, StoresUpdateWithoutOrderItemsInput>, StoresUncheckedUpdateWithoutOrderItemsInput>
  }

  export type AffiliatesCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<AffiliatesCreateWithoutCommissionsInput, AffiliatesUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutCommissionsInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<OrdersCreateWithoutCommissionsInput, OrdersUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutCommissionsInput
    connect?: OrdersWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutCommissionsInput = {
    create?: XOR<StoresCreateWithoutCommissionsInput, StoresUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCommissionsInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.StatusType
  }

  export type NullableEnumApprovalModeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalModeType | null
  }

  export type AffiliatesUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<AffiliatesCreateWithoutCommissionsInput, AffiliatesUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutCommissionsInput
    upsert?: AffiliatesUpsertWithoutCommissionsInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutCommissionsInput, AffiliatesUpdateWithoutCommissionsInput>, AffiliatesUncheckedUpdateWithoutCommissionsInput>
  }

  export type OrdersUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<OrdersCreateWithoutCommissionsInput, OrdersUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutCommissionsInput
    upsert?: OrdersUpsertWithoutCommissionsInput
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutCommissionsInput, OrdersUpdateWithoutCommissionsInput>, OrdersUncheckedUpdateWithoutCommissionsInput>
  }

  export type StoresUpdateOneRequiredWithoutCommissionsNestedInput = {
    create?: XOR<StoresCreateWithoutCommissionsInput, StoresUncheckedCreateWithoutCommissionsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCommissionsInput
    upsert?: StoresUpsertWithoutCommissionsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutCommissionsInput, StoresUpdateWithoutCommissionsInput>, StoresUncheckedUpdateWithoutCommissionsInput>
  }

  export type AffiliatesCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<AffiliatesCreateWithoutPayoutsInput, AffiliatesUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutPayoutsInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type JobsCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<JobsCreateWithoutPayoutsInput, JobsUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: JobsCreateOrConnectWithoutPayoutsInput
    connect?: JobsWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<StoresCreateWithoutPayoutsInput, StoresUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPayoutsInput
    connect?: StoresWhereUniqueInput
  }

  export type ActivityLogCreateNestedManyWithoutPayoutsInput = {
    create?: XOR<ActivityLogCreateWithoutPayoutsInput, ActivityLogUncheckedCreateWithoutPayoutsInput> | ActivityLogCreateWithoutPayoutsInput[] | ActivityLogUncheckedCreateWithoutPayoutsInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutPayoutsInput | ActivityLogCreateOrConnectWithoutPayoutsInput[]
    createMany?: ActivityLogCreateManyPayoutsInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutPayoutsInput = {
    create?: XOR<ActivityLogCreateWithoutPayoutsInput, ActivityLogUncheckedCreateWithoutPayoutsInput> | ActivityLogCreateWithoutPayoutsInput[] | ActivityLogUncheckedCreateWithoutPayoutsInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutPayoutsInput | ActivityLogCreateOrConnectWithoutPayoutsInput[]
    createMany?: ActivityLogCreateManyPayoutsInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type AffiliatesUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<AffiliatesCreateWithoutPayoutsInput, AffiliatesUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutPayoutsInput
    upsert?: AffiliatesUpsertWithoutPayoutsInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutPayoutsInput, AffiliatesUpdateWithoutPayoutsInput>, AffiliatesUncheckedUpdateWithoutPayoutsInput>
  }

  export type JobsUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<JobsCreateWithoutPayoutsInput, JobsUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: JobsCreateOrConnectWithoutPayoutsInput
    upsert?: JobsUpsertWithoutPayoutsInput
    connect?: JobsWhereUniqueInput
    update?: XOR<XOR<JobsUpdateToOneWithWhereWithoutPayoutsInput, JobsUpdateWithoutPayoutsInput>, JobsUncheckedUpdateWithoutPayoutsInput>
  }

  export type StoresUpdateOneRequiredWithoutPayoutsNestedInput = {
    create?: XOR<StoresCreateWithoutPayoutsInput, StoresUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPayoutsInput
    upsert?: StoresUpsertWithoutPayoutsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutPayoutsInput, StoresUpdateWithoutPayoutsInput>, StoresUncheckedUpdateWithoutPayoutsInput>
  }

  export type ActivityLogUpdateManyWithoutPayoutsNestedInput = {
    create?: XOR<ActivityLogCreateWithoutPayoutsInput, ActivityLogUncheckedCreateWithoutPayoutsInput> | ActivityLogCreateWithoutPayoutsInput[] | ActivityLogUncheckedCreateWithoutPayoutsInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutPayoutsInput | ActivityLogCreateOrConnectWithoutPayoutsInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutPayoutsInput | ActivityLogUpsertWithWhereUniqueWithoutPayoutsInput[]
    createMany?: ActivityLogCreateManyPayoutsInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutPayoutsInput | ActivityLogUpdateWithWhereUniqueWithoutPayoutsInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutPayoutsInput | ActivityLogUpdateManyWithWhereWithoutPayoutsInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutPayoutsNestedInput = {
    create?: XOR<ActivityLogCreateWithoutPayoutsInput, ActivityLogUncheckedCreateWithoutPayoutsInput> | ActivityLogCreateWithoutPayoutsInput[] | ActivityLogUncheckedCreateWithoutPayoutsInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutPayoutsInput | ActivityLogCreateOrConnectWithoutPayoutsInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutPayoutsInput | ActivityLogUpsertWithWhereUniqueWithoutPayoutsInput[]
    createMany?: ActivityLogCreateManyPayoutsInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutPayoutsInput | ActivityLogUpdateWithWhereUniqueWithoutPayoutsInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutPayoutsInput | ActivityLogUpdateManyWithWhereWithoutPayoutsInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AffiliateBonusCreateNestedManyWithoutBonusInput = {
    create?: XOR<AffiliateBonusCreateWithoutBonusInput, AffiliateBonusUncheckedCreateWithoutBonusInput> | AffiliateBonusCreateWithoutBonusInput[] | AffiliateBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutBonusInput | AffiliateBonusCreateOrConnectWithoutBonusInput[]
    createMany?: AffiliateBonusCreateManyBonusInputEnvelope
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
  }

  export type StoresCreateNestedOneWithoutBonusInput = {
    create?: XOR<StoresCreateWithoutBonusInput, StoresUncheckedCreateWithoutBonusInput>
    connectOrCreate?: StoresCreateOrConnectWithoutBonusInput
    connect?: StoresWhereUniqueInput
  }

  export type ProgramBonusCreateNestedManyWithoutBonusInput = {
    create?: XOR<ProgramBonusCreateWithoutBonusInput, ProgramBonusUncheckedCreateWithoutBonusInput> | ProgramBonusCreateWithoutBonusInput[] | ProgramBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutBonusInput | ProgramBonusCreateOrConnectWithoutBonusInput[]
    createMany?: ProgramBonusCreateManyBonusInputEnvelope
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
  }

  export type AffiliateBonusUncheckedCreateNestedManyWithoutBonusInput = {
    create?: XOR<AffiliateBonusCreateWithoutBonusInput, AffiliateBonusUncheckedCreateWithoutBonusInput> | AffiliateBonusCreateWithoutBonusInput[] | AffiliateBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutBonusInput | AffiliateBonusCreateOrConnectWithoutBonusInput[]
    createMany?: AffiliateBonusCreateManyBonusInputEnvelope
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
  }

  export type ProgramBonusUncheckedCreateNestedManyWithoutBonusInput = {
    create?: XOR<ProgramBonusCreateWithoutBonusInput, ProgramBonusUncheckedCreateWithoutBonusInput> | ProgramBonusCreateWithoutBonusInput[] | ProgramBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutBonusInput | ProgramBonusCreateOrConnectWithoutBonusInput[]
    createMany?: ProgramBonusCreateManyBonusInputEnvelope
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
  }

  export type EnumBonusTypeFieldUpdateOperationsInput = {
    set?: $Enums.BonusType
  }

  export type AffiliateBonusUpdateManyWithoutBonusNestedInput = {
    create?: XOR<AffiliateBonusCreateWithoutBonusInput, AffiliateBonusUncheckedCreateWithoutBonusInput> | AffiliateBonusCreateWithoutBonusInput[] | AffiliateBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutBonusInput | AffiliateBonusCreateOrConnectWithoutBonusInput[]
    upsert?: AffiliateBonusUpsertWithWhereUniqueWithoutBonusInput | AffiliateBonusUpsertWithWhereUniqueWithoutBonusInput[]
    createMany?: AffiliateBonusCreateManyBonusInputEnvelope
    set?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    disconnect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    delete?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    update?: AffiliateBonusUpdateWithWhereUniqueWithoutBonusInput | AffiliateBonusUpdateWithWhereUniqueWithoutBonusInput[]
    updateMany?: AffiliateBonusUpdateManyWithWhereWithoutBonusInput | AffiliateBonusUpdateManyWithWhereWithoutBonusInput[]
    deleteMany?: AffiliateBonusScalarWhereInput | AffiliateBonusScalarWhereInput[]
  }

  export type StoresUpdateOneRequiredWithoutBonusNestedInput = {
    create?: XOR<StoresCreateWithoutBonusInput, StoresUncheckedCreateWithoutBonusInput>
    connectOrCreate?: StoresCreateOrConnectWithoutBonusInput
    upsert?: StoresUpsertWithoutBonusInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutBonusInput, StoresUpdateWithoutBonusInput>, StoresUncheckedUpdateWithoutBonusInput>
  }

  export type ProgramBonusUpdateManyWithoutBonusNestedInput = {
    create?: XOR<ProgramBonusCreateWithoutBonusInput, ProgramBonusUncheckedCreateWithoutBonusInput> | ProgramBonusCreateWithoutBonusInput[] | ProgramBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutBonusInput | ProgramBonusCreateOrConnectWithoutBonusInput[]
    upsert?: ProgramBonusUpsertWithWhereUniqueWithoutBonusInput | ProgramBonusUpsertWithWhereUniqueWithoutBonusInput[]
    createMany?: ProgramBonusCreateManyBonusInputEnvelope
    set?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    disconnect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    delete?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    update?: ProgramBonusUpdateWithWhereUniqueWithoutBonusInput | ProgramBonusUpdateWithWhereUniqueWithoutBonusInput[]
    updateMany?: ProgramBonusUpdateManyWithWhereWithoutBonusInput | ProgramBonusUpdateManyWithWhereWithoutBonusInput[]
    deleteMany?: ProgramBonusScalarWhereInput | ProgramBonusScalarWhereInput[]
  }

  export type AffiliateBonusUncheckedUpdateManyWithoutBonusNestedInput = {
    create?: XOR<AffiliateBonusCreateWithoutBonusInput, AffiliateBonusUncheckedCreateWithoutBonusInput> | AffiliateBonusCreateWithoutBonusInput[] | AffiliateBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutBonusInput | AffiliateBonusCreateOrConnectWithoutBonusInput[]
    upsert?: AffiliateBonusUpsertWithWhereUniqueWithoutBonusInput | AffiliateBonusUpsertWithWhereUniqueWithoutBonusInput[]
    createMany?: AffiliateBonusCreateManyBonusInputEnvelope
    set?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    disconnect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    delete?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    update?: AffiliateBonusUpdateWithWhereUniqueWithoutBonusInput | AffiliateBonusUpdateWithWhereUniqueWithoutBonusInput[]
    updateMany?: AffiliateBonusUpdateManyWithWhereWithoutBonusInput | AffiliateBonusUpdateManyWithWhereWithoutBonusInput[]
    deleteMany?: AffiliateBonusScalarWhereInput | AffiliateBonusScalarWhereInput[]
  }

  export type ProgramBonusUncheckedUpdateManyWithoutBonusNestedInput = {
    create?: XOR<ProgramBonusCreateWithoutBonusInput, ProgramBonusUncheckedCreateWithoutBonusInput> | ProgramBonusCreateWithoutBonusInput[] | ProgramBonusUncheckedCreateWithoutBonusInput[]
    connectOrCreate?: ProgramBonusCreateOrConnectWithoutBonusInput | ProgramBonusCreateOrConnectWithoutBonusInput[]
    upsert?: ProgramBonusUpsertWithWhereUniqueWithoutBonusInput | ProgramBonusUpsertWithWhereUniqueWithoutBonusInput[]
    createMany?: ProgramBonusCreateManyBonusInputEnvelope
    set?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    disconnect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    delete?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    connect?: ProgramBonusWhereUniqueInput | ProgramBonusWhereUniqueInput[]
    update?: ProgramBonusUpdateWithWhereUniqueWithoutBonusInput | ProgramBonusUpdateWithWhereUniqueWithoutBonusInput[]
    updateMany?: ProgramBonusUpdateManyWithWhereWithoutBonusInput | ProgramBonusUpdateManyWithWhereWithoutBonusInput[]
    deleteMany?: ProgramBonusScalarWhereInput | ProgramBonusScalarWhereInput[]
  }

  export type AffiliateGiftsCreateNestedManyWithoutGiftsInput = {
    create?: XOR<AffiliateGiftsCreateWithoutGiftsInput, AffiliateGiftsUncheckedCreateWithoutGiftsInput> | AffiliateGiftsCreateWithoutGiftsInput[] | AffiliateGiftsUncheckedCreateWithoutGiftsInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutGiftsInput | AffiliateGiftsCreateOrConnectWithoutGiftsInput[]
    createMany?: AffiliateGiftsCreateManyGiftsInputEnvelope
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
  }

  export type StoresCreateNestedOneWithoutGiftsInput = {
    create?: XOR<StoresCreateWithoutGiftsInput, StoresUncheckedCreateWithoutGiftsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutGiftsInput
    connect?: StoresWhereUniqueInput
  }

  export type AffiliateGiftsUncheckedCreateNestedManyWithoutGiftsInput = {
    create?: XOR<AffiliateGiftsCreateWithoutGiftsInput, AffiliateGiftsUncheckedCreateWithoutGiftsInput> | AffiliateGiftsCreateWithoutGiftsInput[] | AffiliateGiftsUncheckedCreateWithoutGiftsInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutGiftsInput | AffiliateGiftsCreateOrConnectWithoutGiftsInput[]
    createMany?: AffiliateGiftsCreateManyGiftsInputEnvelope
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
  }

  export type EnumGiftTypeFieldUpdateOperationsInput = {
    set?: $Enums.GiftType
  }

  export type EnumShippingTypeFieldUpdateOperationsInput = {
    set?: $Enums.ShippingType
  }

  export type AffiliateGiftsUpdateManyWithoutGiftsNestedInput = {
    create?: XOR<AffiliateGiftsCreateWithoutGiftsInput, AffiliateGiftsUncheckedCreateWithoutGiftsInput> | AffiliateGiftsCreateWithoutGiftsInput[] | AffiliateGiftsUncheckedCreateWithoutGiftsInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutGiftsInput | AffiliateGiftsCreateOrConnectWithoutGiftsInput[]
    upsert?: AffiliateGiftsUpsertWithWhereUniqueWithoutGiftsInput | AffiliateGiftsUpsertWithWhereUniqueWithoutGiftsInput[]
    createMany?: AffiliateGiftsCreateManyGiftsInputEnvelope
    set?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    disconnect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    delete?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    update?: AffiliateGiftsUpdateWithWhereUniqueWithoutGiftsInput | AffiliateGiftsUpdateWithWhereUniqueWithoutGiftsInput[]
    updateMany?: AffiliateGiftsUpdateManyWithWhereWithoutGiftsInput | AffiliateGiftsUpdateManyWithWhereWithoutGiftsInput[]
    deleteMany?: AffiliateGiftsScalarWhereInput | AffiliateGiftsScalarWhereInput[]
  }

  export type StoresUpdateOneRequiredWithoutGiftsNestedInput = {
    create?: XOR<StoresCreateWithoutGiftsInput, StoresUncheckedCreateWithoutGiftsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutGiftsInput
    upsert?: StoresUpsertWithoutGiftsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutGiftsInput, StoresUpdateWithoutGiftsInput>, StoresUncheckedUpdateWithoutGiftsInput>
  }

  export type AffiliateGiftsUncheckedUpdateManyWithoutGiftsNestedInput = {
    create?: XOR<AffiliateGiftsCreateWithoutGiftsInput, AffiliateGiftsUncheckedCreateWithoutGiftsInput> | AffiliateGiftsCreateWithoutGiftsInput[] | AffiliateGiftsUncheckedCreateWithoutGiftsInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutGiftsInput | AffiliateGiftsCreateOrConnectWithoutGiftsInput[]
    upsert?: AffiliateGiftsUpsertWithWhereUniqueWithoutGiftsInput | AffiliateGiftsUpsertWithWhereUniqueWithoutGiftsInput[]
    createMany?: AffiliateGiftsCreateManyGiftsInputEnvelope
    set?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    disconnect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    delete?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    update?: AffiliateGiftsUpdateWithWhereUniqueWithoutGiftsInput | AffiliateGiftsUpdateWithWhereUniqueWithoutGiftsInput[]
    updateMany?: AffiliateGiftsUpdateManyWithWhereWithoutGiftsInput | AffiliateGiftsUpdateManyWithWhereWithoutGiftsInput[]
    deleteMany?: AffiliateGiftsScalarWhereInput | AffiliateGiftsScalarWhereInput[]
  }

  export type AffiliatesCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AffiliatesCreateWithoutTransactionsInput, AffiliatesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutTransactionsInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<StoresCreateWithoutTransactionsInput, StoresUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutTransactionsInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumTransactionReferenceTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionReferenceType
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type AffiliatesUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<AffiliatesCreateWithoutTransactionsInput, AffiliatesUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutTransactionsInput
    upsert?: AffiliatesUpsertWithoutTransactionsInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutTransactionsInput, AffiliatesUpdateWithoutTransactionsInput>, AffiliatesUncheckedUpdateWithoutTransactionsInput>
  }

  export type StoresUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<StoresCreateWithoutTransactionsInput, StoresUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutTransactionsInput
    upsert?: StoresUpsertWithoutTransactionsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutTransactionsInput, StoresUpdateWithoutTransactionsInput>, StoresUncheckedUpdateWithoutTransactionsInput>
  }

  export type StoresCreateNestedOneWithoutSettingsInput = {
    create?: XOR<StoresCreateWithoutSettingsInput, StoresUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutSettingsInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumApprovalModeTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalModeType
  }

  export type EnumCommissionCalculationTypeFieldUpdateOperationsInput = {
    set?: $Enums.CommissionCalculationType
  }

  export type StoresUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<StoresCreateWithoutSettingsInput, StoresUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutSettingsInput
    upsert?: StoresUpsertWithoutSettingsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutSettingsInput, StoresUpdateWithoutSettingsInput>, StoresUncheckedUpdateWithoutSettingsInput>
  }

  export type StoresCreateNestedOneWithoutJobsInput = {
    create?: XOR<StoresCreateWithoutJobsInput, StoresUncheckedCreateWithoutJobsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutJobsInput
    connect?: StoresWhereUniqueInput
  }

  export type PayoutsCreateNestedOneWithoutJobsInput = {
    create?: XOR<PayoutsCreateWithoutJobsInput, PayoutsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PayoutsCreateOrConnectWithoutJobsInput
    connect?: PayoutsWhereUniqueInput
  }

  export type PayoutsUncheckedCreateNestedOneWithoutJobsInput = {
    create?: XOR<PayoutsCreateWithoutJobsInput, PayoutsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PayoutsCreateOrConnectWithoutJobsInput
    connect?: PayoutsWhereUniqueInput
  }

  export type EnumJobsStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.JobsStatusType
  }

  export type EnumJobTypeFieldUpdateOperationsInput = {
    set?: $Enums.JobType
  }

  export type StoresUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<StoresCreateWithoutJobsInput, StoresUncheckedCreateWithoutJobsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutJobsInput
    upsert?: StoresUpsertWithoutJobsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutJobsInput, StoresUpdateWithoutJobsInput>, StoresUncheckedUpdateWithoutJobsInput>
  }

  export type PayoutsUpdateOneWithoutJobsNestedInput = {
    create?: XOR<PayoutsCreateWithoutJobsInput, PayoutsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PayoutsCreateOrConnectWithoutJobsInput
    upsert?: PayoutsUpsertWithoutJobsInput
    disconnect?: PayoutsWhereInput | boolean
    delete?: PayoutsWhereInput | boolean
    connect?: PayoutsWhereUniqueInput
    update?: XOR<XOR<PayoutsUpdateToOneWithWhereWithoutJobsInput, PayoutsUpdateWithoutJobsInput>, PayoutsUncheckedUpdateWithoutJobsInput>
  }

  export type PayoutsUncheckedUpdateOneWithoutJobsNestedInput = {
    create?: XOR<PayoutsCreateWithoutJobsInput, PayoutsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: PayoutsCreateOrConnectWithoutJobsInput
    upsert?: PayoutsUpsertWithoutJobsInput
    disconnect?: PayoutsWhereInput | boolean
    delete?: PayoutsWhereInput | boolean
    connect?: PayoutsWhereUniqueInput
    update?: XOR<XOR<PayoutsUpdateToOneWithWhereWithoutJobsInput, PayoutsUpdateWithoutJobsInput>, PayoutsUncheckedUpdateWithoutJobsInput>
  }

  export type AffiliatesCreateNestedOneWithoutCustomersInput = {
    create?: XOR<AffiliatesCreateWithoutCustomersInput, AffiliatesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutCustomersInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutCustomersInput = {
    create?: XOR<StoresCreateWithoutCustomersInput, StoresUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCustomersInput
    connect?: StoresWhereUniqueInput
  }

  export type OrderItemsCreateNestedManyWithoutCustomersInput = {
    create?: XOR<OrderItemsCreateWithoutCustomersInput, OrderItemsUncheckedCreateWithoutCustomersInput> | OrderItemsCreateWithoutCustomersInput[] | OrderItemsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutCustomersInput | OrderItemsCreateOrConnectWithoutCustomersInput[]
    createMany?: OrderItemsCreateManyCustomersInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type OrdersCreateNestedManyWithoutCustomersInput = {
    create?: XOR<OrdersCreateWithoutCustomersInput, OrdersUncheckedCreateWithoutCustomersInput> | OrdersCreateWithoutCustomersInput[] | OrdersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutCustomersInput | OrdersCreateOrConnectWithoutCustomersInput[]
    createMany?: OrdersCreateManyCustomersInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type OrderItemsUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<OrderItemsCreateWithoutCustomersInput, OrderItemsUncheckedCreateWithoutCustomersInput> | OrderItemsCreateWithoutCustomersInput[] | OrderItemsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutCustomersInput | OrderItemsCreateOrConnectWithoutCustomersInput[]
    createMany?: OrderItemsCreateManyCustomersInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutCustomersInput = {
    create?: XOR<OrdersCreateWithoutCustomersInput, OrdersUncheckedCreateWithoutCustomersInput> | OrdersCreateWithoutCustomersInput[] | OrdersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutCustomersInput | OrdersCreateOrConnectWithoutCustomersInput[]
    createMany?: OrdersCreateManyCustomersInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type EnumContactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContactType
  }

  export type AffiliatesUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<AffiliatesCreateWithoutCustomersInput, AffiliatesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutCustomersInput
    upsert?: AffiliatesUpsertWithoutCustomersInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutCustomersInput, AffiliatesUpdateWithoutCustomersInput>, AffiliatesUncheckedUpdateWithoutCustomersInput>
  }

  export type StoresUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<StoresCreateWithoutCustomersInput, StoresUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: StoresCreateOrConnectWithoutCustomersInput
    upsert?: StoresUpsertWithoutCustomersInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutCustomersInput, StoresUpdateWithoutCustomersInput>, StoresUncheckedUpdateWithoutCustomersInput>
  }

  export type OrderItemsUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<OrderItemsCreateWithoutCustomersInput, OrderItemsUncheckedCreateWithoutCustomersInput> | OrderItemsCreateWithoutCustomersInput[] | OrderItemsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutCustomersInput | OrderItemsCreateOrConnectWithoutCustomersInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutCustomersInput | OrderItemsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: OrderItemsCreateManyCustomersInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutCustomersInput | OrderItemsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutCustomersInput | OrderItemsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type OrdersUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<OrdersCreateWithoutCustomersInput, OrdersUncheckedCreateWithoutCustomersInput> | OrdersCreateWithoutCustomersInput[] | OrdersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutCustomersInput | OrdersCreateOrConnectWithoutCustomersInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutCustomersInput | OrdersUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: OrdersCreateManyCustomersInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutCustomersInput | OrdersUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutCustomersInput | OrdersUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type OrderItemsUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<OrderItemsCreateWithoutCustomersInput, OrderItemsUncheckedCreateWithoutCustomersInput> | OrderItemsCreateWithoutCustomersInput[] | OrderItemsUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutCustomersInput | OrderItemsCreateOrConnectWithoutCustomersInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutCustomersInput | OrderItemsUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: OrderItemsCreateManyCustomersInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutCustomersInput | OrderItemsUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutCustomersInput | OrderItemsUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutCustomersNestedInput = {
    create?: XOR<OrdersCreateWithoutCustomersInput, OrdersUncheckedCreateWithoutCustomersInput> | OrdersCreateWithoutCustomersInput[] | OrdersUncheckedCreateWithoutCustomersInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutCustomersInput | OrdersCreateOrConnectWithoutCustomersInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutCustomersInput | OrdersUpsertWithWhereUniqueWithoutCustomersInput[]
    createMany?: OrdersCreateManyCustomersInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutCustomersInput | OrdersUpdateWithWhereUniqueWithoutCustomersInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutCustomersInput | OrdersUpdateManyWithWhereWithoutCustomersInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type AffiliateBonusCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateBonusCreateWithoutAffiliatesInput, AffiliateBonusUncheckedCreateWithoutAffiliatesInput> | AffiliateBonusCreateWithoutAffiliatesInput[] | AffiliateBonusUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutAffiliatesInput | AffiliateBonusCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateBonusCreateManyAffiliatesInputEnvelope
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
  }

  export type AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateDiscountsCreateWithoutAffiliatesInput, AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput> | AffiliateDiscountsCreateWithoutAffiliatesInput[] | AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateDiscountsCreateOrConnectWithoutAffiliatesInput | AffiliateDiscountsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateDiscountsCreateManyAffiliatesInputEnvelope
    connect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
  }

  export type AffiliateGiftsCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateGiftsCreateWithoutAffiliatesInput, AffiliateGiftsUncheckedCreateWithoutAffiliatesInput> | AffiliateGiftsCreateWithoutAffiliatesInput[] | AffiliateGiftsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutAffiliatesInput | AffiliateGiftsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateGiftsCreateManyAffiliatesInputEnvelope
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
  }

  export type AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateProgramHistoryCreateWithoutAffiliatesInput, AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput> | AffiliateProgramHistoryCreateWithoutAffiliatesInput[] | AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateProgramHistoryCreateOrConnectWithoutAffiliatesInput | AffiliateProgramHistoryCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateProgramHistoryCreateManyAffiliatesInputEnvelope
    connect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
  }

  export type AffiliateProgramsCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateProgramsCreateWithoutAffiliatesInput, AffiliateProgramsUncheckedCreateWithoutAffiliatesInput> | AffiliateProgramsCreateWithoutAffiliatesInput[] | AffiliateProgramsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutAffiliatesInput | AffiliateProgramsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateProgramsCreateManyAffiliatesInputEnvelope
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
  }

  export type MembersCreateNestedOneWithoutAffiliatesInput = {
    create?: XOR<MembersCreateWithoutAffiliatesInput, MembersUncheckedCreateWithoutAffiliatesInput>
    connectOrCreate?: MembersCreateOrConnectWithoutAffiliatesInput
    connect?: MembersWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutAffiliatesInput = {
    create?: XOR<StoresCreateWithoutAffiliatesInput, StoresUncheckedCreateWithoutAffiliatesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliatesInput
    connect?: StoresWhereUniqueInput
  }

  export type CommissionsCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<CommissionsCreateWithoutAffiliatesInput, CommissionsUncheckedCreateWithoutAffiliatesInput> | CommissionsCreateWithoutAffiliatesInput[] | CommissionsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: CommissionsCreateOrConnectWithoutAffiliatesInput | CommissionsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: CommissionsCreateManyAffiliatesInputEnvelope
    connect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
  }

  export type CustomersCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<CustomersCreateWithoutAffiliatesInput, CustomersUncheckedCreateWithoutAffiliatesInput> | CustomersCreateWithoutAffiliatesInput[] | CustomersUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutAffiliatesInput | CustomersCreateOrConnectWithoutAffiliatesInput[]
    createMany?: CustomersCreateManyAffiliatesInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type OrderItemsCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<OrderItemsCreateWithoutAffiliatesInput, OrderItemsUncheckedCreateWithoutAffiliatesInput> | OrderItemsCreateWithoutAffiliatesInput[] | OrderItemsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutAffiliatesInput | OrderItemsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: OrderItemsCreateManyAffiliatesInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type OrdersCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<OrdersCreateWithoutAffiliatesInput, OrdersUncheckedCreateWithoutAffiliatesInput> | OrdersCreateWithoutAffiliatesInput[] | OrdersUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAffiliatesInput | OrdersCreateOrConnectWithoutAffiliatesInput[]
    createMany?: OrdersCreateManyAffiliatesInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type PayoutsCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<PayoutsCreateWithoutAffiliatesInput, PayoutsUncheckedCreateWithoutAffiliatesInput> | PayoutsCreateWithoutAffiliatesInput[] | PayoutsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: PayoutsCreateOrConnectWithoutAffiliatesInput | PayoutsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: PayoutsCreateManyAffiliatesInputEnvelope
    connect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
  }

  export type TransactionsCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<TransactionsCreateWithoutAffiliatesInput, TransactionsUncheckedCreateWithoutAffiliatesInput> | TransactionsCreateWithoutAffiliatesInput[] | TransactionsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutAffiliatesInput | TransactionsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: TransactionsCreateManyAffiliatesInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<ActivityLogCreateWithoutAffiliatesInput, ActivityLogUncheckedCreateWithoutAffiliatesInput> | ActivityLogCreateWithoutAffiliatesInput[] | ActivityLogUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAffiliatesInput | ActivityLogCreateOrConnectWithoutAffiliatesInput[]
    createMany?: ActivityLogCreateManyAffiliatesInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateBonusCreateWithoutAffiliatesInput, AffiliateBonusUncheckedCreateWithoutAffiliatesInput> | AffiliateBonusCreateWithoutAffiliatesInput[] | AffiliateBonusUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutAffiliatesInput | AffiliateBonusCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateBonusCreateManyAffiliatesInputEnvelope
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
  }

  export type AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateDiscountsCreateWithoutAffiliatesInput, AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput> | AffiliateDiscountsCreateWithoutAffiliatesInput[] | AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateDiscountsCreateOrConnectWithoutAffiliatesInput | AffiliateDiscountsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateDiscountsCreateManyAffiliatesInputEnvelope
    connect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
  }

  export type AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateGiftsCreateWithoutAffiliatesInput, AffiliateGiftsUncheckedCreateWithoutAffiliatesInput> | AffiliateGiftsCreateWithoutAffiliatesInput[] | AffiliateGiftsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutAffiliatesInput | AffiliateGiftsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateGiftsCreateManyAffiliatesInputEnvelope
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
  }

  export type AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateProgramHistoryCreateWithoutAffiliatesInput, AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput> | AffiliateProgramHistoryCreateWithoutAffiliatesInput[] | AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateProgramHistoryCreateOrConnectWithoutAffiliatesInput | AffiliateProgramHistoryCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateProgramHistoryCreateManyAffiliatesInputEnvelope
    connect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
  }

  export type AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<AffiliateProgramsCreateWithoutAffiliatesInput, AffiliateProgramsUncheckedCreateWithoutAffiliatesInput> | AffiliateProgramsCreateWithoutAffiliatesInput[] | AffiliateProgramsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutAffiliatesInput | AffiliateProgramsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: AffiliateProgramsCreateManyAffiliatesInputEnvelope
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
  }

  export type CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<CommissionsCreateWithoutAffiliatesInput, CommissionsUncheckedCreateWithoutAffiliatesInput> | CommissionsCreateWithoutAffiliatesInput[] | CommissionsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: CommissionsCreateOrConnectWithoutAffiliatesInput | CommissionsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: CommissionsCreateManyAffiliatesInputEnvelope
    connect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
  }

  export type CustomersUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<CustomersCreateWithoutAffiliatesInput, CustomersUncheckedCreateWithoutAffiliatesInput> | CustomersCreateWithoutAffiliatesInput[] | CustomersUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutAffiliatesInput | CustomersCreateOrConnectWithoutAffiliatesInput[]
    createMany?: CustomersCreateManyAffiliatesInputEnvelope
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
  }

  export type OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<OrderItemsCreateWithoutAffiliatesInput, OrderItemsUncheckedCreateWithoutAffiliatesInput> | OrderItemsCreateWithoutAffiliatesInput[] | OrderItemsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutAffiliatesInput | OrderItemsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: OrderItemsCreateManyAffiliatesInputEnvelope
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
  }

  export type OrdersUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<OrdersCreateWithoutAffiliatesInput, OrdersUncheckedCreateWithoutAffiliatesInput> | OrdersCreateWithoutAffiliatesInput[] | OrdersUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAffiliatesInput | OrdersCreateOrConnectWithoutAffiliatesInput[]
    createMany?: OrdersCreateManyAffiliatesInputEnvelope
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
  }

  export type PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<PayoutsCreateWithoutAffiliatesInput, PayoutsUncheckedCreateWithoutAffiliatesInput> | PayoutsCreateWithoutAffiliatesInput[] | PayoutsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: PayoutsCreateOrConnectWithoutAffiliatesInput | PayoutsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: PayoutsCreateManyAffiliatesInputEnvelope
    connect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
  }

  export type TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<TransactionsCreateWithoutAffiliatesInput, TransactionsUncheckedCreateWithoutAffiliatesInput> | TransactionsCreateWithoutAffiliatesInput[] | TransactionsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutAffiliatesInput | TransactionsCreateOrConnectWithoutAffiliatesInput[]
    createMany?: TransactionsCreateManyAffiliatesInputEnvelope
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput = {
    create?: XOR<ActivityLogCreateWithoutAffiliatesInput, ActivityLogUncheckedCreateWithoutAffiliatesInput> | ActivityLogCreateWithoutAffiliatesInput[] | ActivityLogUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAffiliatesInput | ActivityLogCreateOrConnectWithoutAffiliatesInput[]
    createMany?: ActivityLogCreateManyAffiliatesInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type EnumAffiliateStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.AffiliateStatusType
  }

  export type NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.AffiliateSourceType | null
  }

  export type AffiliateBonusUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateBonusCreateWithoutAffiliatesInput, AffiliateBonusUncheckedCreateWithoutAffiliatesInput> | AffiliateBonusCreateWithoutAffiliatesInput[] | AffiliateBonusUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutAffiliatesInput | AffiliateBonusCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateBonusUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateBonusUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateBonusCreateManyAffiliatesInputEnvelope
    set?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    disconnect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    delete?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    update?: AffiliateBonusUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateBonusUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateBonusUpdateManyWithWhereWithoutAffiliatesInput | AffiliateBonusUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateBonusScalarWhereInput | AffiliateBonusScalarWhereInput[]
  }

  export type AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateDiscountsCreateWithoutAffiliatesInput, AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput> | AffiliateDiscountsCreateWithoutAffiliatesInput[] | AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateDiscountsCreateOrConnectWithoutAffiliatesInput | AffiliateDiscountsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateDiscountsUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateDiscountsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateDiscountsCreateManyAffiliatesInputEnvelope
    set?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    disconnect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    delete?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    connect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    update?: AffiliateDiscountsUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateDiscountsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateDiscountsUpdateManyWithWhereWithoutAffiliatesInput | AffiliateDiscountsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateDiscountsScalarWhereInput | AffiliateDiscountsScalarWhereInput[]
  }

  export type AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateGiftsCreateWithoutAffiliatesInput, AffiliateGiftsUncheckedCreateWithoutAffiliatesInput> | AffiliateGiftsCreateWithoutAffiliatesInput[] | AffiliateGiftsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutAffiliatesInput | AffiliateGiftsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateGiftsUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateGiftsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateGiftsCreateManyAffiliatesInputEnvelope
    set?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    disconnect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    delete?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    update?: AffiliateGiftsUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateGiftsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateGiftsUpdateManyWithWhereWithoutAffiliatesInput | AffiliateGiftsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateGiftsScalarWhereInput | AffiliateGiftsScalarWhereInput[]
  }

  export type AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateProgramHistoryCreateWithoutAffiliatesInput, AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput> | AffiliateProgramHistoryCreateWithoutAffiliatesInput[] | AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateProgramHistoryCreateOrConnectWithoutAffiliatesInput | AffiliateProgramHistoryCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateProgramHistoryUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateProgramHistoryUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateProgramHistoryCreateManyAffiliatesInputEnvelope
    set?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    disconnect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    delete?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    connect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    update?: AffiliateProgramHistoryUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateProgramHistoryUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateProgramHistoryUpdateManyWithWhereWithoutAffiliatesInput | AffiliateProgramHistoryUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateProgramHistoryScalarWhereInput | AffiliateProgramHistoryScalarWhereInput[]
  }

  export type AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateProgramsCreateWithoutAffiliatesInput, AffiliateProgramsUncheckedCreateWithoutAffiliatesInput> | AffiliateProgramsCreateWithoutAffiliatesInput[] | AffiliateProgramsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutAffiliatesInput | AffiliateProgramsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateProgramsUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateProgramsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateProgramsCreateManyAffiliatesInputEnvelope
    set?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    disconnect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    delete?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    update?: AffiliateProgramsUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateProgramsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateProgramsUpdateManyWithWhereWithoutAffiliatesInput | AffiliateProgramsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateProgramsScalarWhereInput | AffiliateProgramsScalarWhereInput[]
  }

  export type MembersUpdateOneRequiredWithoutAffiliatesNestedInput = {
    create?: XOR<MembersCreateWithoutAffiliatesInput, MembersUncheckedCreateWithoutAffiliatesInput>
    connectOrCreate?: MembersCreateOrConnectWithoutAffiliatesInput
    upsert?: MembersUpsertWithoutAffiliatesInput
    connect?: MembersWhereUniqueInput
    update?: XOR<XOR<MembersUpdateToOneWithWhereWithoutAffiliatesInput, MembersUpdateWithoutAffiliatesInput>, MembersUncheckedUpdateWithoutAffiliatesInput>
  }

  export type StoresUpdateOneRequiredWithoutAffiliatesNestedInput = {
    create?: XOR<StoresCreateWithoutAffiliatesInput, StoresUncheckedCreateWithoutAffiliatesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliatesInput
    upsert?: StoresUpsertWithoutAffiliatesInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAffiliatesInput, StoresUpdateWithoutAffiliatesInput>, StoresUncheckedUpdateWithoutAffiliatesInput>
  }

  export type CommissionsUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<CommissionsCreateWithoutAffiliatesInput, CommissionsUncheckedCreateWithoutAffiliatesInput> | CommissionsCreateWithoutAffiliatesInput[] | CommissionsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: CommissionsCreateOrConnectWithoutAffiliatesInput | CommissionsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: CommissionsUpsertWithWhereUniqueWithoutAffiliatesInput | CommissionsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: CommissionsCreateManyAffiliatesInputEnvelope
    set?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    disconnect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    delete?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    connect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    update?: CommissionsUpdateWithWhereUniqueWithoutAffiliatesInput | CommissionsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: CommissionsUpdateManyWithWhereWithoutAffiliatesInput | CommissionsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: CommissionsScalarWhereInput | CommissionsScalarWhereInput[]
  }

  export type CustomersUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<CustomersCreateWithoutAffiliatesInput, CustomersUncheckedCreateWithoutAffiliatesInput> | CustomersCreateWithoutAffiliatesInput[] | CustomersUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutAffiliatesInput | CustomersCreateOrConnectWithoutAffiliatesInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutAffiliatesInput | CustomersUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: CustomersCreateManyAffiliatesInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutAffiliatesInput | CustomersUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutAffiliatesInput | CustomersUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type OrderItemsUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<OrderItemsCreateWithoutAffiliatesInput, OrderItemsUncheckedCreateWithoutAffiliatesInput> | OrderItemsCreateWithoutAffiliatesInput[] | OrderItemsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutAffiliatesInput | OrderItemsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutAffiliatesInput | OrderItemsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: OrderItemsCreateManyAffiliatesInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutAffiliatesInput | OrderItemsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutAffiliatesInput | OrderItemsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type OrdersUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<OrdersCreateWithoutAffiliatesInput, OrdersUncheckedCreateWithoutAffiliatesInput> | OrdersCreateWithoutAffiliatesInput[] | OrdersUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAffiliatesInput | OrdersCreateOrConnectWithoutAffiliatesInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutAffiliatesInput | OrdersUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: OrdersCreateManyAffiliatesInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutAffiliatesInput | OrdersUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutAffiliatesInput | OrdersUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type PayoutsUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<PayoutsCreateWithoutAffiliatesInput, PayoutsUncheckedCreateWithoutAffiliatesInput> | PayoutsCreateWithoutAffiliatesInput[] | PayoutsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: PayoutsCreateOrConnectWithoutAffiliatesInput | PayoutsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: PayoutsUpsertWithWhereUniqueWithoutAffiliatesInput | PayoutsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: PayoutsCreateManyAffiliatesInputEnvelope
    set?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    disconnect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    delete?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    connect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    update?: PayoutsUpdateWithWhereUniqueWithoutAffiliatesInput | PayoutsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: PayoutsUpdateManyWithWhereWithoutAffiliatesInput | PayoutsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: PayoutsScalarWhereInput | PayoutsScalarWhereInput[]
  }

  export type TransactionsUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<TransactionsCreateWithoutAffiliatesInput, TransactionsUncheckedCreateWithoutAffiliatesInput> | TransactionsCreateWithoutAffiliatesInput[] | TransactionsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutAffiliatesInput | TransactionsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutAffiliatesInput | TransactionsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: TransactionsCreateManyAffiliatesInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutAffiliatesInput | TransactionsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutAffiliatesInput | TransactionsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAffiliatesInput, ActivityLogUncheckedCreateWithoutAffiliatesInput> | ActivityLogCreateWithoutAffiliatesInput[] | ActivityLogUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAffiliatesInput | ActivityLogCreateOrConnectWithoutAffiliatesInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAffiliatesInput | ActivityLogUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: ActivityLogCreateManyAffiliatesInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAffiliatesInput | ActivityLogUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAffiliatesInput | ActivityLogUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateBonusCreateWithoutAffiliatesInput, AffiliateBonusUncheckedCreateWithoutAffiliatesInput> | AffiliateBonusCreateWithoutAffiliatesInput[] | AffiliateBonusUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateBonusCreateOrConnectWithoutAffiliatesInput | AffiliateBonusCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateBonusUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateBonusUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateBonusCreateManyAffiliatesInputEnvelope
    set?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    disconnect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    delete?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    connect?: AffiliateBonusWhereUniqueInput | AffiliateBonusWhereUniqueInput[]
    update?: AffiliateBonusUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateBonusUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateBonusUpdateManyWithWhereWithoutAffiliatesInput | AffiliateBonusUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateBonusScalarWhereInput | AffiliateBonusScalarWhereInput[]
  }

  export type AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateDiscountsCreateWithoutAffiliatesInput, AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput> | AffiliateDiscountsCreateWithoutAffiliatesInput[] | AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateDiscountsCreateOrConnectWithoutAffiliatesInput | AffiliateDiscountsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateDiscountsUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateDiscountsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateDiscountsCreateManyAffiliatesInputEnvelope
    set?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    disconnect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    delete?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    connect?: AffiliateDiscountsWhereUniqueInput | AffiliateDiscountsWhereUniqueInput[]
    update?: AffiliateDiscountsUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateDiscountsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateDiscountsUpdateManyWithWhereWithoutAffiliatesInput | AffiliateDiscountsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateDiscountsScalarWhereInput | AffiliateDiscountsScalarWhereInput[]
  }

  export type AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateGiftsCreateWithoutAffiliatesInput, AffiliateGiftsUncheckedCreateWithoutAffiliatesInput> | AffiliateGiftsCreateWithoutAffiliatesInput[] | AffiliateGiftsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateGiftsCreateOrConnectWithoutAffiliatesInput | AffiliateGiftsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateGiftsUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateGiftsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateGiftsCreateManyAffiliatesInputEnvelope
    set?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    disconnect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    delete?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    connect?: AffiliateGiftsWhereUniqueInput | AffiliateGiftsWhereUniqueInput[]
    update?: AffiliateGiftsUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateGiftsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateGiftsUpdateManyWithWhereWithoutAffiliatesInput | AffiliateGiftsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateGiftsScalarWhereInput | AffiliateGiftsScalarWhereInput[]
  }

  export type AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateProgramHistoryCreateWithoutAffiliatesInput, AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput> | AffiliateProgramHistoryCreateWithoutAffiliatesInput[] | AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateProgramHistoryCreateOrConnectWithoutAffiliatesInput | AffiliateProgramHistoryCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateProgramHistoryUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateProgramHistoryUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateProgramHistoryCreateManyAffiliatesInputEnvelope
    set?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    disconnect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    delete?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    connect?: AffiliateProgramHistoryWhereUniqueInput | AffiliateProgramHistoryWhereUniqueInput[]
    update?: AffiliateProgramHistoryUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateProgramHistoryUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateProgramHistoryUpdateManyWithWhereWithoutAffiliatesInput | AffiliateProgramHistoryUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateProgramHistoryScalarWhereInput | AffiliateProgramHistoryScalarWhereInput[]
  }

  export type AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<AffiliateProgramsCreateWithoutAffiliatesInput, AffiliateProgramsUncheckedCreateWithoutAffiliatesInput> | AffiliateProgramsCreateWithoutAffiliatesInput[] | AffiliateProgramsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: AffiliateProgramsCreateOrConnectWithoutAffiliatesInput | AffiliateProgramsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: AffiliateProgramsUpsertWithWhereUniqueWithoutAffiliatesInput | AffiliateProgramsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: AffiliateProgramsCreateManyAffiliatesInputEnvelope
    set?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    disconnect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    delete?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    connect?: AffiliateProgramsWhereUniqueInput | AffiliateProgramsWhereUniqueInput[]
    update?: AffiliateProgramsUpdateWithWhereUniqueWithoutAffiliatesInput | AffiliateProgramsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: AffiliateProgramsUpdateManyWithWhereWithoutAffiliatesInput | AffiliateProgramsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: AffiliateProgramsScalarWhereInput | AffiliateProgramsScalarWhereInput[]
  }

  export type CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<CommissionsCreateWithoutAffiliatesInput, CommissionsUncheckedCreateWithoutAffiliatesInput> | CommissionsCreateWithoutAffiliatesInput[] | CommissionsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: CommissionsCreateOrConnectWithoutAffiliatesInput | CommissionsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: CommissionsUpsertWithWhereUniqueWithoutAffiliatesInput | CommissionsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: CommissionsCreateManyAffiliatesInputEnvelope
    set?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    disconnect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    delete?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    connect?: CommissionsWhereUniqueInput | CommissionsWhereUniqueInput[]
    update?: CommissionsUpdateWithWhereUniqueWithoutAffiliatesInput | CommissionsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: CommissionsUpdateManyWithWhereWithoutAffiliatesInput | CommissionsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: CommissionsScalarWhereInput | CommissionsScalarWhereInput[]
  }

  export type CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<CustomersCreateWithoutAffiliatesInput, CustomersUncheckedCreateWithoutAffiliatesInput> | CustomersCreateWithoutAffiliatesInput[] | CustomersUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: CustomersCreateOrConnectWithoutAffiliatesInput | CustomersCreateOrConnectWithoutAffiliatesInput[]
    upsert?: CustomersUpsertWithWhereUniqueWithoutAffiliatesInput | CustomersUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: CustomersCreateManyAffiliatesInputEnvelope
    set?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    disconnect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    delete?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    connect?: CustomersWhereUniqueInput | CustomersWhereUniqueInput[]
    update?: CustomersUpdateWithWhereUniqueWithoutAffiliatesInput | CustomersUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: CustomersUpdateManyWithWhereWithoutAffiliatesInput | CustomersUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
  }

  export type OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<OrderItemsCreateWithoutAffiliatesInput, OrderItemsUncheckedCreateWithoutAffiliatesInput> | OrderItemsCreateWithoutAffiliatesInput[] | OrderItemsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: OrderItemsCreateOrConnectWithoutAffiliatesInput | OrderItemsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: OrderItemsUpsertWithWhereUniqueWithoutAffiliatesInput | OrderItemsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: OrderItemsCreateManyAffiliatesInputEnvelope
    set?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    disconnect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    delete?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    connect?: OrderItemsWhereUniqueInput | OrderItemsWhereUniqueInput[]
    update?: OrderItemsUpdateWithWhereUniqueWithoutAffiliatesInput | OrderItemsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: OrderItemsUpdateManyWithWhereWithoutAffiliatesInput | OrderItemsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
  }

  export type OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<OrdersCreateWithoutAffiliatesInput, OrdersUncheckedCreateWithoutAffiliatesInput> | OrdersCreateWithoutAffiliatesInput[] | OrdersUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: OrdersCreateOrConnectWithoutAffiliatesInput | OrdersCreateOrConnectWithoutAffiliatesInput[]
    upsert?: OrdersUpsertWithWhereUniqueWithoutAffiliatesInput | OrdersUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: OrdersCreateManyAffiliatesInputEnvelope
    set?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    disconnect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    delete?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    connect?: OrdersWhereUniqueInput | OrdersWhereUniqueInput[]
    update?: OrdersUpdateWithWhereUniqueWithoutAffiliatesInput | OrdersUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: OrdersUpdateManyWithWhereWithoutAffiliatesInput | OrdersUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
  }

  export type PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<PayoutsCreateWithoutAffiliatesInput, PayoutsUncheckedCreateWithoutAffiliatesInput> | PayoutsCreateWithoutAffiliatesInput[] | PayoutsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: PayoutsCreateOrConnectWithoutAffiliatesInput | PayoutsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: PayoutsUpsertWithWhereUniqueWithoutAffiliatesInput | PayoutsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: PayoutsCreateManyAffiliatesInputEnvelope
    set?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    disconnect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    delete?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    connect?: PayoutsWhereUniqueInput | PayoutsWhereUniqueInput[]
    update?: PayoutsUpdateWithWhereUniqueWithoutAffiliatesInput | PayoutsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: PayoutsUpdateManyWithWhereWithoutAffiliatesInput | PayoutsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: PayoutsScalarWhereInput | PayoutsScalarWhereInput[]
  }

  export type TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<TransactionsCreateWithoutAffiliatesInput, TransactionsUncheckedCreateWithoutAffiliatesInput> | TransactionsCreateWithoutAffiliatesInput[] | TransactionsUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: TransactionsCreateOrConnectWithoutAffiliatesInput | TransactionsCreateOrConnectWithoutAffiliatesInput[]
    upsert?: TransactionsUpsertWithWhereUniqueWithoutAffiliatesInput | TransactionsUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: TransactionsCreateManyAffiliatesInputEnvelope
    set?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    disconnect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    delete?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    connect?: TransactionsWhereUniqueInput | TransactionsWhereUniqueInput[]
    update?: TransactionsUpdateWithWhereUniqueWithoutAffiliatesInput | TransactionsUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: TransactionsUpdateManyWithWhereWithoutAffiliatesInput | TransactionsUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput = {
    create?: XOR<ActivityLogCreateWithoutAffiliatesInput, ActivityLogUncheckedCreateWithoutAffiliatesInput> | ActivityLogCreateWithoutAffiliatesInput[] | ActivityLogUncheckedCreateWithoutAffiliatesInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutAffiliatesInput | ActivityLogCreateOrConnectWithoutAffiliatesInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutAffiliatesInput | ActivityLogUpsertWithWhereUniqueWithoutAffiliatesInput[]
    createMany?: ActivityLogCreateManyAffiliatesInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutAffiliatesInput | ActivityLogUpdateWithWhereUniqueWithoutAffiliatesInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutAffiliatesInput | ActivityLogUpdateManyWithWhereWithoutAffiliatesInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AffiliatesCreateNestedOneWithoutAffiliate_programsInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_programsInput, AffiliatesUncheckedCreateWithoutAffiliate_programsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_programsInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type ProgramsCreateNestedOneWithoutAffiliate_programsInput = {
    create?: XOR<ProgramsCreateWithoutAffiliate_programsInput, ProgramsUncheckedCreateWithoutAffiliate_programsInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutAffiliate_programsInput
    connect?: ProgramsWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutAffiliate_programsInput = {
    create?: XOR<StoresCreateWithoutAffiliate_programsInput, StoresUncheckedCreateWithoutAffiliate_programsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_programsInput
    connect?: StoresWhereUniqueInput
  }

  export type AffiliatesUpdateOneRequiredWithoutAffiliate_programsNestedInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_programsInput, AffiliatesUncheckedCreateWithoutAffiliate_programsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_programsInput
    upsert?: AffiliatesUpsertWithoutAffiliate_programsInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutAffiliate_programsInput, AffiliatesUpdateWithoutAffiliate_programsInput>, AffiliatesUncheckedUpdateWithoutAffiliate_programsInput>
  }

  export type ProgramsUpdateOneRequiredWithoutAffiliate_programsNestedInput = {
    create?: XOR<ProgramsCreateWithoutAffiliate_programsInput, ProgramsUncheckedCreateWithoutAffiliate_programsInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutAffiliate_programsInput
    upsert?: ProgramsUpsertWithoutAffiliate_programsInput
    connect?: ProgramsWhereUniqueInput
    update?: XOR<XOR<ProgramsUpdateToOneWithWhereWithoutAffiliate_programsInput, ProgramsUpdateWithoutAffiliate_programsInput>, ProgramsUncheckedUpdateWithoutAffiliate_programsInput>
  }

  export type StoresUpdateOneRequiredWithoutAffiliate_programsNestedInput = {
    create?: XOR<StoresCreateWithoutAffiliate_programsInput, StoresUncheckedCreateWithoutAffiliate_programsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_programsInput
    upsert?: StoresUpsertWithoutAffiliate_programsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAffiliate_programsInput, StoresUpdateWithoutAffiliate_programsInput>, StoresUncheckedUpdateWithoutAffiliate_programsInput>
  }

  export type AffiliatesCreateNestedOneWithoutAffiliate_program_historyInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_program_historyInput, AffiliatesUncheckedCreateWithoutAffiliate_program_historyInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_program_historyInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutAffiliate_program_historyInput = {
    create?: XOR<StoresCreateWithoutAffiliate_program_historyInput, StoresUncheckedCreateWithoutAffiliate_program_historyInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_program_historyInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumProgramHistoryStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProgramHistoryStatusType
  }

  export type AffiliatesUpdateOneRequiredWithoutAffiliate_program_historyNestedInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_program_historyInput, AffiliatesUncheckedCreateWithoutAffiliate_program_historyInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_program_historyInput
    upsert?: AffiliatesUpsertWithoutAffiliate_program_historyInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutAffiliate_program_historyInput, AffiliatesUpdateWithoutAffiliate_program_historyInput>, AffiliatesUncheckedUpdateWithoutAffiliate_program_historyInput>
  }

  export type StoresUpdateOneRequiredWithoutAffiliate_program_historyNestedInput = {
    create?: XOR<StoresCreateWithoutAffiliate_program_historyInput, StoresUncheckedCreateWithoutAffiliate_program_historyInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_program_historyInput
    upsert?: StoresUpsertWithoutAffiliate_program_historyInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAffiliate_program_historyInput, StoresUpdateWithoutAffiliate_program_historyInput>, StoresUncheckedUpdateWithoutAffiliate_program_historyInput>
  }

  export type AffiliatesCreateNestedOneWithoutAffiliate_discountsInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_discountsInput, AffiliatesUncheckedCreateWithoutAffiliate_discountsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_discountsInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutAffiliate_discountsInput = {
    create?: XOR<StoresCreateWithoutAffiliate_discountsInput, StoresUncheckedCreateWithoutAffiliate_discountsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_discountsInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumDiscountStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountStatusType
  }

  export type AffiliatesUpdateOneRequiredWithoutAffiliate_discountsNestedInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_discountsInput, AffiliatesUncheckedCreateWithoutAffiliate_discountsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_discountsInput
    upsert?: AffiliatesUpsertWithoutAffiliate_discountsInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutAffiliate_discountsInput, AffiliatesUpdateWithoutAffiliate_discountsInput>, AffiliatesUncheckedUpdateWithoutAffiliate_discountsInput>
  }

  export type StoresUpdateOneRequiredWithoutAffiliate_discountsNestedInput = {
    create?: XOR<StoresCreateWithoutAffiliate_discountsInput, StoresUncheckedCreateWithoutAffiliate_discountsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_discountsInput
    upsert?: StoresUpsertWithoutAffiliate_discountsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAffiliate_discountsInput, StoresUpdateWithoutAffiliate_discountsInput>, StoresUncheckedUpdateWithoutAffiliate_discountsInput>
  }

  export type AffiliatesCreateNestedOneWithoutAffiliate_giftsInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_giftsInput, AffiliatesUncheckedCreateWithoutAffiliate_giftsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_giftsInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type GiftsCreateNestedOneWithoutAffiliate_giftsInput = {
    create?: XOR<GiftsCreateWithoutAffiliate_giftsInput, GiftsUncheckedCreateWithoutAffiliate_giftsInput>
    connectOrCreate?: GiftsCreateOrConnectWithoutAffiliate_giftsInput
    connect?: GiftsWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutAffiliate_giftsInput = {
    create?: XOR<StoresCreateWithoutAffiliate_giftsInput, StoresUncheckedCreateWithoutAffiliate_giftsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_giftsInput
    connect?: StoresWhereUniqueInput
  }

  export type AffiliatesUpdateOneRequiredWithoutAffiliate_giftsNestedInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_giftsInput, AffiliatesUncheckedCreateWithoutAffiliate_giftsInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_giftsInput
    upsert?: AffiliatesUpsertWithoutAffiliate_giftsInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutAffiliate_giftsInput, AffiliatesUpdateWithoutAffiliate_giftsInput>, AffiliatesUncheckedUpdateWithoutAffiliate_giftsInput>
  }

  export type GiftsUpdateOneRequiredWithoutAffiliate_giftsNestedInput = {
    create?: XOR<GiftsCreateWithoutAffiliate_giftsInput, GiftsUncheckedCreateWithoutAffiliate_giftsInput>
    connectOrCreate?: GiftsCreateOrConnectWithoutAffiliate_giftsInput
    upsert?: GiftsUpsertWithoutAffiliate_giftsInput
    connect?: GiftsWhereUniqueInput
    update?: XOR<XOR<GiftsUpdateToOneWithWhereWithoutAffiliate_giftsInput, GiftsUpdateWithoutAffiliate_giftsInput>, GiftsUncheckedUpdateWithoutAffiliate_giftsInput>
  }

  export type StoresUpdateOneRequiredWithoutAffiliate_giftsNestedInput = {
    create?: XOR<StoresCreateWithoutAffiliate_giftsInput, StoresUncheckedCreateWithoutAffiliate_giftsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_giftsInput
    upsert?: StoresUpsertWithoutAffiliate_giftsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAffiliate_giftsInput, StoresUpdateWithoutAffiliate_giftsInput>, StoresUncheckedUpdateWithoutAffiliate_giftsInput>
  }

  export type AffiliatesCreateNestedOneWithoutAffiliate_bonusInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_bonusInput, AffiliatesUncheckedCreateWithoutAffiliate_bonusInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_bonusInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type BonusCreateNestedOneWithoutAffiliate_bonusInput = {
    create?: XOR<BonusCreateWithoutAffiliate_bonusInput, BonusUncheckedCreateWithoutAffiliate_bonusInput>
    connectOrCreate?: BonusCreateOrConnectWithoutAffiliate_bonusInput
    connect?: BonusWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutAffiliate_bonusInput = {
    create?: XOR<StoresCreateWithoutAffiliate_bonusInput, StoresUncheckedCreateWithoutAffiliate_bonusInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_bonusInput
    connect?: StoresWhereUniqueInput
  }

  export type AffiliatesUpdateOneRequiredWithoutAffiliate_bonusNestedInput = {
    create?: XOR<AffiliatesCreateWithoutAffiliate_bonusInput, AffiliatesUncheckedCreateWithoutAffiliate_bonusInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutAffiliate_bonusInput
    upsert?: AffiliatesUpsertWithoutAffiliate_bonusInput
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutAffiliate_bonusInput, AffiliatesUpdateWithoutAffiliate_bonusInput>, AffiliatesUncheckedUpdateWithoutAffiliate_bonusInput>
  }

  export type BonusUpdateOneRequiredWithoutAffiliate_bonusNestedInput = {
    create?: XOR<BonusCreateWithoutAffiliate_bonusInput, BonusUncheckedCreateWithoutAffiliate_bonusInput>
    connectOrCreate?: BonusCreateOrConnectWithoutAffiliate_bonusInput
    upsert?: BonusUpsertWithoutAffiliate_bonusInput
    connect?: BonusWhereUniqueInput
    update?: XOR<XOR<BonusUpdateToOneWithWhereWithoutAffiliate_bonusInput, BonusUpdateWithoutAffiliate_bonusInput>, BonusUncheckedUpdateWithoutAffiliate_bonusInput>
  }

  export type StoresUpdateOneRequiredWithoutAffiliate_bonusNestedInput = {
    create?: XOR<StoresCreateWithoutAffiliate_bonusInput, StoresUncheckedCreateWithoutAffiliate_bonusInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAffiliate_bonusInput
    upsert?: StoresUpsertWithoutAffiliate_bonusInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAffiliate_bonusInput, StoresUpdateWithoutAffiliate_bonusInput>, StoresUncheckedUpdateWithoutAffiliate_bonusInput>
  }

  export type BonusCreateNestedOneWithoutProgram_bonusInput = {
    create?: XOR<BonusCreateWithoutProgram_bonusInput, BonusUncheckedCreateWithoutProgram_bonusInput>
    connectOrCreate?: BonusCreateOrConnectWithoutProgram_bonusInput
    connect?: BonusWhereUniqueInput
  }

  export type ProgramsCreateNestedOneWithoutProgram_bonusInput = {
    create?: XOR<ProgramsCreateWithoutProgram_bonusInput, ProgramsUncheckedCreateWithoutProgram_bonusInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutProgram_bonusInput
    connect?: ProgramsWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutProgram_bonusInput = {
    create?: XOR<StoresCreateWithoutProgram_bonusInput, StoresUncheckedCreateWithoutProgram_bonusInput>
    connectOrCreate?: StoresCreateOrConnectWithoutProgram_bonusInput
    connect?: StoresWhereUniqueInput
  }

  export type BonusUpdateOneRequiredWithoutProgram_bonusNestedInput = {
    create?: XOR<BonusCreateWithoutProgram_bonusInput, BonusUncheckedCreateWithoutProgram_bonusInput>
    connectOrCreate?: BonusCreateOrConnectWithoutProgram_bonusInput
    upsert?: BonusUpsertWithoutProgram_bonusInput
    connect?: BonusWhereUniqueInput
    update?: XOR<XOR<BonusUpdateToOneWithWhereWithoutProgram_bonusInput, BonusUpdateWithoutProgram_bonusInput>, BonusUncheckedUpdateWithoutProgram_bonusInput>
  }

  export type ProgramsUpdateOneRequiredWithoutProgram_bonusNestedInput = {
    create?: XOR<ProgramsCreateWithoutProgram_bonusInput, ProgramsUncheckedCreateWithoutProgram_bonusInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutProgram_bonusInput
    upsert?: ProgramsUpsertWithoutProgram_bonusInput
    connect?: ProgramsWhereUniqueInput
    update?: XOR<XOR<ProgramsUpdateToOneWithWhereWithoutProgram_bonusInput, ProgramsUpdateWithoutProgram_bonusInput>, ProgramsUncheckedUpdateWithoutProgram_bonusInput>
  }

  export type StoresUpdateOneRequiredWithoutProgram_bonusNestedInput = {
    create?: XOR<StoresCreateWithoutProgram_bonusInput, StoresUncheckedCreateWithoutProgram_bonusInput>
    connectOrCreate?: StoresCreateOrConnectWithoutProgram_bonusInput
    upsert?: StoresUpsertWithoutProgram_bonusInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutProgram_bonusInput, StoresUpdateWithoutProgram_bonusInput>, StoresUncheckedUpdateWithoutProgram_bonusInput>
  }

  export type StoresCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<StoresCreateWithoutNotificationsInput, StoresUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutNotificationsInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type EnumNotificationReceiverTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationReceiverType
  }

  export type EnumNotificationStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatusType
  }

  export type StoresUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<StoresCreateWithoutNotificationsInput, StoresUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutNotificationsInput
    upsert?: StoresUpsertWithoutNotificationsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutNotificationsInput, StoresUpdateWithoutNotificationsInput>, StoresUncheckedUpdateWithoutNotificationsInput>
  }

  export type StoresCreateNestedOneWithoutActivity_logInput = {
    create?: XOR<StoresCreateWithoutActivity_logInput, StoresUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: StoresCreateOrConnectWithoutActivity_logInput
    connect?: StoresWhereUniqueInput
  }

  export type AffiliatesCreateNestedOneWithoutActivity_logInput = {
    create?: XOR<AffiliatesCreateWithoutActivity_logInput, AffiliatesUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutActivity_logInput
    connect?: AffiliatesWhereUniqueInput
  }

  export type ProgramsCreateNestedOneWithoutActivity_logInput = {
    create?: XOR<ProgramsCreateWithoutActivity_logInput, ProgramsUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutActivity_logInput
    connect?: ProgramsWhereUniqueInput
  }

  export type OrdersCreateNestedOneWithoutActivity_logInput = {
    create?: XOR<OrdersCreateWithoutActivity_logInput, OrdersUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutActivity_logInput
    connect?: OrdersWhereUniqueInput
  }

  export type PayoutsCreateNestedOneWithoutActivity_logInput = {
    create?: XOR<PayoutsCreateWithoutActivity_logInput, PayoutsUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: PayoutsCreateOrConnectWithoutActivity_logInput
    connect?: PayoutsWhereUniqueInput
  }

  export type EnumActivityEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActivityEntityType
  }

  export type StoresUpdateOneRequiredWithoutActivity_logNestedInput = {
    create?: XOR<StoresCreateWithoutActivity_logInput, StoresUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: StoresCreateOrConnectWithoutActivity_logInput
    upsert?: StoresUpsertWithoutActivity_logInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutActivity_logInput, StoresUpdateWithoutActivity_logInput>, StoresUncheckedUpdateWithoutActivity_logInput>
  }

  export type AffiliatesUpdateOneWithoutActivity_logNestedInput = {
    create?: XOR<AffiliatesCreateWithoutActivity_logInput, AffiliatesUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: AffiliatesCreateOrConnectWithoutActivity_logInput
    upsert?: AffiliatesUpsertWithoutActivity_logInput
    disconnect?: AffiliatesWhereInput | boolean
    delete?: AffiliatesWhereInput | boolean
    connect?: AffiliatesWhereUniqueInput
    update?: XOR<XOR<AffiliatesUpdateToOneWithWhereWithoutActivity_logInput, AffiliatesUpdateWithoutActivity_logInput>, AffiliatesUncheckedUpdateWithoutActivity_logInput>
  }

  export type ProgramsUpdateOneWithoutActivity_logNestedInput = {
    create?: XOR<ProgramsCreateWithoutActivity_logInput, ProgramsUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: ProgramsCreateOrConnectWithoutActivity_logInput
    upsert?: ProgramsUpsertWithoutActivity_logInput
    disconnect?: ProgramsWhereInput | boolean
    delete?: ProgramsWhereInput | boolean
    connect?: ProgramsWhereUniqueInput
    update?: XOR<XOR<ProgramsUpdateToOneWithWhereWithoutActivity_logInput, ProgramsUpdateWithoutActivity_logInput>, ProgramsUncheckedUpdateWithoutActivity_logInput>
  }

  export type OrdersUpdateOneWithoutActivity_logNestedInput = {
    create?: XOR<OrdersCreateWithoutActivity_logInput, OrdersUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: OrdersCreateOrConnectWithoutActivity_logInput
    upsert?: OrdersUpsertWithoutActivity_logInput
    disconnect?: OrdersWhereInput | boolean
    delete?: OrdersWhereInput | boolean
    connect?: OrdersWhereUniqueInput
    update?: XOR<XOR<OrdersUpdateToOneWithWhereWithoutActivity_logInput, OrdersUpdateWithoutActivity_logInput>, OrdersUncheckedUpdateWithoutActivity_logInput>
  }

  export type PayoutsUpdateOneWithoutActivity_logNestedInput = {
    create?: XOR<PayoutsCreateWithoutActivity_logInput, PayoutsUncheckedCreateWithoutActivity_logInput>
    connectOrCreate?: PayoutsCreateOrConnectWithoutActivity_logInput
    upsert?: PayoutsUpsertWithoutActivity_logInput
    disconnect?: PayoutsWhereInput | boolean
    delete?: PayoutsWhereInput | boolean
    connect?: PayoutsWhereUniqueInput
    update?: XOR<XOR<PayoutsUpdateToOneWithWhereWithoutActivity_logInput, PayoutsUpdateWithoutActivity_logInput>, PayoutsUncheckedUpdateWithoutActivity_logInput>
  }

  export type StoresCreateNestedOneWithoutMessageHistoryInput = {
    create?: XOR<StoresCreateWithoutMessageHistoryInput, StoresUncheckedCreateWithoutMessageHistoryInput>
    connectOrCreate?: StoresCreateOrConnectWithoutMessageHistoryInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumMessageHistoryStatusTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageHistoryStatusType
  }

  export type StoresUpdateOneRequiredWithoutMessageHistoryNestedInput = {
    create?: XOR<StoresCreateWithoutMessageHistoryInput, StoresUncheckedCreateWithoutMessageHistoryInput>
    connectOrCreate?: StoresCreateOrConnectWithoutMessageHistoryInput
    upsert?: StoresUpsertWithoutMessageHistoryInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutMessageHistoryInput, StoresUpdateWithoutMessageHistoryInput>, StoresUncheckedUpdateWithoutMessageHistoryInput>
  }

  export type StoresCreateNestedOneWithoutPaymentGatewayInput = {
    create?: XOR<StoresCreateWithoutPaymentGatewayInput, StoresUncheckedCreateWithoutPaymentGatewayInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPaymentGatewayInput
    connect?: StoresWhereUniqueInput
  }

  export type StoresUpdateOneRequiredWithoutPaymentGatewayNestedInput = {
    create?: XOR<StoresCreateWithoutPaymentGatewayInput, StoresUncheckedCreateWithoutPaymentGatewayInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPaymentGatewayInput
    upsert?: StoresUpsertWithoutPaymentGatewayInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutPaymentGatewayInput, StoresUpdateWithoutPaymentGatewayInput>, StoresUncheckedUpdateWithoutPaymentGatewayInput>
  }

  export type StoresCreateNestedOneWithoutAppSubscriptionInput = {
    create?: XOR<StoresCreateWithoutAppSubscriptionInput, StoresUncheckedCreateWithoutAppSubscriptionInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAppSubscriptionInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumAppSubscriptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.AppSubscriptionType
  }

  export type StoresUpdateOneRequiredWithoutAppSubscriptionNestedInput = {
    create?: XOR<StoresCreateWithoutAppSubscriptionInput, StoresUncheckedCreateWithoutAppSubscriptionInput>
    connectOrCreate?: StoresCreateOrConnectWithoutAppSubscriptionInput
    upsert?: StoresUpsertWithoutAppSubscriptionInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutAppSubscriptionInput, StoresUpdateWithoutAppSubscriptionInput>, StoresUncheckedUpdateWithoutAppSubscriptionInput>
  }

  export type StoresCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<StoresCreateWithoutIntegrationsInput, StoresUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutIntegrationsInput
    connect?: StoresWhereUniqueInput
  }

  export type EnumIntegrationTypeFieldUpdateOperationsInput = {
    set?: $Enums.IntegrationType
  }

  export type StoresUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<StoresCreateWithoutIntegrationsInput, StoresUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: StoresCreateOrConnectWithoutIntegrationsInput
    upsert?: StoresUpsertWithoutIntegrationsInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutIntegrationsInput, StoresUpdateWithoutIntegrationsInput>, StoresUncheckedUpdateWithoutIntegrationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumStoreStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreStatusType | EnumStoreStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreStatusType[] | ListEnumStoreStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreStatusType[] | ListEnumStoreStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreStatusTypeFilter<$PrismaModel> | $Enums.StoreStatusType
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStoreStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StoreStatusType | EnumStoreStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StoreStatusType[] | ListEnumStoreStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StoreStatusType[] | ListEnumStoreStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStoreStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.StoreStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStoreStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumStoreStatusTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumProgramStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramStatusType | EnumProgramStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProgramStatusType[] | ListEnumProgramStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgramStatusType[] | ListEnumProgramStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProgramStatusTypeFilter<$PrismaModel> | $Enums.ProgramStatusType
  }

  export type NestedEnumProgramStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramStatusType | EnumProgramStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProgramStatusType[] | ListEnumProgramStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgramStatusType[] | ListEnumProgramStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProgramStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProgramStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProgramStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumProgramStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumTierTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TierType | EnumTierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TierType[] | ListEnumTierTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TierType[] | ListEnumTierTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTierTypeFilter<$PrismaModel> | $Enums.TierType
  }

  export type NestedEnumEarningTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EarningType | EnumEarningTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EarningType[] | ListEnumEarningTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EarningType[] | ListEnumEarningTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEarningTypeFilter<$PrismaModel> | $Enums.EarningType
  }

  export type NestedEnumTierTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TierType | EnumTierTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TierType[] | ListEnumTierTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TierType[] | ListEnumTierTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTierTypeWithAggregatesFilter<$PrismaModel> | $Enums.TierType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTierTypeFilter<$PrismaModel>
    _max?: NestedEnumTierTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumEarningTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EarningType | EnumEarningTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EarningType[] | ListEnumEarningTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EarningType[] | ListEnumEarningTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEarningTypeWithAggregatesFilter<$PrismaModel> | $Enums.EarningType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEarningTypeFilter<$PrismaModel>
    _max?: NestedEnumEarningTypeFilter<$PrismaModel>
  }

  export type NestedEnumCustomerDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerDiscountType | EnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerDiscountType[] | ListEnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerDiscountType[] | ListEnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerDiscountTypeFilter<$PrismaModel> | $Enums.CustomerDiscountType
  }

  export type NestedEnumCustomerDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerDiscountType | EnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerDiscountType[] | ListEnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerDiscountType[] | ListEnumCustomerDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.CustomerDiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumCustomerDiscountTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderAttributeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAttributeType | EnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAttributeType[] | ListEnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAttributeType[] | ListEnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAttributeTypeFilter<$PrismaModel> | $Enums.OrderAttributeType
  }

  export type NestedEnumOrderStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusTypeFilter<$PrismaModel> | $Enums.OrderStatusType
  }

  export type NestedEnumOrderAttributeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderAttributeType | EnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderAttributeType[] | ListEnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderAttributeType[] | ListEnumOrderAttributeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderAttributeTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderAttributeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderAttributeTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderAttributeTypeFilter<$PrismaModel>
  }

  export type NestedEnumOrderStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderStatusType | EnumOrderStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderStatusType[] | ListEnumOrderStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.OrderStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumOrderStatusTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeFilter<$PrismaModel> | $Enums.StatusType
  }

  export type NestedEnumApprovalModeTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalModeType | EnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumApprovalModeTypeNullableFilter<$PrismaModel> | $Enums.ApprovalModeType | null
  }

  export type NestedEnumStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StatusType | EnumStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.StatusType[] | ListEnumStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.StatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumApprovalModeTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalModeType | EnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumApprovalModeTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalModeType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumApprovalModeTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumApprovalModeTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumBonusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BonusType | EnumBonusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BonusType[] | ListEnumBonusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BonusType[] | ListEnumBonusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBonusTypeFilter<$PrismaModel> | $Enums.BonusType
  }

  export type NestedEnumBonusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BonusType | EnumBonusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BonusType[] | ListEnumBonusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BonusType[] | ListEnumBonusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBonusTypeWithAggregatesFilter<$PrismaModel> | $Enums.BonusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBonusTypeFilter<$PrismaModel>
    _max?: NestedEnumBonusTypeFilter<$PrismaModel>
  }

  export type NestedEnumGiftTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.GiftType | EnumGiftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GiftType[] | ListEnumGiftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GiftType[] | ListEnumGiftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGiftTypeFilter<$PrismaModel> | $Enums.GiftType
  }

  export type NestedEnumShippingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingType | EnumShippingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingType[] | ListEnumShippingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingType[] | ListEnumShippingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingTypeFilter<$PrismaModel> | $Enums.ShippingType
  }

  export type NestedEnumGiftTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GiftType | EnumGiftTypeFieldRefInput<$PrismaModel>
    in?: $Enums.GiftType[] | ListEnumGiftTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.GiftType[] | ListEnumGiftTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumGiftTypeWithAggregatesFilter<$PrismaModel> | $Enums.GiftType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGiftTypeFilter<$PrismaModel>
    _max?: NestedEnumGiftTypeFilter<$PrismaModel>
  }

  export type NestedEnumShippingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ShippingType | EnumShippingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ShippingType[] | ListEnumShippingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ShippingType[] | ListEnumShippingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumShippingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ShippingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumShippingTypeFilter<$PrismaModel>
    _max?: NestedEnumShippingTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionReferenceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReferenceType | EnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReferenceType[] | ListEnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionReferenceType[] | ListEnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionReferenceTypeFilter<$PrismaModel> | $Enums.TransactionReferenceType
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionReferenceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReferenceType | EnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReferenceType[] | ListEnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionReferenceType[] | ListEnumTransactionReferenceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionReferenceTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionReferenceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionReferenceTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionReferenceTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumApprovalModeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalModeType | EnumApprovalModeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalModeTypeFilter<$PrismaModel> | $Enums.ApprovalModeType
  }

  export type NestedEnumCommissionCalculationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionCalculationType | EnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionCalculationType[] | ListEnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionCalculationType[] | ListEnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionCalculationTypeFilter<$PrismaModel> | $Enums.CommissionCalculationType
  }

  export type NestedEnumApprovalModeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalModeType | EnumApprovalModeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalModeType[] | ListEnumApprovalModeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalModeTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalModeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalModeTypeFilter<$PrismaModel>
    _max?: NestedEnumApprovalModeTypeFilter<$PrismaModel>
  }

  export type NestedEnumCommissionCalculationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CommissionCalculationType | EnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CommissionCalculationType[] | ListEnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CommissionCalculationType[] | ListEnumCommissionCalculationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCommissionCalculationTypeWithAggregatesFilter<$PrismaModel> | $Enums.CommissionCalculationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCommissionCalculationTypeFilter<$PrismaModel>
    _max?: NestedEnumCommissionCalculationTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobsStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsStatusType | EnumJobsStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobsStatusType[] | ListEnumJobsStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobsStatusType[] | ListEnumJobsStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobsStatusTypeFilter<$PrismaModel> | $Enums.JobsStatusType
  }

  export type NestedEnumJobTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeFilter<$PrismaModel> | $Enums.JobType
  }

  export type NestedEnumJobsStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobsStatusType | EnumJobsStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobsStatusType[] | ListEnumJobsStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobsStatusType[] | ListEnumJobsStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobsStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobsStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobsStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumJobsStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumJobTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.JobType | EnumJobTypeFieldRefInput<$PrismaModel>
    in?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.JobType[] | ListEnumJobTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumJobTypeWithAggregatesFilter<$PrismaModel> | $Enums.JobType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumJobTypeFilter<$PrismaModel>
    _max?: NestedEnumJobTypeFilter<$PrismaModel>
  }

  export type NestedEnumContactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeFilter<$PrismaModel> | $Enums.ContactType
  }

  export type NestedEnumContactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContactType | EnumContactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContactType[] | ListEnumContactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContactTypeFilter<$PrismaModel>
    _max?: NestedEnumContactTypeFilter<$PrismaModel>
  }

  export type NestedEnumAffiliateStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateStatusType | EnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateStatusType[] | ListEnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateStatusType[] | ListEnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateStatusTypeFilter<$PrismaModel> | $Enums.AffiliateStatusType
  }

  export type NestedEnumAffiliateSourceTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateSourceType | EnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AffiliateSourceType[] | ListEnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AffiliateSourceType[] | ListEnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAffiliateSourceTypeNullableFilter<$PrismaModel> | $Enums.AffiliateSourceType | null
  }

  export type NestedEnumAffiliateStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateStatusType | EnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AffiliateStatusType[] | ListEnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AffiliateStatusType[] | ListEnumAffiliateStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAffiliateStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAffiliateStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumAffiliateStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumAffiliateSourceTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AffiliateSourceType | EnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.AffiliateSourceType[] | ListEnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.AffiliateSourceType[] | ListEnumAffiliateSourceTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumAffiliateSourceTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.AffiliateSourceType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumAffiliateSourceTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumAffiliateSourceTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumProgramHistoryStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramHistoryStatusType | EnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProgramHistoryStatusType[] | ListEnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgramHistoryStatusType[] | ListEnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProgramHistoryStatusTypeFilter<$PrismaModel> | $Enums.ProgramHistoryStatusType
  }

  export type NestedEnumProgramHistoryStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProgramHistoryStatusType | EnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProgramHistoryStatusType[] | ListEnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProgramHistoryStatusType[] | ListEnumProgramHistoryStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProgramHistoryStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProgramHistoryStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProgramHistoryStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumProgramHistoryStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumDiscountStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountStatusType | EnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountStatusType[] | ListEnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountStatusType[] | ListEnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountStatusTypeFilter<$PrismaModel> | $Enums.DiscountStatusType
  }

  export type NestedEnumDiscountStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountStatusType | EnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountStatusType[] | ListEnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountStatusType[] | ListEnumDiscountStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationReceiverTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationReceiverType | EnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationReceiverType[] | ListEnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationReceiverType[] | ListEnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationReceiverTypeFilter<$PrismaModel> | $Enums.NotificationReceiverType
  }

  export type NestedEnumNotificationStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatusType | EnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatusType[] | ListEnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatusType[] | ListEnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusTypeFilter<$PrismaModel> | $Enums.NotificationStatusType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationReceiverTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationReceiverType | EnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationReceiverType[] | ListEnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationReceiverType[] | ListEnumNotificationReceiverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationReceiverTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationReceiverType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationReceiverTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationReceiverTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatusType | EnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatusType[] | ListEnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatusType[] | ListEnumNotificationStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumActivityEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityEntityType | EnumActivityEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityEntityTypeFilter<$PrismaModel> | $Enums.ActivityEntityType
  }

  export type NestedEnumActivityEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityEntityType | EnumActivityEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityEntityType[] | ListEnumActivityEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActivityEntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumActivityEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumMessageHistoryStatusTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageHistoryStatusType | EnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageHistoryStatusType[] | ListEnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageHistoryStatusType[] | ListEnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageHistoryStatusTypeFilter<$PrismaModel> | $Enums.MessageHistoryStatusType
  }

  export type NestedEnumMessageHistoryStatusTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageHistoryStatusType | EnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageHistoryStatusType[] | ListEnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MessageHistoryStatusType[] | ListEnumMessageHistoryStatusTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMessageHistoryStatusTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageHistoryStatusType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageHistoryStatusTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageHistoryStatusTypeFilter<$PrismaModel>
  }

  export type NestedEnumAppSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppSubscriptionType | EnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppSubscriptionType[] | ListEnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppSubscriptionType[] | ListEnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppSubscriptionTypeFilter<$PrismaModel> | $Enums.AppSubscriptionType
  }

  export type NestedEnumAppSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppSubscriptionType | EnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppSubscriptionType[] | ListEnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppSubscriptionType[] | ListEnumAppSubscriptionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppSubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumAppSubscriptionTypeFilter<$PrismaModel>
  }

  export type NestedEnumIntegrationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeFilter<$PrismaModel> | $Enums.IntegrationType
  }

  export type NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IntegrationType | EnumIntegrationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.IntegrationType[] | ListEnumIntegrationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumIntegrationTypeWithAggregatesFilter<$PrismaModel> | $Enums.IntegrationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIntegrationTypeFilter<$PrismaModel>
    _max?: NestedEnumIntegrationTypeFilter<$PrismaModel>
  }

  export type ActivityLogCreateWithoutStoresInput = {
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
    affiliates?: AffiliatesCreateNestedOneWithoutActivity_logInput
    programs?: ProgramsCreateNestedOneWithoutActivity_logInput
    orders?: OrdersCreateNestedOneWithoutActivity_logInput
    payouts?: PayoutsCreateNestedOneWithoutActivity_logInput
  }

  export type ActivityLogUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id?: number | null
    program_id?: number | null
    order_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type ActivityLogCreateOrConnectWithoutStoresInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutStoresInput, ActivityLogUncheckedCreateWithoutStoresInput>
  }

  export type ActivityLogCreateManyStoresInputEnvelope = {
    data: ActivityLogCreateManyStoresInput | ActivityLogCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateBonusCreateWithoutStoresInput = {
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_bonusInput
    bonus: BonusCreateNestedOneWithoutAffiliate_bonusInput
  }

  export type AffiliateBonusUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateBonusCreateOrConnectWithoutStoresInput = {
    where: AffiliateBonusWhereUniqueInput
    create: XOR<AffiliateBonusCreateWithoutStoresInput, AffiliateBonusUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateBonusCreateManyStoresInputEnvelope = {
    data: AffiliateBonusCreateManyStoresInput | AffiliateBonusCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateDiscountsCreateWithoutStoresInput = {
    discount_id: bigint | number
    discount_code: string
    is_deleted?: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_discountsInput
  }

  export type AffiliateDiscountsUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    discount_id: bigint | number
    discount_code: string
    is_deleted?: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateDiscountsCreateOrConnectWithoutStoresInput = {
    where: AffiliateDiscountsWhereUniqueInput
    create: XOR<AffiliateDiscountsCreateWithoutStoresInput, AffiliateDiscountsUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateDiscountsCreateManyStoresInputEnvelope = {
    data: AffiliateDiscountsCreateManyStoresInput | AffiliateDiscountsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateGiftsCreateWithoutStoresInput = {
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_giftsInput
    gifts: GiftsCreateNestedOneWithoutAffiliate_giftsInput
  }

  export type AffiliateGiftsUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    gift_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateGiftsCreateOrConnectWithoutStoresInput = {
    where: AffiliateGiftsWhereUniqueInput
    create: XOR<AffiliateGiftsCreateWithoutStoresInput, AffiliateGiftsUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateGiftsCreateManyStoresInputEnvelope = {
    data: AffiliateGiftsCreateManyStoresInput | AffiliateGiftsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateProgramHistoryCreateWithoutStoresInput = {
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_program_historyInput
  }

  export type AffiliateProgramHistoryUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramHistoryCreateOrConnectWithoutStoresInput = {
    where: AffiliateProgramHistoryWhereUniqueInput
    create: XOR<AffiliateProgramHistoryCreateWithoutStoresInput, AffiliateProgramHistoryUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateProgramHistoryCreateManyStoresInputEnvelope = {
    data: AffiliateProgramHistoryCreateManyStoresInput | AffiliateProgramHistoryCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateProgramsCreateWithoutStoresInput = {
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_programsInput
    programs: ProgramsCreateNestedOneWithoutAffiliate_programsInput
  }

  export type AffiliateProgramsUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    program_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramsCreateOrConnectWithoutStoresInput = {
    where: AffiliateProgramsWhereUniqueInput
    create: XOR<AffiliateProgramsCreateWithoutStoresInput, AffiliateProgramsUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateProgramsCreateManyStoresInputEnvelope = {
    data: AffiliateProgramsCreateManyStoresInput | AffiliateProgramsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type AffiliatesCreateWithoutStoresInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutStoresInput = {
    id?: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutStoresInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutStoresInput, AffiliatesUncheckedCreateWithoutStoresInput>
  }

  export type AffiliatesCreateManyStoresInputEnvelope = {
    data: AffiliatesCreateManyStoresInput | AffiliatesCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type AppSubscriptionCreateWithoutStoresInput = {
    plan_id?: string | null
    name: string
    price: number
    status: $Enums.AppSubscriptionType
    currency_code: string
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AppSubscriptionUncheckedCreateWithoutStoresInput = {
    id?: number
    plan_id?: string | null
    name: string
    price: number
    status: $Enums.AppSubscriptionType
    currency_code: string
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AppSubscriptionCreateOrConnectWithoutStoresInput = {
    where: AppSubscriptionWhereUniqueInput
    create: XOR<AppSubscriptionCreateWithoutStoresInput, AppSubscriptionUncheckedCreateWithoutStoresInput>
  }

  export type BonusCreateWithoutStoresInput = {
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutBonusInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutBonusInput
  }

  export type BonusUncheckedCreateWithoutStoresInput = {
    id?: number
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutBonusInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutBonusInput
  }

  export type BonusCreateOrConnectWithoutStoresInput = {
    where: BonusWhereUniqueInput
    create: XOR<BonusCreateWithoutStoresInput, BonusUncheckedCreateWithoutStoresInput>
  }

  export type BonusCreateManyStoresInputEnvelope = {
    data: BonusCreateManyStoresInput | BonusCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type CommissionsCreateWithoutStoresInput = {
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutCommissionsInput
    orders: OrdersCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionsUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    order_id: number
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CommissionsCreateOrConnectWithoutStoresInput = {
    where: CommissionsWhereUniqueInput
    create: XOR<CommissionsCreateWithoutStoresInput, CommissionsUncheckedCreateWithoutStoresInput>
  }

  export type CommissionsCreateManyStoresInputEnvelope = {
    data: CommissionsCreateManyStoresInput | CommissionsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type CustomerDiscountsCreateWithoutStoresInput = {
    discount_rate: number
    discount_options: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    discount_type: $Enums.CustomerDiscountType
    programs: ProgramsCreateNestedOneWithoutCustomer_discountsInput
  }

  export type CustomerDiscountsUncheckedCreateWithoutStoresInput = {
    id?: number
    program_id: number
    discount_rate: number
    discount_options: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    discount_type: $Enums.CustomerDiscountType
  }

  export type CustomerDiscountsCreateOrConnectWithoutStoresInput = {
    where: CustomerDiscountsWhereUniqueInput
    create: XOR<CustomerDiscountsCreateWithoutStoresInput, CustomerDiscountsUncheckedCreateWithoutStoresInput>
  }

  export type CustomerDiscountsCreateManyStoresInputEnvelope = {
    data: CustomerDiscountsCreateManyStoresInput | CustomerDiscountsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type CustomersCreateWithoutStoresInput = {
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutCustomersInput
    order_items?: OrderItemsCreateNestedManyWithoutCustomersInput
    orders?: OrdersCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutCustomersInput
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutStoresInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutStoresInput, CustomersUncheckedCreateWithoutStoresInput>
  }

  export type CustomersCreateManyStoresInputEnvelope = {
    data: CustomersCreateManyStoresInput | CustomersCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type GiftsCreateWithoutStoresInput = {
    title: string
    description: string
    products: JsonNullValueInput | InputJsonValue
    gift_type: $Enums.GiftType
    status: $Enums.StatusType
    shipping_method: $Enums.ShippingType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutGiftsInput
  }

  export type GiftsUncheckedCreateWithoutStoresInput = {
    id?: number
    title: string
    description: string
    products: JsonNullValueInput | InputJsonValue
    gift_type: $Enums.GiftType
    status: $Enums.StatusType
    shipping_method: $Enums.ShippingType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutGiftsInput
  }

  export type GiftsCreateOrConnectWithoutStoresInput = {
    where: GiftsWhereUniqueInput
    create: XOR<GiftsCreateWithoutStoresInput, GiftsUncheckedCreateWithoutStoresInput>
  }

  export type GiftsCreateManyStoresInputEnvelope = {
    data: GiftsCreateManyStoresInput | GiftsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationsCreateWithoutStoresInput = {
    integration_type: $Enums.IntegrationType
    status: $Enums.NotificationStatusType
    api_key: string
    api_secret?: string | null
    created_at: bigint | number
    updated_at: bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationsUncheckedCreateWithoutStoresInput = {
    id?: number
    integration_type: $Enums.IntegrationType
    status: $Enums.NotificationStatusType
    api_key: string
    api_secret?: string | null
    created_at: bigint | number
    updated_at: bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationsCreateOrConnectWithoutStoresInput = {
    where: IntegrationsWhereUniqueInput
    create: XOR<IntegrationsCreateWithoutStoresInput, IntegrationsUncheckedCreateWithoutStoresInput>
  }

  export type IntegrationsCreateManyStoresInputEnvelope = {
    data: IntegrationsCreateManyStoresInput | IntegrationsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type JobsCreateWithoutStoresInput = {
    job_metadata: JsonNullValueInput | InputJsonValue
    status: $Enums.JobsStatusType
    type: $Enums.JobType
    job_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    payouts?: PayoutsCreateNestedOneWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutStoresInput = {
    id?: number
    job_metadata: JsonNullValueInput | InputJsonValue
    status: $Enums.JobsStatusType
    type: $Enums.JobType
    job_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    payouts?: PayoutsUncheckedCreateNestedOneWithoutJobsInput
  }

  export type JobsCreateOrConnectWithoutStoresInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutStoresInput, JobsUncheckedCreateWithoutStoresInput>
  }

  export type JobsCreateManyStoresInputEnvelope = {
    data: JobsCreateManyStoresInput | JobsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type MessageHistoryCreateWithoutStoresInput = {
    status: $Enums.MessageHistoryStatusType
    referenceId: string
    metaData: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
  }

  export type MessageHistoryUncheckedCreateWithoutStoresInput = {
    id?: number
    status: $Enums.MessageHistoryStatusType
    referenceId: string
    metaData: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
  }

  export type MessageHistoryCreateOrConnectWithoutStoresInput = {
    where: MessageHistoryWhereUniqueInput
    create: XOR<MessageHistoryCreateWithoutStoresInput, MessageHistoryUncheckedCreateWithoutStoresInput>
  }

  export type MessageHistoryCreateManyStoresInputEnvelope = {
    data: MessageHistoryCreateManyStoresInput | MessageHistoryCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type NotificationsCreateWithoutStoresInput = {
    notification_id?: string
    type: $Enums.NotificationType
    receiver_type: $Enums.NotificationReceiverType
    subject: string
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
    languages?: string
  }

  export type NotificationsUncheckedCreateWithoutStoresInput = {
    id?: number
    notification_id?: string
    type: $Enums.NotificationType
    receiver_type: $Enums.NotificationReceiverType
    subject: string
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
    languages?: string
  }

  export type NotificationsCreateOrConnectWithoutStoresInput = {
    where: NotificationsWhereUniqueInput
    create: XOR<NotificationsCreateWithoutStoresInput, NotificationsUncheckedCreateWithoutStoresInput>
  }

  export type NotificationsCreateManyStoresInputEnvelope = {
    data: NotificationsCreateManyStoresInput | NotificationsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemsCreateWithoutStoresInput = {
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutOrder_itemsInput
    customers: CustomersCreateNestedOneWithoutOrder_itemsInput
    orders: OrdersCreateNestedOneWithoutOrder_itemsInput
  }

  export type OrderItemsUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    customer_id: number
    order_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrderItemsCreateOrConnectWithoutStoresInput = {
    where: OrderItemsWhereUniqueInput
    create: XOR<OrderItemsCreateWithoutStoresInput, OrderItemsUncheckedCreateWithoutStoresInput>
  }

  export type OrderItemsCreateManyStoresInputEnvelope = {
    data: OrderItemsCreateManyStoresInput | OrderItemsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutStoresInput = {
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    commissions?: CommissionsCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsCreateNestedManyWithoutOrdersInput
    affiliates: AffiliatesCreateNestedOneWithoutOrdersInput
    customers: CustomersCreateNestedOneWithoutOrdersInput
    programs?: ProgramsCreateNestedOneWithoutOrdersInput
    activity_log?: ActivityLogCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
    commissions?: CommissionsUncheckedCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutOrdersInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutStoresInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutStoresInput, OrdersUncheckedCreateWithoutStoresInput>
  }

  export type OrdersCreateManyStoresInputEnvelope = {
    data: OrdersCreateManyStoresInput | OrdersCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type PaymentGatewayCreateWithoutStoresInput = {
    payment_uuid?: string
    provider: $Enums.PaymentType
    credentials: JsonNullValueInput | InputJsonValue
    webhook_id?: string | null
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type PaymentGatewayUncheckedCreateWithoutStoresInput = {
    id?: number
    payment_uuid?: string
    provider: $Enums.PaymentType
    credentials: JsonNullValueInput | InputJsonValue
    webhook_id?: string | null
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type PaymentGatewayCreateOrConnectWithoutStoresInput = {
    where: PaymentGatewayWhereUniqueInput
    create: XOR<PaymentGatewayCreateWithoutStoresInput, PaymentGatewayUncheckedCreateWithoutStoresInput>
  }

  export type PaymentGatewayCreateManyStoresInputEnvelope = {
    data: PaymentGatewayCreateManyStoresInput | PaymentGatewayCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type PayoutsCreateWithoutStoresInput = {
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    affiliates: AffiliatesCreateNestedOneWithoutPayoutsInput
    jobs: JobsCreateNestedOneWithoutPayoutsInput
    activity_log?: ActivityLogCreateNestedManyWithoutPayoutsInput
  }

  export type PayoutsUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    job_id: number
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutPayoutsInput
  }

  export type PayoutsCreateOrConnectWithoutStoresInput = {
    where: PayoutsWhereUniqueInput
    create: XOR<PayoutsCreateWithoutStoresInput, PayoutsUncheckedCreateWithoutStoresInput>
  }

  export type PayoutsCreateManyStoresInputEnvelope = {
    data: PayoutsCreateManyStoresInput | PayoutsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type ProgramBonusCreateWithoutStoresInput = {
    created_at: bigint | number
    updated_at: bigint | number
    bonus: BonusCreateNestedOneWithoutProgram_bonusInput
    programs: ProgramsCreateNestedOneWithoutProgram_bonusInput
  }

  export type ProgramBonusUncheckedCreateWithoutStoresInput = {
    id?: number
    program_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ProgramBonusCreateOrConnectWithoutStoresInput = {
    where: ProgramBonusWhereUniqueInput
    create: XOR<ProgramBonusCreateWithoutStoresInput, ProgramBonusUncheckedCreateWithoutStoresInput>
  }

  export type ProgramBonusCreateManyStoresInputEnvelope = {
    data: ProgramBonusCreateManyStoresInput | ProgramBonusCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type ProgramsCreateWithoutStoresInput = {
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsCreateNestedOneWithoutProgramsInput
    Orders?: OrdersCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutProgramsInput
    tiers?: TiersCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsUncheckedCreateWithoutStoresInput = {
    id?: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedOneWithoutProgramsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutProgramsInput
    tiers?: TiersUncheckedCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsCreateOrConnectWithoutStoresInput = {
    where: ProgramsWhereUniqueInput
    create: XOR<ProgramsCreateWithoutStoresInput, ProgramsUncheckedCreateWithoutStoresInput>
  }

  export type ProgramsCreateManyStoresInputEnvelope = {
    data: ProgramsCreateManyStoresInput | ProgramsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type SettingsCreateWithoutStoresInput = {
    commission_delay?: number
    commission_approval_mode: $Enums.ApprovalModeType
    commission_calculation: $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: number | null
    primary_color?: string
    secondary_color?: string
    created_at: bigint | number
    updated_at: bigint | number
    current_email_lang?: string
    email_limit?: number
    notify_once?: boolean
  }

  export type SettingsUncheckedCreateWithoutStoresInput = {
    id?: number
    commission_delay?: number
    commission_approval_mode: $Enums.ApprovalModeType
    commission_calculation: $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: number | null
    primary_color?: string
    secondary_color?: string
    created_at: bigint | number
    updated_at: bigint | number
    current_email_lang?: string
    email_limit?: number
    notify_once?: boolean
  }

  export type SettingsCreateOrConnectWithoutStoresInput = {
    where: SettingsWhereUniqueInput
    create: XOR<SettingsCreateWithoutStoresInput, SettingsUncheckedCreateWithoutStoresInput>
  }

  export type TiersCreateWithoutStoresInput = {
    tier_type: $Enums.TierType
    min_value: number
    max_value?: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint | number
    updated_at: bigint | number
    programs: ProgramsCreateNestedOneWithoutTiersInput
  }

  export type TiersUncheckedCreateWithoutStoresInput = {
    id?: number
    program_id: number
    tier_type: $Enums.TierType
    min_value: number
    max_value?: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TiersCreateOrConnectWithoutStoresInput = {
    where: TiersWhereUniqueInput
    create: XOR<TiersCreateWithoutStoresInput, TiersUncheckedCreateWithoutStoresInput>
  }

  export type TiersCreateManyStoresInputEnvelope = {
    data: TiersCreateManyStoresInput | TiersCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type TransactionsCreateWithoutStoresInput = {
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted?: boolean
    amount: number
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutStoresInput = {
    id?: number
    affiliate_id: number
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted?: boolean
    amount: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TransactionsCreateOrConnectWithoutStoresInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutStoresInput, TransactionsUncheckedCreateWithoutStoresInput>
  }

  export type TransactionsCreateManyStoresInputEnvelope = {
    data: TransactionsCreateManyStoresInput | TransactionsCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutStoresInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutStoresInput, ActivityLogUncheckedUpdateWithoutStoresInput>
    create: XOR<ActivityLogCreateWithoutStoresInput, ActivityLogUncheckedCreateWithoutStoresInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutStoresInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutStoresInput, ActivityLogUncheckedUpdateWithoutStoresInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutStoresInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutStoresInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    store_id?: IntFilter<"ActivityLog"> | number
    affiliate_id?: IntNullableFilter<"ActivityLog"> | number | null
    program_id?: IntNullableFilter<"ActivityLog"> | number | null
    order_id?: IntNullableFilter<"ActivityLog"> | number | null
    payout_id?: IntNullableFilter<"ActivityLog"> | number | null
    entity_type?: EnumActivityEntityTypeFilter<"ActivityLog"> | $Enums.ActivityEntityType
    message?: StringFilter<"ActivityLog"> | string
    created_at?: BigIntFilter<"ActivityLog"> | bigint | number
  }

  export type AffiliateBonusUpsertWithWhereUniqueWithoutStoresInput = {
    where: AffiliateBonusWhereUniqueInput
    update: XOR<AffiliateBonusUpdateWithoutStoresInput, AffiliateBonusUncheckedUpdateWithoutStoresInput>
    create: XOR<AffiliateBonusCreateWithoutStoresInput, AffiliateBonusUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateBonusUpdateWithWhereUniqueWithoutStoresInput = {
    where: AffiliateBonusWhereUniqueInput
    data: XOR<AffiliateBonusUpdateWithoutStoresInput, AffiliateBonusUncheckedUpdateWithoutStoresInput>
  }

  export type AffiliateBonusUpdateManyWithWhereWithoutStoresInput = {
    where: AffiliateBonusScalarWhereInput
    data: XOR<AffiliateBonusUpdateManyMutationInput, AffiliateBonusUncheckedUpdateManyWithoutStoresInput>
  }

  export type AffiliateBonusScalarWhereInput = {
    AND?: AffiliateBonusScalarWhereInput | AffiliateBonusScalarWhereInput[]
    OR?: AffiliateBonusScalarWhereInput[]
    NOT?: AffiliateBonusScalarWhereInput | AffiliateBonusScalarWhereInput[]
    id?: IntFilter<"AffiliateBonus"> | number
    store_id?: IntFilter<"AffiliateBonus"> | number
    affiliate_id?: IntFilter<"AffiliateBonus"> | number
    bonus_id?: IntFilter<"AffiliateBonus"> | number
    created_at?: BigIntFilter<"AffiliateBonus"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateBonus"> | bigint | number
  }

  export type AffiliateDiscountsUpsertWithWhereUniqueWithoutStoresInput = {
    where: AffiliateDiscountsWhereUniqueInput
    update: XOR<AffiliateDiscountsUpdateWithoutStoresInput, AffiliateDiscountsUncheckedUpdateWithoutStoresInput>
    create: XOR<AffiliateDiscountsCreateWithoutStoresInput, AffiliateDiscountsUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateDiscountsUpdateWithWhereUniqueWithoutStoresInput = {
    where: AffiliateDiscountsWhereUniqueInput
    data: XOR<AffiliateDiscountsUpdateWithoutStoresInput, AffiliateDiscountsUncheckedUpdateWithoutStoresInput>
  }

  export type AffiliateDiscountsUpdateManyWithWhereWithoutStoresInput = {
    where: AffiliateDiscountsScalarWhereInput
    data: XOR<AffiliateDiscountsUpdateManyMutationInput, AffiliateDiscountsUncheckedUpdateManyWithoutStoresInput>
  }

  export type AffiliateDiscountsScalarWhereInput = {
    AND?: AffiliateDiscountsScalarWhereInput | AffiliateDiscountsScalarWhereInput[]
    OR?: AffiliateDiscountsScalarWhereInput[]
    NOT?: AffiliateDiscountsScalarWhereInput | AffiliateDiscountsScalarWhereInput[]
    id?: IntFilter<"AffiliateDiscounts"> | number
    store_id?: IntFilter<"AffiliateDiscounts"> | number
    affiliate_id?: IntFilter<"AffiliateDiscounts"> | number
    discount_id?: BigIntFilter<"AffiliateDiscounts"> | bigint | number
    discount_code?: StringFilter<"AffiliateDiscounts"> | string
    is_deleted?: BoolNullableFilter<"AffiliateDiscounts"> | boolean | null
    status?: EnumDiscountStatusTypeFilter<"AffiliateDiscounts"> | $Enums.DiscountStatusType
    created_at?: BigIntFilter<"AffiliateDiscounts"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateDiscounts"> | bigint | number
  }

  export type AffiliateGiftsUpsertWithWhereUniqueWithoutStoresInput = {
    where: AffiliateGiftsWhereUniqueInput
    update: XOR<AffiliateGiftsUpdateWithoutStoresInput, AffiliateGiftsUncheckedUpdateWithoutStoresInput>
    create: XOR<AffiliateGiftsCreateWithoutStoresInput, AffiliateGiftsUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateGiftsUpdateWithWhereUniqueWithoutStoresInput = {
    where: AffiliateGiftsWhereUniqueInput
    data: XOR<AffiliateGiftsUpdateWithoutStoresInput, AffiliateGiftsUncheckedUpdateWithoutStoresInput>
  }

  export type AffiliateGiftsUpdateManyWithWhereWithoutStoresInput = {
    where: AffiliateGiftsScalarWhereInput
    data: XOR<AffiliateGiftsUpdateManyMutationInput, AffiliateGiftsUncheckedUpdateManyWithoutStoresInput>
  }

  export type AffiliateGiftsScalarWhereInput = {
    AND?: AffiliateGiftsScalarWhereInput | AffiliateGiftsScalarWhereInput[]
    OR?: AffiliateGiftsScalarWhereInput[]
    NOT?: AffiliateGiftsScalarWhereInput | AffiliateGiftsScalarWhereInput[]
    id?: IntFilter<"AffiliateGifts"> | number
    store_id?: IntFilter<"AffiliateGifts"> | number
    affiliate_id?: IntFilter<"AffiliateGifts"> | number
    gift_id?: IntFilter<"AffiliateGifts"> | number
    created_at?: BigIntFilter<"AffiliateGifts"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateGifts"> | bigint | number
  }

  export type AffiliateProgramHistoryUpsertWithWhereUniqueWithoutStoresInput = {
    where: AffiliateProgramHistoryWhereUniqueInput
    update: XOR<AffiliateProgramHistoryUpdateWithoutStoresInput, AffiliateProgramHistoryUncheckedUpdateWithoutStoresInput>
    create: XOR<AffiliateProgramHistoryCreateWithoutStoresInput, AffiliateProgramHistoryUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateProgramHistoryUpdateWithWhereUniqueWithoutStoresInput = {
    where: AffiliateProgramHistoryWhereUniqueInput
    data: XOR<AffiliateProgramHistoryUpdateWithoutStoresInput, AffiliateProgramHistoryUncheckedUpdateWithoutStoresInput>
  }

  export type AffiliateProgramHistoryUpdateManyWithWhereWithoutStoresInput = {
    where: AffiliateProgramHistoryScalarWhereInput
    data: XOR<AffiliateProgramHistoryUpdateManyMutationInput, AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresInput>
  }

  export type AffiliateProgramHistoryScalarWhereInput = {
    AND?: AffiliateProgramHistoryScalarWhereInput | AffiliateProgramHistoryScalarWhereInput[]
    OR?: AffiliateProgramHistoryScalarWhereInput[]
    NOT?: AffiliateProgramHistoryScalarWhereInput | AffiliateProgramHistoryScalarWhereInput[]
    id?: IntFilter<"AffiliateProgramHistory"> | number
    store_id?: IntFilter<"AffiliateProgramHistory"> | number
    affiliate_id?: IntFilter<"AffiliateProgramHistory"> | number
    program_id?: IntFilter<"AffiliateProgramHistory"> | number
    program_name?: StringFilter<"AffiliateProgramHistory"> | string
    status?: EnumProgramHistoryStatusTypeFilter<"AffiliateProgramHistory"> | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFilter<"AffiliateProgramHistory"> | bigint | number
    updated_at?: BigIntFilter<"AffiliateProgramHistory"> | bigint | number
  }

  export type AffiliateProgramsUpsertWithWhereUniqueWithoutStoresInput = {
    where: AffiliateProgramsWhereUniqueInput
    update: XOR<AffiliateProgramsUpdateWithoutStoresInput, AffiliateProgramsUncheckedUpdateWithoutStoresInput>
    create: XOR<AffiliateProgramsCreateWithoutStoresInput, AffiliateProgramsUncheckedCreateWithoutStoresInput>
  }

  export type AffiliateProgramsUpdateWithWhereUniqueWithoutStoresInput = {
    where: AffiliateProgramsWhereUniqueInput
    data: XOR<AffiliateProgramsUpdateWithoutStoresInput, AffiliateProgramsUncheckedUpdateWithoutStoresInput>
  }

  export type AffiliateProgramsUpdateManyWithWhereWithoutStoresInput = {
    where: AffiliateProgramsScalarWhereInput
    data: XOR<AffiliateProgramsUpdateManyMutationInput, AffiliateProgramsUncheckedUpdateManyWithoutStoresInput>
  }

  export type AffiliateProgramsScalarWhereInput = {
    AND?: AffiliateProgramsScalarWhereInput | AffiliateProgramsScalarWhereInput[]
    OR?: AffiliateProgramsScalarWhereInput[]
    NOT?: AffiliateProgramsScalarWhereInput | AffiliateProgramsScalarWhereInput[]
    id?: IntFilter<"AffiliatePrograms"> | number
    store_id?: IntFilter<"AffiliatePrograms"> | number
    affiliate_id?: IntFilter<"AffiliatePrograms"> | number
    program_id?: IntFilter<"AffiliatePrograms"> | number
    created_at?: BigIntFilter<"AffiliatePrograms"> | bigint | number
    updated_at?: BigIntFilter<"AffiliatePrograms"> | bigint | number
  }

  export type AffiliatesUpsertWithWhereUniqueWithoutStoresInput = {
    where: AffiliatesWhereUniqueInput
    update: XOR<AffiliatesUpdateWithoutStoresInput, AffiliatesUncheckedUpdateWithoutStoresInput>
    create: XOR<AffiliatesCreateWithoutStoresInput, AffiliatesUncheckedCreateWithoutStoresInput>
  }

  export type AffiliatesUpdateWithWhereUniqueWithoutStoresInput = {
    where: AffiliatesWhereUniqueInput
    data: XOR<AffiliatesUpdateWithoutStoresInput, AffiliatesUncheckedUpdateWithoutStoresInput>
  }

  export type AffiliatesUpdateManyWithWhereWithoutStoresInput = {
    where: AffiliatesScalarWhereInput
    data: XOR<AffiliatesUpdateManyMutationInput, AffiliatesUncheckedUpdateManyWithoutStoresInput>
  }

  export type AffiliatesScalarWhereInput = {
    AND?: AffiliatesScalarWhereInput | AffiliatesScalarWhereInput[]
    OR?: AffiliatesScalarWhereInput[]
    NOT?: AffiliatesScalarWhereInput | AffiliatesScalarWhereInput[]
    id?: IntFilter<"Affiliates"> | number
    store_id?: IntFilter<"Affiliates"> | number
    member_id?: IntFilter<"Affiliates"> | number
    first_name?: StringNullableFilter<"Affiliates"> | string | null
    last_name?: StringNullableFilter<"Affiliates"> | string | null
    phone?: StringNullableFilter<"Affiliates"> | string | null
    referral_code?: StringFilter<"Affiliates"> | string
    status?: EnumAffiliateStatusTypeFilter<"Affiliates"> | $Enums.AffiliateStatusType
    affiliate_details?: JsonNullableFilter<"Affiliates">
    payout_requested?: BoolNullableFilter<"Affiliates"> | boolean | null
    created_at?: BigIntFilter<"Affiliates"> | bigint | number
    updated_at?: BigIntFilter<"Affiliates"> | bigint | number
    source?: EnumAffiliateSourceTypeNullableFilter<"Affiliates"> | $Enums.AffiliateSourceType | null
  }

  export type AppSubscriptionUpsertWithoutStoresInput = {
    update: XOR<AppSubscriptionUpdateWithoutStoresInput, AppSubscriptionUncheckedUpdateWithoutStoresInput>
    create: XOR<AppSubscriptionCreateWithoutStoresInput, AppSubscriptionUncheckedCreateWithoutStoresInput>
    where?: AppSubscriptionWhereInput
  }

  export type AppSubscriptionUpdateToOneWithWhereWithoutStoresInput = {
    where?: AppSubscriptionWhereInput
    data: XOR<AppSubscriptionUpdateWithoutStoresInput, AppSubscriptionUncheckedUpdateWithoutStoresInput>
  }

  export type AppSubscriptionUpdateWithoutStoresInput = {
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumAppSubscriptionTypeFieldUpdateOperationsInput | $Enums.AppSubscriptionType
    currency_code?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AppSubscriptionUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    status?: EnumAppSubscriptionTypeFieldUpdateOperationsInput | $Enums.AppSubscriptionType
    currency_code?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type BonusUpsertWithWhereUniqueWithoutStoresInput = {
    where: BonusWhereUniqueInput
    update: XOR<BonusUpdateWithoutStoresInput, BonusUncheckedUpdateWithoutStoresInput>
    create: XOR<BonusCreateWithoutStoresInput, BonusUncheckedCreateWithoutStoresInput>
  }

  export type BonusUpdateWithWhereUniqueWithoutStoresInput = {
    where: BonusWhereUniqueInput
    data: XOR<BonusUpdateWithoutStoresInput, BonusUncheckedUpdateWithoutStoresInput>
  }

  export type BonusUpdateManyWithWhereWithoutStoresInput = {
    where: BonusScalarWhereInput
    data: XOR<BonusUpdateManyMutationInput, BonusUncheckedUpdateManyWithoutStoresInput>
  }

  export type BonusScalarWhereInput = {
    AND?: BonusScalarWhereInput | BonusScalarWhereInput[]
    OR?: BonusScalarWhereInput[]
    NOT?: BonusScalarWhereInput | BonusScalarWhereInput[]
    id?: IntFilter<"Bonus"> | number
    store_id?: IntFilter<"Bonus"> | number
    title?: StringFilter<"Bonus"> | string
    description?: StringFilter<"Bonus"> | string
    bonus_associate?: EnumBonusTypeFilter<"Bonus"> | $Enums.BonusType
    target_type?: EnumTierTypeFilter<"Bonus"> | $Enums.TierType
    target_goal?: FloatFilter<"Bonus"> | number
    bonus_type?: EnumEarningTypeFilter<"Bonus"> | $Enums.EarningType
    bonus_rate?: FloatFilter<"Bonus"> | number
    status?: EnumStatusTypeFilter<"Bonus"> | $Enums.StatusType
    begin_datetime?: BigIntFilter<"Bonus"> | bigint | number
    expire_datetime?: BigIntFilter<"Bonus"> | bigint | number
    created_at?: BigIntFilter<"Bonus"> | bigint | number
    updated_at?: BigIntFilter<"Bonus"> | bigint | number
  }

  export type CommissionsUpsertWithWhereUniqueWithoutStoresInput = {
    where: CommissionsWhereUniqueInput
    update: XOR<CommissionsUpdateWithoutStoresInput, CommissionsUncheckedUpdateWithoutStoresInput>
    create: XOR<CommissionsCreateWithoutStoresInput, CommissionsUncheckedCreateWithoutStoresInput>
  }

  export type CommissionsUpdateWithWhereUniqueWithoutStoresInput = {
    where: CommissionsWhereUniqueInput
    data: XOR<CommissionsUpdateWithoutStoresInput, CommissionsUncheckedUpdateWithoutStoresInput>
  }

  export type CommissionsUpdateManyWithWhereWithoutStoresInput = {
    where: CommissionsScalarWhereInput
    data: XOR<CommissionsUpdateManyMutationInput, CommissionsUncheckedUpdateManyWithoutStoresInput>
  }

  export type CommissionsScalarWhereInput = {
    AND?: CommissionsScalarWhereInput | CommissionsScalarWhereInput[]
    OR?: CommissionsScalarWhereInput[]
    NOT?: CommissionsScalarWhereInput | CommissionsScalarWhereInput[]
    id?: IntFilter<"Commissions"> | number
    store_id?: IntFilter<"Commissions"> | number
    affiliate_id?: IntFilter<"Commissions"> | number
    order_id?: IntFilter<"Commissions"> | number
    currency_code?: StringFilter<"Commissions"> | string
    amount?: FloatFilter<"Commissions"> | number
    status?: EnumStatusTypeFilter<"Commissions"> | $Enums.StatusType
    approval_mode?: EnumApprovalModeTypeNullableFilter<"Commissions"> | $Enums.ApprovalModeType | null
    review_on?: BigIntNullableFilter<"Commissions"> | bigint | number | null
    created_at?: BigIntFilter<"Commissions"> | bigint | number
    updated_at?: BigIntFilter<"Commissions"> | bigint | number
  }

  export type CustomerDiscountsUpsertWithWhereUniqueWithoutStoresInput = {
    where: CustomerDiscountsWhereUniqueInput
    update: XOR<CustomerDiscountsUpdateWithoutStoresInput, CustomerDiscountsUncheckedUpdateWithoutStoresInput>
    create: XOR<CustomerDiscountsCreateWithoutStoresInput, CustomerDiscountsUncheckedCreateWithoutStoresInput>
  }

  export type CustomerDiscountsUpdateWithWhereUniqueWithoutStoresInput = {
    where: CustomerDiscountsWhereUniqueInput
    data: XOR<CustomerDiscountsUpdateWithoutStoresInput, CustomerDiscountsUncheckedUpdateWithoutStoresInput>
  }

  export type CustomerDiscountsUpdateManyWithWhereWithoutStoresInput = {
    where: CustomerDiscountsScalarWhereInput
    data: XOR<CustomerDiscountsUpdateManyMutationInput, CustomerDiscountsUncheckedUpdateManyWithoutStoresInput>
  }

  export type CustomerDiscountsScalarWhereInput = {
    AND?: CustomerDiscountsScalarWhereInput | CustomerDiscountsScalarWhereInput[]
    OR?: CustomerDiscountsScalarWhereInput[]
    NOT?: CustomerDiscountsScalarWhereInput | CustomerDiscountsScalarWhereInput[]
    id?: IntFilter<"CustomerDiscounts"> | number
    store_id?: IntFilter<"CustomerDiscounts"> | number
    program_id?: IntFilter<"CustomerDiscounts"> | number
    discount_rate?: FloatFilter<"CustomerDiscounts"> | number
    discount_options?: JsonFilter<"CustomerDiscounts">
    created_at?: BigIntFilter<"CustomerDiscounts"> | bigint | number
    updated_at?: BigIntFilter<"CustomerDiscounts"> | bigint | number
    discount_type?: EnumCustomerDiscountTypeFilter<"CustomerDiscounts"> | $Enums.CustomerDiscountType
  }

  export type CustomersUpsertWithWhereUniqueWithoutStoresInput = {
    where: CustomersWhereUniqueInput
    update: XOR<CustomersUpdateWithoutStoresInput, CustomersUncheckedUpdateWithoutStoresInput>
    create: XOR<CustomersCreateWithoutStoresInput, CustomersUncheckedCreateWithoutStoresInput>
  }

  export type CustomersUpdateWithWhereUniqueWithoutStoresInput = {
    where: CustomersWhereUniqueInput
    data: XOR<CustomersUpdateWithoutStoresInput, CustomersUncheckedUpdateWithoutStoresInput>
  }

  export type CustomersUpdateManyWithWhereWithoutStoresInput = {
    where: CustomersScalarWhereInput
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyWithoutStoresInput>
  }

  export type CustomersScalarWhereInput = {
    AND?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    OR?: CustomersScalarWhereInput[]
    NOT?: CustomersScalarWhereInput | CustomersScalarWhereInput[]
    id?: IntFilter<"Customers"> | number
    store_id?: IntFilter<"Customers"> | number
    affiliate_id?: IntFilter<"Customers"> | number
    shopify_customer_id?: BigIntFilter<"Customers"> | bigint | number
    first_name?: StringFilter<"Customers"> | string
    last_name?: StringFilter<"Customers"> | string
    contact_type?: EnumContactTypeFilter<"Customers"> | $Enums.ContactType
    email?: StringNullableFilter<"Customers"> | string | null
    phone?: StringNullableFilter<"Customers"> | string | null
    customer_details?: JsonFilter<"Customers">
    created_at?: BigIntFilter<"Customers"> | bigint | number
    updated_at?: BigIntFilter<"Customers"> | bigint | number
  }

  export type GiftsUpsertWithWhereUniqueWithoutStoresInput = {
    where: GiftsWhereUniqueInput
    update: XOR<GiftsUpdateWithoutStoresInput, GiftsUncheckedUpdateWithoutStoresInput>
    create: XOR<GiftsCreateWithoutStoresInput, GiftsUncheckedCreateWithoutStoresInput>
  }

  export type GiftsUpdateWithWhereUniqueWithoutStoresInput = {
    where: GiftsWhereUniqueInput
    data: XOR<GiftsUpdateWithoutStoresInput, GiftsUncheckedUpdateWithoutStoresInput>
  }

  export type GiftsUpdateManyWithWhereWithoutStoresInput = {
    where: GiftsScalarWhereInput
    data: XOR<GiftsUpdateManyMutationInput, GiftsUncheckedUpdateManyWithoutStoresInput>
  }

  export type GiftsScalarWhereInput = {
    AND?: GiftsScalarWhereInput | GiftsScalarWhereInput[]
    OR?: GiftsScalarWhereInput[]
    NOT?: GiftsScalarWhereInput | GiftsScalarWhereInput[]
    id?: IntFilter<"Gifts"> | number
    store_id?: IntFilter<"Gifts"> | number
    title?: StringFilter<"Gifts"> | string
    description?: StringFilter<"Gifts"> | string
    products?: JsonFilter<"Gifts">
    gift_type?: EnumGiftTypeFilter<"Gifts"> | $Enums.GiftType
    status?: EnumStatusTypeFilter<"Gifts"> | $Enums.StatusType
    shipping_method?: EnumShippingTypeFilter<"Gifts"> | $Enums.ShippingType
    created_at?: BigIntFilter<"Gifts"> | bigint | number
    updated_at?: BigIntFilter<"Gifts"> | bigint | number
  }

  export type IntegrationsUpsertWithWhereUniqueWithoutStoresInput = {
    where: IntegrationsWhereUniqueInput
    update: XOR<IntegrationsUpdateWithoutStoresInput, IntegrationsUncheckedUpdateWithoutStoresInput>
    create: XOR<IntegrationsCreateWithoutStoresInput, IntegrationsUncheckedCreateWithoutStoresInput>
  }

  export type IntegrationsUpdateWithWhereUniqueWithoutStoresInput = {
    where: IntegrationsWhereUniqueInput
    data: XOR<IntegrationsUpdateWithoutStoresInput, IntegrationsUncheckedUpdateWithoutStoresInput>
  }

  export type IntegrationsUpdateManyWithWhereWithoutStoresInput = {
    where: IntegrationsScalarWhereInput
    data: XOR<IntegrationsUpdateManyMutationInput, IntegrationsUncheckedUpdateManyWithoutStoresInput>
  }

  export type IntegrationsScalarWhereInput = {
    AND?: IntegrationsScalarWhereInput | IntegrationsScalarWhereInput[]
    OR?: IntegrationsScalarWhereInput[]
    NOT?: IntegrationsScalarWhereInput | IntegrationsScalarWhereInput[]
    id?: IntFilter<"Integrations"> | number
    store_id?: IntFilter<"Integrations"> | number
    integration_type?: EnumIntegrationTypeFilter<"Integrations"> | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFilter<"Integrations"> | $Enums.NotificationStatusType
    api_key?: StringFilter<"Integrations"> | string
    api_secret?: StringNullableFilter<"Integrations"> | string | null
    created_at?: BigIntFilter<"Integrations"> | bigint | number
    updated_at?: BigIntFilter<"Integrations"> | bigint | number
    integration_details?: JsonNullableFilter<"Integrations">
  }

  export type JobsUpsertWithWhereUniqueWithoutStoresInput = {
    where: JobsWhereUniqueInput
    update: XOR<JobsUpdateWithoutStoresInput, JobsUncheckedUpdateWithoutStoresInput>
    create: XOR<JobsCreateWithoutStoresInput, JobsUncheckedCreateWithoutStoresInput>
  }

  export type JobsUpdateWithWhereUniqueWithoutStoresInput = {
    where: JobsWhereUniqueInput
    data: XOR<JobsUpdateWithoutStoresInput, JobsUncheckedUpdateWithoutStoresInput>
  }

  export type JobsUpdateManyWithWhereWithoutStoresInput = {
    where: JobsScalarWhereInput
    data: XOR<JobsUpdateManyMutationInput, JobsUncheckedUpdateManyWithoutStoresInput>
  }

  export type JobsScalarWhereInput = {
    AND?: JobsScalarWhereInput | JobsScalarWhereInput[]
    OR?: JobsScalarWhereInput[]
    NOT?: JobsScalarWhereInput | JobsScalarWhereInput[]
    id?: IntFilter<"Jobs"> | number
    store_id?: IntFilter<"Jobs"> | number
    job_metadata?: JsonFilter<"Jobs">
    status?: EnumJobsStatusTypeFilter<"Jobs"> | $Enums.JobsStatusType
    type?: EnumJobTypeFilter<"Jobs"> | $Enums.JobType
    job_details?: JsonFilter<"Jobs">
    created_at?: BigIntFilter<"Jobs"> | bigint | number
    updated_at?: BigIntFilter<"Jobs"> | bigint | number
  }

  export type MessageHistoryUpsertWithWhereUniqueWithoutStoresInput = {
    where: MessageHistoryWhereUniqueInput
    update: XOR<MessageHistoryUpdateWithoutStoresInput, MessageHistoryUncheckedUpdateWithoutStoresInput>
    create: XOR<MessageHistoryCreateWithoutStoresInput, MessageHistoryUncheckedCreateWithoutStoresInput>
  }

  export type MessageHistoryUpdateWithWhereUniqueWithoutStoresInput = {
    where: MessageHistoryWhereUniqueInput
    data: XOR<MessageHistoryUpdateWithoutStoresInput, MessageHistoryUncheckedUpdateWithoutStoresInput>
  }

  export type MessageHistoryUpdateManyWithWhereWithoutStoresInput = {
    where: MessageHistoryScalarWhereInput
    data: XOR<MessageHistoryUpdateManyMutationInput, MessageHistoryUncheckedUpdateManyWithoutStoresInput>
  }

  export type MessageHistoryScalarWhereInput = {
    AND?: MessageHistoryScalarWhereInput | MessageHistoryScalarWhereInput[]
    OR?: MessageHistoryScalarWhereInput[]
    NOT?: MessageHistoryScalarWhereInput | MessageHistoryScalarWhereInput[]
    id?: IntFilter<"MessageHistory"> | number
    status?: EnumMessageHistoryStatusTypeFilter<"MessageHistory"> | $Enums.MessageHistoryStatusType
    referenceId?: StringFilter<"MessageHistory"> | string
    metaData?: JsonFilter<"MessageHistory">
    created_at?: BigIntFilter<"MessageHistory"> | bigint | number
    store_id?: IntFilter<"MessageHistory"> | number
  }

  export type NotificationsUpsertWithWhereUniqueWithoutStoresInput = {
    where: NotificationsWhereUniqueInput
    update: XOR<NotificationsUpdateWithoutStoresInput, NotificationsUncheckedUpdateWithoutStoresInput>
    create: XOR<NotificationsCreateWithoutStoresInput, NotificationsUncheckedCreateWithoutStoresInput>
  }

  export type NotificationsUpdateWithWhereUniqueWithoutStoresInput = {
    where: NotificationsWhereUniqueInput
    data: XOR<NotificationsUpdateWithoutStoresInput, NotificationsUncheckedUpdateWithoutStoresInput>
  }

  export type NotificationsUpdateManyWithWhereWithoutStoresInput = {
    where: NotificationsScalarWhereInput
    data: XOR<NotificationsUpdateManyMutationInput, NotificationsUncheckedUpdateManyWithoutStoresInput>
  }

  export type NotificationsScalarWhereInput = {
    AND?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    OR?: NotificationsScalarWhereInput[]
    NOT?: NotificationsScalarWhereInput | NotificationsScalarWhereInput[]
    id?: IntFilter<"Notifications"> | number
    notification_id?: StringFilter<"Notifications"> | string
    store_id?: IntFilter<"Notifications"> | number
    type?: EnumNotificationTypeFilter<"Notifications"> | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFilter<"Notifications"> | $Enums.NotificationReceiverType
    subject?: StringFilter<"Notifications"> | string
    status?: EnumNotificationStatusTypeFilter<"Notifications"> | $Enums.NotificationStatusType
    created_at?: BigIntFilter<"Notifications"> | bigint | number
    updated_at?: BigIntFilter<"Notifications"> | bigint | number
    languages?: StringFilter<"Notifications"> | string
  }

  export type OrderItemsUpsertWithWhereUniqueWithoutStoresInput = {
    where: OrderItemsWhereUniqueInput
    update: XOR<OrderItemsUpdateWithoutStoresInput, OrderItemsUncheckedUpdateWithoutStoresInput>
    create: XOR<OrderItemsCreateWithoutStoresInput, OrderItemsUncheckedCreateWithoutStoresInput>
  }

  export type OrderItemsUpdateWithWhereUniqueWithoutStoresInput = {
    where: OrderItemsWhereUniqueInput
    data: XOR<OrderItemsUpdateWithoutStoresInput, OrderItemsUncheckedUpdateWithoutStoresInput>
  }

  export type OrderItemsUpdateManyWithWhereWithoutStoresInput = {
    where: OrderItemsScalarWhereInput
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyWithoutStoresInput>
  }

  export type OrderItemsScalarWhereInput = {
    AND?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
    OR?: OrderItemsScalarWhereInput[]
    NOT?: OrderItemsScalarWhereInput | OrderItemsScalarWhereInput[]
    id?: IntFilter<"OrderItems"> | number
    store_id?: IntFilter<"OrderItems"> | number
    affiliate_id?: IntFilter<"OrderItems"> | number
    customer_id?: IntFilter<"OrderItems"> | number
    order_id?: IntFilter<"OrderItems"> | number
    item_id?: BigIntFilter<"OrderItems"> | bigint | number
    product_id?: BigIntFilter<"OrderItems"> | bigint | number
    variant_id?: BigIntFilter<"OrderItems"> | bigint | number
    product_title?: StringFilter<"OrderItems"> | string
    variant_title?: StringFilter<"OrderItems"> | string
    quantity?: IntFilter<"OrderItems"> | number
    shop_item_currency_code?: StringFilter<"OrderItems"> | string
    shop_item_amount?: FloatFilter<"OrderItems"> | number
    customer_item_currency_code?: StringFilter<"OrderItems"> | string
    customer_item_amount?: FloatFilter<"OrderItems"> | number
    item_details?: JsonFilter<"OrderItems">
    created_at?: BigIntFilter<"OrderItems"> | bigint | number
    updated_at?: BigIntFilter<"OrderItems"> | bigint | number
  }

  export type OrdersUpsertWithWhereUniqueWithoutStoresInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutStoresInput, OrdersUncheckedUpdateWithoutStoresInput>
    create: XOR<OrdersCreateWithoutStoresInput, OrdersUncheckedCreateWithoutStoresInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutStoresInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutStoresInput, OrdersUncheckedUpdateWithoutStoresInput>
  }

  export type OrdersUpdateManyWithWhereWithoutStoresInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutStoresInput>
  }

  export type OrdersScalarWhereInput = {
    AND?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    OR?: OrdersScalarWhereInput[]
    NOT?: OrdersScalarWhereInput | OrdersScalarWhereInput[]
    id?: IntFilter<"Orders"> | number
    store_id?: IntFilter<"Orders"> | number
    affiliate_id?: IntFilter<"Orders"> | number
    customer_id?: IntFilter<"Orders"> | number
    order_id?: BigIntFilter<"Orders"> | bigint | number
    shopify_order_number?: IntFilter<"Orders"> | number
    shop_order_currency_code?: StringFilter<"Orders"> | string
    shop_order_amount?: FloatFilter<"Orders"> | number
    customer_order_currency_code?: StringFilter<"Orders"> | string
    customer_order_amount?: FloatFilter<"Orders"> | number
    financial_status?: StringFilter<"Orders"> | string
    order_details?: JsonFilter<"Orders">
    attribute_type?: EnumOrderAttributeTypeFilter<"Orders"> | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFilter<"Orders"> | $Enums.OrderStatusType
    created_at?: BigIntFilter<"Orders"> | bigint | number
    updated_at?: BigIntFilter<"Orders"> | bigint | number
    program_id?: IntNullableFilter<"Orders"> | number | null
  }

  export type PaymentGatewayUpsertWithWhereUniqueWithoutStoresInput = {
    where: PaymentGatewayWhereUniqueInput
    update: XOR<PaymentGatewayUpdateWithoutStoresInput, PaymentGatewayUncheckedUpdateWithoutStoresInput>
    create: XOR<PaymentGatewayCreateWithoutStoresInput, PaymentGatewayUncheckedCreateWithoutStoresInput>
  }

  export type PaymentGatewayUpdateWithWhereUniqueWithoutStoresInput = {
    where: PaymentGatewayWhereUniqueInput
    data: XOR<PaymentGatewayUpdateWithoutStoresInput, PaymentGatewayUncheckedUpdateWithoutStoresInput>
  }

  export type PaymentGatewayUpdateManyWithWhereWithoutStoresInput = {
    where: PaymentGatewayScalarWhereInput
    data: XOR<PaymentGatewayUpdateManyMutationInput, PaymentGatewayUncheckedUpdateManyWithoutStoresInput>
  }

  export type PaymentGatewayScalarWhereInput = {
    AND?: PaymentGatewayScalarWhereInput | PaymentGatewayScalarWhereInput[]
    OR?: PaymentGatewayScalarWhereInput[]
    NOT?: PaymentGatewayScalarWhereInput | PaymentGatewayScalarWhereInput[]
    id?: IntFilter<"PaymentGateway"> | number
    store_id?: IntFilter<"PaymentGateway"> | number
    payment_uuid?: StringFilter<"PaymentGateway"> | string
    provider?: EnumPaymentTypeFilter<"PaymentGateway"> | $Enums.PaymentType
    credentials?: JsonFilter<"PaymentGateway">
    webhook_id?: StringNullableFilter<"PaymentGateway"> | string | null
    status?: EnumNotificationStatusTypeFilter<"PaymentGateway"> | $Enums.NotificationStatusType
    created_at?: BigIntFilter<"PaymentGateway"> | bigint | number
    updated_at?: BigIntFilter<"PaymentGateway"> | bigint | number
  }

  export type PayoutsUpsertWithWhereUniqueWithoutStoresInput = {
    where: PayoutsWhereUniqueInput
    update: XOR<PayoutsUpdateWithoutStoresInput, PayoutsUncheckedUpdateWithoutStoresInput>
    create: XOR<PayoutsCreateWithoutStoresInput, PayoutsUncheckedCreateWithoutStoresInput>
  }

  export type PayoutsUpdateWithWhereUniqueWithoutStoresInput = {
    where: PayoutsWhereUniqueInput
    data: XOR<PayoutsUpdateWithoutStoresInput, PayoutsUncheckedUpdateWithoutStoresInput>
  }

  export type PayoutsUpdateManyWithWhereWithoutStoresInput = {
    where: PayoutsScalarWhereInput
    data: XOR<PayoutsUpdateManyMutationInput, PayoutsUncheckedUpdateManyWithoutStoresInput>
  }

  export type PayoutsScalarWhereInput = {
    AND?: PayoutsScalarWhereInput | PayoutsScalarWhereInput[]
    OR?: PayoutsScalarWhereInput[]
    NOT?: PayoutsScalarWhereInput | PayoutsScalarWhereInput[]
    id?: IntFilter<"Payouts"> | number
    store_id?: IntFilter<"Payouts"> | number
    affiliate_id?: IntFilter<"Payouts"> | number
    transaction_id?: StringFilter<"Payouts"> | string
    currency_code?: StringFilter<"Payouts"> | string
    amount?: FloatFilter<"Payouts"> | number
    notes?: StringFilter<"Payouts"> | string
    payment_method?: EnumPaymentTypeFilter<"Payouts"> | $Enums.PaymentType
    payment_details?: JsonFilter<"Payouts">
    status?: EnumStatusTypeFilter<"Payouts"> | $Enums.StatusType
    created_at?: BigIntFilter<"Payouts"> | bigint | number
    updated_at?: BigIntFilter<"Payouts"> | bigint | number
    user_id?: BigIntNullableFilter<"Payouts"> | bigint | number | null
    job_id?: IntFilter<"Payouts"> | number
  }

  export type ProgramBonusUpsertWithWhereUniqueWithoutStoresInput = {
    where: ProgramBonusWhereUniqueInput
    update: XOR<ProgramBonusUpdateWithoutStoresInput, ProgramBonusUncheckedUpdateWithoutStoresInput>
    create: XOR<ProgramBonusCreateWithoutStoresInput, ProgramBonusUncheckedCreateWithoutStoresInput>
  }

  export type ProgramBonusUpdateWithWhereUniqueWithoutStoresInput = {
    where: ProgramBonusWhereUniqueInput
    data: XOR<ProgramBonusUpdateWithoutStoresInput, ProgramBonusUncheckedUpdateWithoutStoresInput>
  }

  export type ProgramBonusUpdateManyWithWhereWithoutStoresInput = {
    where: ProgramBonusScalarWhereInput
    data: XOR<ProgramBonusUpdateManyMutationInput, ProgramBonusUncheckedUpdateManyWithoutStoresInput>
  }

  export type ProgramBonusScalarWhereInput = {
    AND?: ProgramBonusScalarWhereInput | ProgramBonusScalarWhereInput[]
    OR?: ProgramBonusScalarWhereInput[]
    NOT?: ProgramBonusScalarWhereInput | ProgramBonusScalarWhereInput[]
    id?: IntFilter<"ProgramBonus"> | number
    store_id?: IntFilter<"ProgramBonus"> | number
    program_id?: IntFilter<"ProgramBonus"> | number
    bonus_id?: IntFilter<"ProgramBonus"> | number
    created_at?: BigIntFilter<"ProgramBonus"> | bigint | number
    updated_at?: BigIntFilter<"ProgramBonus"> | bigint | number
  }

  export type ProgramsUpsertWithWhereUniqueWithoutStoresInput = {
    where: ProgramsWhereUniqueInput
    update: XOR<ProgramsUpdateWithoutStoresInput, ProgramsUncheckedUpdateWithoutStoresInput>
    create: XOR<ProgramsCreateWithoutStoresInput, ProgramsUncheckedCreateWithoutStoresInput>
  }

  export type ProgramsUpdateWithWhereUniqueWithoutStoresInput = {
    where: ProgramsWhereUniqueInput
    data: XOR<ProgramsUpdateWithoutStoresInput, ProgramsUncheckedUpdateWithoutStoresInput>
  }

  export type ProgramsUpdateManyWithWhereWithoutStoresInput = {
    where: ProgramsScalarWhereInput
    data: XOR<ProgramsUpdateManyMutationInput, ProgramsUncheckedUpdateManyWithoutStoresInput>
  }

  export type ProgramsScalarWhereInput = {
    AND?: ProgramsScalarWhereInput | ProgramsScalarWhereInput[]
    OR?: ProgramsScalarWhereInput[]
    NOT?: ProgramsScalarWhereInput | ProgramsScalarWhereInput[]
    id?: IntFilter<"Programs"> | number
    store_id?: IntFilter<"Programs"> | number
    title?: StringFilter<"Programs"> | string
    description?: StringFilter<"Programs"> | string
    currency_code?: StringFilter<"Programs"> | string
    program_details?: JsonFilter<"Programs">
    status?: EnumProgramStatusTypeFilter<"Programs"> | $Enums.ProgramStatusType
    created_at?: BigIntFilter<"Programs"> | bigint | number
    updated_at?: BigIntFilter<"Programs"> | bigint | number
  }

  export type SettingsUpsertWithoutStoresInput = {
    update: XOR<SettingsUpdateWithoutStoresInput, SettingsUncheckedUpdateWithoutStoresInput>
    create: XOR<SettingsCreateWithoutStoresInput, SettingsUncheckedCreateWithoutStoresInput>
    where?: SettingsWhereInput
  }

  export type SettingsUpdateToOneWithWhereWithoutStoresInput = {
    where?: SettingsWhereInput
    data: XOR<SettingsUpdateWithoutStoresInput, SettingsUncheckedUpdateWithoutStoresInput>
  }

  export type SettingsUpdateWithoutStoresInput = {
    commission_delay?: IntFieldUpdateOperationsInput | number
    commission_approval_mode?: EnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType
    commission_calculation?: EnumCommissionCalculationTypeFieldUpdateOperationsInput | $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    current_email_lang?: StringFieldUpdateOperationsInput | string
    email_limit?: IntFieldUpdateOperationsInput | number
    notify_once?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SettingsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    commission_delay?: IntFieldUpdateOperationsInput | number
    commission_approval_mode?: EnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType
    commission_calculation?: EnumCommissionCalculationTypeFieldUpdateOperationsInput | $Enums.CommissionCalculationType
    details?: NullableJsonNullValueInput | InputJsonValue
    min_threshold?: NullableIntFieldUpdateOperationsInput | number | null
    primary_color?: StringFieldUpdateOperationsInput | string
    secondary_color?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    current_email_lang?: StringFieldUpdateOperationsInput | string
    email_limit?: IntFieldUpdateOperationsInput | number
    notify_once?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TiersUpsertWithWhereUniqueWithoutStoresInput = {
    where: TiersWhereUniqueInput
    update: XOR<TiersUpdateWithoutStoresInput, TiersUncheckedUpdateWithoutStoresInput>
    create: XOR<TiersCreateWithoutStoresInput, TiersUncheckedCreateWithoutStoresInput>
  }

  export type TiersUpdateWithWhereUniqueWithoutStoresInput = {
    where: TiersWhereUniqueInput
    data: XOR<TiersUpdateWithoutStoresInput, TiersUncheckedUpdateWithoutStoresInput>
  }

  export type TiersUpdateManyWithWhereWithoutStoresInput = {
    where: TiersScalarWhereInput
    data: XOR<TiersUpdateManyMutationInput, TiersUncheckedUpdateManyWithoutStoresInput>
  }

  export type TiersScalarWhereInput = {
    AND?: TiersScalarWhereInput | TiersScalarWhereInput[]
    OR?: TiersScalarWhereInput[]
    NOT?: TiersScalarWhereInput | TiersScalarWhereInput[]
    id?: IntFilter<"Tiers"> | number
    store_id?: IntFilter<"Tiers"> | number
    program_id?: IntFilter<"Tiers"> | number
    tier_type?: EnumTierTypeFilter<"Tiers"> | $Enums.TierType
    min_value?: FloatFilter<"Tiers"> | number
    max_value?: FloatNullableFilter<"Tiers"> | number | null
    commission_type?: EnumEarningTypeFilter<"Tiers"> | $Enums.EarningType
    commission_rate?: FloatFilter<"Tiers"> | number
    created_at?: BigIntFilter<"Tiers"> | bigint | number
    updated_at?: BigIntFilter<"Tiers"> | bigint | number
  }

  export type TransactionsUpsertWithWhereUniqueWithoutStoresInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutStoresInput, TransactionsUncheckedUpdateWithoutStoresInput>
    create: XOR<TransactionsCreateWithoutStoresInput, TransactionsUncheckedCreateWithoutStoresInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutStoresInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutStoresInput, TransactionsUncheckedUpdateWithoutStoresInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutStoresInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutStoresInput>
  }

  export type TransactionsScalarWhereInput = {
    AND?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    OR?: TransactionsScalarWhereInput[]
    NOT?: TransactionsScalarWhereInput | TransactionsScalarWhereInput[]
    id?: IntFilter<"Transactions"> | number
    store_id?: IntFilter<"Transactions"> | number
    affiliate_id?: IntFilter<"Transactions"> | number
    reference_type?: EnumTransactionReferenceTypeFilter<"Transactions"> | $Enums.TransactionReferenceType
    reference_id?: StringFilter<"Transactions"> | string
    currency_code?: StringFilter<"Transactions"> | string
    type?: EnumTransactionTypeFilter<"Transactions"> | $Enums.TransactionType
    is_reverted?: BoolFilter<"Transactions"> | boolean
    amount?: FloatFilter<"Transactions"> | number
    created_at?: BigIntFilter<"Transactions"> | bigint | number
    updated_at?: BigIntFilter<"Transactions"> | bigint | number
  }

  export type AffiliatesCreateWithoutMembersInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutMembersInput = {
    id?: number
    store_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutMembersInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutMembersInput, AffiliatesUncheckedCreateWithoutMembersInput>
  }

  export type AffiliatesCreateManyMembersInputEnvelope = {
    data: AffiliatesCreateManyMembersInput | AffiliatesCreateManyMembersInput[]
    skipDuplicates?: boolean
  }

  export type AffiliatesUpsertWithWhereUniqueWithoutMembersInput = {
    where: AffiliatesWhereUniqueInput
    update: XOR<AffiliatesUpdateWithoutMembersInput, AffiliatesUncheckedUpdateWithoutMembersInput>
    create: XOR<AffiliatesCreateWithoutMembersInput, AffiliatesUncheckedCreateWithoutMembersInput>
  }

  export type AffiliatesUpdateWithWhereUniqueWithoutMembersInput = {
    where: AffiliatesWhereUniqueInput
    data: XOR<AffiliatesUpdateWithoutMembersInput, AffiliatesUncheckedUpdateWithoutMembersInput>
  }

  export type AffiliatesUpdateManyWithWhereWithoutMembersInput = {
    where: AffiliatesScalarWhereInput
    data: XOR<AffiliatesUpdateManyMutationInput, AffiliatesUncheckedUpdateManyWithoutMembersInput>
  }

  export type AffiliateProgramsCreateWithoutProgramsInput = {
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_programsInput
    stores: StoresCreateNestedOneWithoutAffiliate_programsInput
  }

  export type AffiliateProgramsUncheckedCreateWithoutProgramsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramsCreateOrConnectWithoutProgramsInput = {
    where: AffiliateProgramsWhereUniqueInput
    create: XOR<AffiliateProgramsCreateWithoutProgramsInput, AffiliateProgramsUncheckedCreateWithoutProgramsInput>
  }

  export type AffiliateProgramsCreateManyProgramsInputEnvelope = {
    data: AffiliateProgramsCreateManyProgramsInput | AffiliateProgramsCreateManyProgramsInput[]
    skipDuplicates?: boolean
  }

  export type CustomerDiscountsCreateWithoutProgramsInput = {
    discount_rate: number
    discount_options: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    discount_type: $Enums.CustomerDiscountType
    stores: StoresCreateNestedOneWithoutCustomer_discountsInput
  }

  export type CustomerDiscountsUncheckedCreateWithoutProgramsInput = {
    id?: number
    store_id: number
    discount_rate: number
    discount_options: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    discount_type: $Enums.CustomerDiscountType
  }

  export type CustomerDiscountsCreateOrConnectWithoutProgramsInput = {
    where: CustomerDiscountsWhereUniqueInput
    create: XOR<CustomerDiscountsCreateWithoutProgramsInput, CustomerDiscountsUncheckedCreateWithoutProgramsInput>
  }

  export type OrdersCreateWithoutProgramsInput = {
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    commissions?: CommissionsCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsCreateNestedManyWithoutOrdersInput
    affiliates: AffiliatesCreateNestedOneWithoutOrdersInput
    customers: CustomersCreateNestedOneWithoutOrdersInput
    stores: StoresCreateNestedOneWithoutOrdersInput
    activity_log?: ActivityLogCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutProgramsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    commissions?: CommissionsUncheckedCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutOrdersInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutProgramsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutProgramsInput, OrdersUncheckedCreateWithoutProgramsInput>
  }

  export type OrdersCreateManyProgramsInputEnvelope = {
    data: OrdersCreateManyProgramsInput | OrdersCreateManyProgramsInput[]
    skipDuplicates?: boolean
  }

  export type ProgramBonusCreateWithoutProgramsInput = {
    created_at: bigint | number
    updated_at: bigint | number
    bonus: BonusCreateNestedOneWithoutProgram_bonusInput
    stores: StoresCreateNestedOneWithoutProgram_bonusInput
  }

  export type ProgramBonusUncheckedCreateWithoutProgramsInput = {
    id?: number
    store_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ProgramBonusCreateOrConnectWithoutProgramsInput = {
    where: ProgramBonusWhereUniqueInput
    create: XOR<ProgramBonusCreateWithoutProgramsInput, ProgramBonusUncheckedCreateWithoutProgramsInput>
  }

  export type ProgramBonusCreateManyProgramsInputEnvelope = {
    data: ProgramBonusCreateManyProgramsInput | ProgramBonusCreateManyProgramsInput[]
    skipDuplicates?: boolean
  }

  export type StoresCreateWithoutProgramsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutProgramsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutProgramsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutProgramsInput, StoresUncheckedCreateWithoutProgramsInput>
  }

  export type TiersCreateWithoutProgramsInput = {
    tier_type: $Enums.TierType
    min_value: number
    max_value?: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutTiersInput
  }

  export type TiersUncheckedCreateWithoutProgramsInput = {
    id?: number
    store_id: number
    tier_type: $Enums.TierType
    min_value: number
    max_value?: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TiersCreateOrConnectWithoutProgramsInput = {
    where: TiersWhereUniqueInput
    create: XOR<TiersCreateWithoutProgramsInput, TiersUncheckedCreateWithoutProgramsInput>
  }

  export type TiersCreateManyProgramsInputEnvelope = {
    data: TiersCreateManyProgramsInput | TiersCreateManyProgramsInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutProgramsInput = {
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
    stores: StoresCreateNestedOneWithoutActivity_logInput
    affiliates?: AffiliatesCreateNestedOneWithoutActivity_logInput
    orders?: OrdersCreateNestedOneWithoutActivity_logInput
    payouts?: PayoutsCreateNestedOneWithoutActivity_logInput
  }

  export type ActivityLogUncheckedCreateWithoutProgramsInput = {
    id?: number
    store_id: number
    affiliate_id?: number | null
    order_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type ActivityLogCreateOrConnectWithoutProgramsInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutProgramsInput, ActivityLogUncheckedCreateWithoutProgramsInput>
  }

  export type ActivityLogCreateManyProgramsInputEnvelope = {
    data: ActivityLogCreateManyProgramsInput | ActivityLogCreateManyProgramsInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateProgramsUpsertWithWhereUniqueWithoutProgramsInput = {
    where: AffiliateProgramsWhereUniqueInput
    update: XOR<AffiliateProgramsUpdateWithoutProgramsInput, AffiliateProgramsUncheckedUpdateWithoutProgramsInput>
    create: XOR<AffiliateProgramsCreateWithoutProgramsInput, AffiliateProgramsUncheckedCreateWithoutProgramsInput>
  }

  export type AffiliateProgramsUpdateWithWhereUniqueWithoutProgramsInput = {
    where: AffiliateProgramsWhereUniqueInput
    data: XOR<AffiliateProgramsUpdateWithoutProgramsInput, AffiliateProgramsUncheckedUpdateWithoutProgramsInput>
  }

  export type AffiliateProgramsUpdateManyWithWhereWithoutProgramsInput = {
    where: AffiliateProgramsScalarWhereInput
    data: XOR<AffiliateProgramsUpdateManyMutationInput, AffiliateProgramsUncheckedUpdateManyWithoutProgramsInput>
  }

  export type CustomerDiscountsUpsertWithoutProgramsInput = {
    update: XOR<CustomerDiscountsUpdateWithoutProgramsInput, CustomerDiscountsUncheckedUpdateWithoutProgramsInput>
    create: XOR<CustomerDiscountsCreateWithoutProgramsInput, CustomerDiscountsUncheckedCreateWithoutProgramsInput>
    where?: CustomerDiscountsWhereInput
  }

  export type CustomerDiscountsUpdateToOneWithWhereWithoutProgramsInput = {
    where?: CustomerDiscountsWhereInput
    data: XOR<CustomerDiscountsUpdateWithoutProgramsInput, CustomerDiscountsUncheckedUpdateWithoutProgramsInput>
  }

  export type CustomerDiscountsUpdateWithoutProgramsInput = {
    discount_rate?: FloatFieldUpdateOperationsInput | number
    discount_options?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_type?: EnumCustomerDiscountTypeFieldUpdateOperationsInput | $Enums.CustomerDiscountType
    stores?: StoresUpdateOneRequiredWithoutCustomer_discountsNestedInput
  }

  export type CustomerDiscountsUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    discount_rate?: FloatFieldUpdateOperationsInput | number
    discount_options?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_type?: EnumCustomerDiscountTypeFieldUpdateOperationsInput | $Enums.CustomerDiscountType
  }

  export type OrdersUpsertWithWhereUniqueWithoutProgramsInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutProgramsInput, OrdersUncheckedUpdateWithoutProgramsInput>
    create: XOR<OrdersCreateWithoutProgramsInput, OrdersUncheckedCreateWithoutProgramsInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutProgramsInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutProgramsInput, OrdersUncheckedUpdateWithoutProgramsInput>
  }

  export type OrdersUpdateManyWithWhereWithoutProgramsInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutProgramsInput>
  }

  export type ProgramBonusUpsertWithWhereUniqueWithoutProgramsInput = {
    where: ProgramBonusWhereUniqueInput
    update: XOR<ProgramBonusUpdateWithoutProgramsInput, ProgramBonusUncheckedUpdateWithoutProgramsInput>
    create: XOR<ProgramBonusCreateWithoutProgramsInput, ProgramBonusUncheckedCreateWithoutProgramsInput>
  }

  export type ProgramBonusUpdateWithWhereUniqueWithoutProgramsInput = {
    where: ProgramBonusWhereUniqueInput
    data: XOR<ProgramBonusUpdateWithoutProgramsInput, ProgramBonusUncheckedUpdateWithoutProgramsInput>
  }

  export type ProgramBonusUpdateManyWithWhereWithoutProgramsInput = {
    where: ProgramBonusScalarWhereInput
    data: XOR<ProgramBonusUpdateManyMutationInput, ProgramBonusUncheckedUpdateManyWithoutProgramsInput>
  }

  export type StoresUpsertWithoutProgramsInput = {
    update: XOR<StoresUpdateWithoutProgramsInput, StoresUncheckedUpdateWithoutProgramsInput>
    create: XOR<StoresCreateWithoutProgramsInput, StoresUncheckedCreateWithoutProgramsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutProgramsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutProgramsInput, StoresUncheckedUpdateWithoutProgramsInput>
  }

  export type StoresUpdateWithoutProgramsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type TiersUpsertWithWhereUniqueWithoutProgramsInput = {
    where: TiersWhereUniqueInput
    update: XOR<TiersUpdateWithoutProgramsInput, TiersUncheckedUpdateWithoutProgramsInput>
    create: XOR<TiersCreateWithoutProgramsInput, TiersUncheckedCreateWithoutProgramsInput>
  }

  export type TiersUpdateWithWhereUniqueWithoutProgramsInput = {
    where: TiersWhereUniqueInput
    data: XOR<TiersUpdateWithoutProgramsInput, TiersUncheckedUpdateWithoutProgramsInput>
  }

  export type TiersUpdateManyWithWhereWithoutProgramsInput = {
    where: TiersScalarWhereInput
    data: XOR<TiersUpdateManyMutationInput, TiersUncheckedUpdateManyWithoutProgramsInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutProgramsInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutProgramsInput, ActivityLogUncheckedUpdateWithoutProgramsInput>
    create: XOR<ActivityLogCreateWithoutProgramsInput, ActivityLogUncheckedCreateWithoutProgramsInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutProgramsInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutProgramsInput, ActivityLogUncheckedUpdateWithoutProgramsInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutProgramsInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutProgramsInput>
  }

  export type ProgramsCreateWithoutTiersInput = {
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsCreateNestedOneWithoutProgramsInput
    Orders?: OrdersCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutProgramsInput
    stores: StoresCreateNestedOneWithoutProgramsInput
    activity_log?: ActivityLogCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsUncheckedCreateWithoutTiersInput = {
    id?: number
    store_id: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedOneWithoutProgramsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsCreateOrConnectWithoutTiersInput = {
    where: ProgramsWhereUniqueInput
    create: XOR<ProgramsCreateWithoutTiersInput, ProgramsUncheckedCreateWithoutTiersInput>
  }

  export type StoresCreateWithoutTiersInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutTiersInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutTiersInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutTiersInput, StoresUncheckedCreateWithoutTiersInput>
  }

  export type ProgramsUpsertWithoutTiersInput = {
    update: XOR<ProgramsUpdateWithoutTiersInput, ProgramsUncheckedUpdateWithoutTiersInput>
    create: XOR<ProgramsCreateWithoutTiersInput, ProgramsUncheckedCreateWithoutTiersInput>
    where?: ProgramsWhereInput
  }

  export type ProgramsUpdateToOneWithWhereWithoutTiersInput = {
    where?: ProgramsWhereInput
    data: XOR<ProgramsUpdateWithoutTiersInput, ProgramsUncheckedUpdateWithoutTiersInput>
  }

  export type ProgramsUpdateWithoutTiersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutProgramsNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgramsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsUncheckedUpdateWithoutTiersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutProgramsNestedInput
  }

  export type StoresUpsertWithoutTiersInput = {
    update: XOR<StoresUpdateWithoutTiersInput, StoresUncheckedUpdateWithoutTiersInput>
    create: XOR<StoresCreateWithoutTiersInput, StoresUncheckedCreateWithoutTiersInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutTiersInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutTiersInput, StoresUncheckedUpdateWithoutTiersInput>
  }

  export type StoresUpdateWithoutTiersInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutTiersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type ProgramsCreateWithoutCustomer_discountsInput = {
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutProgramsInput
    Orders?: OrdersCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutProgramsInput
    stores: StoresCreateNestedOneWithoutProgramsInput
    tiers?: TiersCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsUncheckedCreateWithoutCustomer_discountsInput = {
    id?: number
    store_id: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutProgramsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutProgramsInput
    tiers?: TiersUncheckedCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsCreateOrConnectWithoutCustomer_discountsInput = {
    where: ProgramsWhereUniqueInput
    create: XOR<ProgramsCreateWithoutCustomer_discountsInput, ProgramsUncheckedCreateWithoutCustomer_discountsInput>
  }

  export type StoresCreateWithoutCustomer_discountsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutCustomer_discountsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutCustomer_discountsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutCustomer_discountsInput, StoresUncheckedCreateWithoutCustomer_discountsInput>
  }

  export type ProgramsUpsertWithoutCustomer_discountsInput = {
    update: XOR<ProgramsUpdateWithoutCustomer_discountsInput, ProgramsUncheckedUpdateWithoutCustomer_discountsInput>
    create: XOR<ProgramsCreateWithoutCustomer_discountsInput, ProgramsUncheckedCreateWithoutCustomer_discountsInput>
    where?: ProgramsWhereInput
  }

  export type ProgramsUpdateToOneWithWhereWithoutCustomer_discountsInput = {
    where?: ProgramsWhereInput
    data: XOR<ProgramsUpdateWithoutCustomer_discountsInput, ProgramsUncheckedUpdateWithoutCustomer_discountsInput>
  }

  export type ProgramsUpdateWithoutCustomer_discountsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutProgramsNestedInput
    Orders?: OrdersUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutProgramsNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgramsNestedInput
    tiers?: TiersUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsUncheckedUpdateWithoutCustomer_discountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutProgramsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutProgramsNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutProgramsNestedInput
  }

  export type StoresUpsertWithoutCustomer_discountsInput = {
    update: XOR<StoresUpdateWithoutCustomer_discountsInput, StoresUncheckedUpdateWithoutCustomer_discountsInput>
    create: XOR<StoresCreateWithoutCustomer_discountsInput, StoresUncheckedCreateWithoutCustomer_discountsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutCustomer_discountsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutCustomer_discountsInput, StoresUncheckedUpdateWithoutCustomer_discountsInput>
  }

  export type StoresUpdateWithoutCustomer_discountsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutCustomer_discountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type CommissionsCreateWithoutOrdersInput = {
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutCommissionsInput
    stores: StoresCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionsUncheckedCreateWithoutOrdersInput = {
    id?: number
    store_id: number
    affiliate_id: number
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CommissionsCreateOrConnectWithoutOrdersInput = {
    where: CommissionsWhereUniqueInput
    create: XOR<CommissionsCreateWithoutOrdersInput, CommissionsUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemsCreateWithoutOrdersInput = {
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutOrder_itemsInput
    customers: CustomersCreateNestedOneWithoutOrder_itemsInput
    stores: StoresCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemsUncheckedCreateWithoutOrdersInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrderItemsCreateOrConnectWithoutOrdersInput = {
    where: OrderItemsWhereUniqueInput
    create: XOR<OrderItemsCreateWithoutOrdersInput, OrderItemsUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemsCreateManyOrdersInputEnvelope = {
    data: OrderItemsCreateManyOrdersInput | OrderItemsCreateManyOrdersInput[]
    skipDuplicates?: boolean
  }

  export type AffiliatesCreateWithoutOrdersInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutOrdersInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutOrdersInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutOrdersInput, AffiliatesUncheckedCreateWithoutOrdersInput>
  }

  export type CustomersCreateWithoutOrdersInput = {
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutCustomersInput
    stores: StoresCreateNestedOneWithoutCustomersInput
    order_items?: OrderItemsCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutOrdersInput = {
    id?: number
    store_id: number
    affiliate_id: number
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutOrdersInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutOrdersInput, CustomersUncheckedCreateWithoutOrdersInput>
  }

  export type ProgramsCreateWithoutOrdersInput = {
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsCreateNestedOneWithoutProgramsInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutProgramsInput
    stores: StoresCreateNestedOneWithoutProgramsInput
    tiers?: TiersCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsUncheckedCreateWithoutOrdersInput = {
    id?: number
    store_id: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedOneWithoutProgramsInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutProgramsInput
    tiers?: TiersUncheckedCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsCreateOrConnectWithoutOrdersInput = {
    where: ProgramsWhereUniqueInput
    create: XOR<ProgramsCreateWithoutOrdersInput, ProgramsUncheckedCreateWithoutOrdersInput>
  }

  export type StoresCreateWithoutOrdersInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutOrdersInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutOrdersInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutOrdersInput, StoresUncheckedCreateWithoutOrdersInput>
  }

  export type ActivityLogCreateWithoutOrdersInput = {
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
    stores: StoresCreateNestedOneWithoutActivity_logInput
    affiliates?: AffiliatesCreateNestedOneWithoutActivity_logInput
    programs?: ProgramsCreateNestedOneWithoutActivity_logInput
    payouts?: PayoutsCreateNestedOneWithoutActivity_logInput
  }

  export type ActivityLogUncheckedCreateWithoutOrdersInput = {
    id?: number
    store_id: number
    affiliate_id?: number | null
    program_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type ActivityLogCreateOrConnectWithoutOrdersInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutOrdersInput, ActivityLogUncheckedCreateWithoutOrdersInput>
  }

  export type ActivityLogCreateManyOrdersInputEnvelope = {
    data: ActivityLogCreateManyOrdersInput | ActivityLogCreateManyOrdersInput[]
    skipDuplicates?: boolean
  }

  export type CommissionsUpsertWithoutOrdersInput = {
    update: XOR<CommissionsUpdateWithoutOrdersInput, CommissionsUncheckedUpdateWithoutOrdersInput>
    create: XOR<CommissionsCreateWithoutOrdersInput, CommissionsUncheckedCreateWithoutOrdersInput>
    where?: CommissionsWhereInput
  }

  export type CommissionsUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CommissionsWhereInput
    data: XOR<CommissionsUpdateWithoutOrdersInput, CommissionsUncheckedUpdateWithoutOrdersInput>
  }

  export type CommissionsUpdateWithoutOrdersInput = {
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutCommissionsNestedInput
    stores?: StoresUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type CommissionsUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsUpsertWithWhereUniqueWithoutOrdersInput = {
    where: OrderItemsWhereUniqueInput
    update: XOR<OrderItemsUpdateWithoutOrdersInput, OrderItemsUncheckedUpdateWithoutOrdersInput>
    create: XOR<OrderItemsCreateWithoutOrdersInput, OrderItemsUncheckedCreateWithoutOrdersInput>
  }

  export type OrderItemsUpdateWithWhereUniqueWithoutOrdersInput = {
    where: OrderItemsWhereUniqueInput
    data: XOR<OrderItemsUpdateWithoutOrdersInput, OrderItemsUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderItemsUpdateManyWithWhereWithoutOrdersInput = {
    where: OrderItemsScalarWhereInput
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyWithoutOrdersInput>
  }

  export type AffiliatesUpsertWithoutOrdersInput = {
    update: XOR<AffiliatesUpdateWithoutOrdersInput, AffiliatesUncheckedUpdateWithoutOrdersInput>
    create: XOR<AffiliatesCreateWithoutOrdersInput, AffiliatesUncheckedCreateWithoutOrdersInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutOrdersInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutOrdersInput, AffiliatesUncheckedUpdateWithoutOrdersInput>
  }

  export type AffiliatesUpdateWithoutOrdersInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type CustomersUpsertWithoutOrdersInput = {
    update: XOR<CustomersUpdateWithoutOrdersInput, CustomersUncheckedUpdateWithoutOrdersInput>
    create: XOR<CustomersCreateWithoutOrdersInput, CustomersUncheckedCreateWithoutOrdersInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutOrdersInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutOrdersInput, CustomersUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomersUpdateWithoutOrdersInput = {
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutCustomersNestedInput
    stores?: StoresUpdateOneRequiredWithoutCustomersNestedInput
    order_items?: OrderItemsUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    order_items?: OrderItemsUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type ProgramsUpsertWithoutOrdersInput = {
    update: XOR<ProgramsUpdateWithoutOrdersInput, ProgramsUncheckedUpdateWithoutOrdersInput>
    create: XOR<ProgramsCreateWithoutOrdersInput, ProgramsUncheckedCreateWithoutOrdersInput>
    where?: ProgramsWhereInput
  }

  export type ProgramsUpdateToOneWithWhereWithoutOrdersInput = {
    where?: ProgramsWhereInput
    data: XOR<ProgramsUpdateWithoutOrdersInput, ProgramsUncheckedUpdateWithoutOrdersInput>
  }

  export type ProgramsUpdateWithoutOrdersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUpdateOneWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutProgramsNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgramsNestedInput
    tiers?: TiersUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateOneWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutProgramsNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutProgramsNestedInput
  }

  export type StoresUpsertWithoutOrdersInput = {
    update: XOR<StoresUpdateWithoutOrdersInput, StoresUncheckedUpdateWithoutOrdersInput>
    create: XOR<StoresCreateWithoutOrdersInput, StoresUncheckedCreateWithoutOrdersInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutOrdersInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutOrdersInput, StoresUncheckedUpdateWithoutOrdersInput>
  }

  export type StoresUpdateWithoutOrdersInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutOrdersInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutOrdersInput, ActivityLogUncheckedUpdateWithoutOrdersInput>
    create: XOR<ActivityLogCreateWithoutOrdersInput, ActivityLogUncheckedCreateWithoutOrdersInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutOrdersInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutOrdersInput, ActivityLogUncheckedUpdateWithoutOrdersInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutOrdersInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutOrdersInput>
  }

  export type AffiliatesCreateWithoutOrder_itemsInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutOrder_itemsInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutOrder_itemsInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutOrder_itemsInput, AffiliatesUncheckedCreateWithoutOrder_itemsInput>
  }

  export type CustomersCreateWithoutOrder_itemsInput = {
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutCustomersInput
    stores: StoresCreateNestedOneWithoutCustomersInput
    orders?: OrdersCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutOrder_itemsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutOrder_itemsInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutOrder_itemsInput, CustomersUncheckedCreateWithoutOrder_itemsInput>
  }

  export type OrdersCreateWithoutOrder_itemsInput = {
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    commissions?: CommissionsCreateNestedOneWithoutOrdersInput
    affiliates: AffiliatesCreateNestedOneWithoutOrdersInput
    customers: CustomersCreateNestedOneWithoutOrdersInput
    programs?: ProgramsCreateNestedOneWithoutOrdersInput
    stores: StoresCreateNestedOneWithoutOrdersInput
    activity_log?: ActivityLogCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutOrder_itemsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
    commissions?: CommissionsUncheckedCreateNestedOneWithoutOrdersInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutOrder_itemsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutOrder_itemsInput, OrdersUncheckedCreateWithoutOrder_itemsInput>
  }

  export type StoresCreateWithoutOrderItemsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutOrderItemsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutOrderItemsInput, StoresUncheckedCreateWithoutOrderItemsInput>
  }

  export type AffiliatesUpsertWithoutOrder_itemsInput = {
    update: XOR<AffiliatesUpdateWithoutOrder_itemsInput, AffiliatesUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<AffiliatesCreateWithoutOrder_itemsInput, AffiliatesUncheckedCreateWithoutOrder_itemsInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutOrder_itemsInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutOrder_itemsInput, AffiliatesUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type AffiliatesUpdateWithoutOrder_itemsInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutOrder_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type CustomersUpsertWithoutOrder_itemsInput = {
    update: XOR<CustomersUpdateWithoutOrder_itemsInput, CustomersUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<CustomersCreateWithoutOrder_itemsInput, CustomersUncheckedCreateWithoutOrder_itemsInput>
    where?: CustomersWhereInput
  }

  export type CustomersUpdateToOneWithWhereWithoutOrder_itemsInput = {
    where?: CustomersWhereInput
    data: XOR<CustomersUpdateWithoutOrder_itemsInput, CustomersUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type CustomersUpdateWithoutOrder_itemsInput = {
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutCustomersNestedInput
    stores?: StoresUpdateOneRequiredWithoutCustomersNestedInput
    orders?: OrdersUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutOrder_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    orders?: OrdersUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type OrdersUpsertWithoutOrder_itemsInput = {
    update: XOR<OrdersUpdateWithoutOrder_itemsInput, OrdersUncheckedUpdateWithoutOrder_itemsInput>
    create: XOR<OrdersCreateWithoutOrder_itemsInput, OrdersUncheckedCreateWithoutOrder_itemsInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutOrder_itemsInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutOrder_itemsInput, OrdersUncheckedUpdateWithoutOrder_itemsInput>
  }

  export type OrdersUpdateWithoutOrder_itemsInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    commissions?: CommissionsUpdateOneWithoutOrdersNestedInput
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrdersNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrdersNestedInput
    programs?: ProgramsUpdateOneWithoutOrdersNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrdersNestedInput
    activity_log?: ActivityLogUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutOrder_itemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    commissions?: CommissionsUncheckedUpdateOneWithoutOrdersNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type StoresUpsertWithoutOrderItemsInput = {
    update: XOR<StoresUpdateWithoutOrderItemsInput, StoresUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<StoresCreateWithoutOrderItemsInput, StoresUncheckedCreateWithoutOrderItemsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutOrderItemsInput, StoresUncheckedUpdateWithoutOrderItemsInput>
  }

  export type StoresUpdateWithoutOrderItemsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type AffiliatesCreateWithoutCommissionsInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutCommissionsInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutCommissionsInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutCommissionsInput, AffiliatesUncheckedCreateWithoutCommissionsInput>
  }

  export type OrdersCreateWithoutCommissionsInput = {
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    order_items?: OrderItemsCreateNestedManyWithoutOrdersInput
    affiliates: AffiliatesCreateNestedOneWithoutOrdersInput
    customers: CustomersCreateNestedOneWithoutOrdersInput
    programs?: ProgramsCreateNestedOneWithoutOrdersInput
    stores: StoresCreateNestedOneWithoutOrdersInput
    activity_log?: ActivityLogCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutCommissionsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutOrdersInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutCommissionsInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutCommissionsInput, OrdersUncheckedCreateWithoutCommissionsInput>
  }

  export type StoresCreateWithoutCommissionsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutCommissionsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutCommissionsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutCommissionsInput, StoresUncheckedCreateWithoutCommissionsInput>
  }

  export type AffiliatesUpsertWithoutCommissionsInput = {
    update: XOR<AffiliatesUpdateWithoutCommissionsInput, AffiliatesUncheckedUpdateWithoutCommissionsInput>
    create: XOR<AffiliatesCreateWithoutCommissionsInput, AffiliatesUncheckedCreateWithoutCommissionsInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutCommissionsInput, AffiliatesUncheckedUpdateWithoutCommissionsInput>
  }

  export type AffiliatesUpdateWithoutCommissionsInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutCommissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type OrdersUpsertWithoutCommissionsInput = {
    update: XOR<OrdersUpdateWithoutCommissionsInput, OrdersUncheckedUpdateWithoutCommissionsInput>
    create: XOR<OrdersCreateWithoutCommissionsInput, OrdersUncheckedCreateWithoutCommissionsInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutCommissionsInput, OrdersUncheckedUpdateWithoutCommissionsInput>
  }

  export type OrdersUpdateWithoutCommissionsInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    order_items?: OrderItemsUpdateManyWithoutOrdersNestedInput
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrdersNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrdersNestedInput
    programs?: ProgramsUpdateOneWithoutOrdersNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrdersNestedInput
    activity_log?: ActivityLogUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutCommissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_items?: OrderItemsUncheckedUpdateManyWithoutOrdersNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type StoresUpsertWithoutCommissionsInput = {
    update: XOR<StoresUpdateWithoutCommissionsInput, StoresUncheckedUpdateWithoutCommissionsInput>
    create: XOR<StoresCreateWithoutCommissionsInput, StoresUncheckedCreateWithoutCommissionsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutCommissionsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutCommissionsInput, StoresUncheckedUpdateWithoutCommissionsInput>
  }

  export type StoresUpdateWithoutCommissionsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutCommissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type AffiliatesCreateWithoutPayoutsInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutPayoutsInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutPayoutsInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutPayoutsInput, AffiliatesUncheckedCreateWithoutPayoutsInput>
  }

  export type JobsCreateWithoutPayoutsInput = {
    job_metadata: JsonNullValueInput | InputJsonValue
    status: $Enums.JobsStatusType
    type: $Enums.JobType
    job_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutJobsInput
  }

  export type JobsUncheckedCreateWithoutPayoutsInput = {
    id?: number
    store_id: number
    job_metadata: JsonNullValueInput | InputJsonValue
    status: $Enums.JobsStatusType
    type: $Enums.JobType
    job_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type JobsCreateOrConnectWithoutPayoutsInput = {
    where: JobsWhereUniqueInput
    create: XOR<JobsCreateWithoutPayoutsInput, JobsUncheckedCreateWithoutPayoutsInput>
  }

  export type StoresCreateWithoutPayoutsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutPayoutsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutPayoutsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutPayoutsInput, StoresUncheckedCreateWithoutPayoutsInput>
  }

  export type ActivityLogCreateWithoutPayoutsInput = {
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
    stores: StoresCreateNestedOneWithoutActivity_logInput
    affiliates?: AffiliatesCreateNestedOneWithoutActivity_logInput
    programs?: ProgramsCreateNestedOneWithoutActivity_logInput
    orders?: OrdersCreateNestedOneWithoutActivity_logInput
  }

  export type ActivityLogUncheckedCreateWithoutPayoutsInput = {
    id?: number
    store_id: number
    affiliate_id?: number | null
    program_id?: number | null
    order_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type ActivityLogCreateOrConnectWithoutPayoutsInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutPayoutsInput, ActivityLogUncheckedCreateWithoutPayoutsInput>
  }

  export type ActivityLogCreateManyPayoutsInputEnvelope = {
    data: ActivityLogCreateManyPayoutsInput | ActivityLogCreateManyPayoutsInput[]
    skipDuplicates?: boolean
  }

  export type AffiliatesUpsertWithoutPayoutsInput = {
    update: XOR<AffiliatesUpdateWithoutPayoutsInput, AffiliatesUncheckedUpdateWithoutPayoutsInput>
    create: XOR<AffiliatesCreateWithoutPayoutsInput, AffiliatesUncheckedCreateWithoutPayoutsInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutPayoutsInput, AffiliatesUncheckedUpdateWithoutPayoutsInput>
  }

  export type AffiliatesUpdateWithoutPayoutsInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutPayoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type JobsUpsertWithoutPayoutsInput = {
    update: XOR<JobsUpdateWithoutPayoutsInput, JobsUncheckedUpdateWithoutPayoutsInput>
    create: XOR<JobsCreateWithoutPayoutsInput, JobsUncheckedCreateWithoutPayoutsInput>
    where?: JobsWhereInput
  }

  export type JobsUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: JobsWhereInput
    data: XOR<JobsUpdateWithoutPayoutsInput, JobsUncheckedUpdateWithoutPayoutsInput>
  }

  export type JobsUpdateWithoutPayoutsInput = {
    job_metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumJobsStatusTypeFieldUpdateOperationsInput | $Enums.JobsStatusType
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    job_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutPayoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    job_metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumJobsStatusTypeFieldUpdateOperationsInput | $Enums.JobsStatusType
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    job_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StoresUpsertWithoutPayoutsInput = {
    update: XOR<StoresUpdateWithoutPayoutsInput, StoresUncheckedUpdateWithoutPayoutsInput>
    create: XOR<StoresCreateWithoutPayoutsInput, StoresUncheckedCreateWithoutPayoutsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutPayoutsInput, StoresUncheckedUpdateWithoutPayoutsInput>
  }

  export type StoresUpdateWithoutPayoutsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutPayoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutPayoutsInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutPayoutsInput, ActivityLogUncheckedUpdateWithoutPayoutsInput>
    create: XOR<ActivityLogCreateWithoutPayoutsInput, ActivityLogUncheckedCreateWithoutPayoutsInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutPayoutsInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutPayoutsInput, ActivityLogUncheckedUpdateWithoutPayoutsInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutPayoutsInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutPayoutsInput>
  }

  export type AffiliateBonusCreateWithoutBonusInput = {
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_bonusInput
    stores: StoresCreateNestedOneWithoutAffiliate_bonusInput
  }

  export type AffiliateBonusUncheckedCreateWithoutBonusInput = {
    id?: number
    store_id: number
    affiliate_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateBonusCreateOrConnectWithoutBonusInput = {
    where: AffiliateBonusWhereUniqueInput
    create: XOR<AffiliateBonusCreateWithoutBonusInput, AffiliateBonusUncheckedCreateWithoutBonusInput>
  }

  export type AffiliateBonusCreateManyBonusInputEnvelope = {
    data: AffiliateBonusCreateManyBonusInput | AffiliateBonusCreateManyBonusInput[]
    skipDuplicates?: boolean
  }

  export type StoresCreateWithoutBonusInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutBonusInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutBonusInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutBonusInput, StoresUncheckedCreateWithoutBonusInput>
  }

  export type ProgramBonusCreateWithoutBonusInput = {
    created_at: bigint | number
    updated_at: bigint | number
    programs: ProgramsCreateNestedOneWithoutProgram_bonusInput
    stores: StoresCreateNestedOneWithoutProgram_bonusInput
  }

  export type ProgramBonusUncheckedCreateWithoutBonusInput = {
    id?: number
    store_id: number
    program_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ProgramBonusCreateOrConnectWithoutBonusInput = {
    where: ProgramBonusWhereUniqueInput
    create: XOR<ProgramBonusCreateWithoutBonusInput, ProgramBonusUncheckedCreateWithoutBonusInput>
  }

  export type ProgramBonusCreateManyBonusInputEnvelope = {
    data: ProgramBonusCreateManyBonusInput | ProgramBonusCreateManyBonusInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateBonusUpsertWithWhereUniqueWithoutBonusInput = {
    where: AffiliateBonusWhereUniqueInput
    update: XOR<AffiliateBonusUpdateWithoutBonusInput, AffiliateBonusUncheckedUpdateWithoutBonusInput>
    create: XOR<AffiliateBonusCreateWithoutBonusInput, AffiliateBonusUncheckedCreateWithoutBonusInput>
  }

  export type AffiliateBonusUpdateWithWhereUniqueWithoutBonusInput = {
    where: AffiliateBonusWhereUniqueInput
    data: XOR<AffiliateBonusUpdateWithoutBonusInput, AffiliateBonusUncheckedUpdateWithoutBonusInput>
  }

  export type AffiliateBonusUpdateManyWithWhereWithoutBonusInput = {
    where: AffiliateBonusScalarWhereInput
    data: XOR<AffiliateBonusUpdateManyMutationInput, AffiliateBonusUncheckedUpdateManyWithoutBonusInput>
  }

  export type StoresUpsertWithoutBonusInput = {
    update: XOR<StoresUpdateWithoutBonusInput, StoresUncheckedUpdateWithoutBonusInput>
    create: XOR<StoresCreateWithoutBonusInput, StoresUncheckedCreateWithoutBonusInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutBonusInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutBonusInput, StoresUncheckedUpdateWithoutBonusInput>
  }

  export type StoresUpdateWithoutBonusInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutBonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type ProgramBonusUpsertWithWhereUniqueWithoutBonusInput = {
    where: ProgramBonusWhereUniqueInput
    update: XOR<ProgramBonusUpdateWithoutBonusInput, ProgramBonusUncheckedUpdateWithoutBonusInput>
    create: XOR<ProgramBonusCreateWithoutBonusInput, ProgramBonusUncheckedCreateWithoutBonusInput>
  }

  export type ProgramBonusUpdateWithWhereUniqueWithoutBonusInput = {
    where: ProgramBonusWhereUniqueInput
    data: XOR<ProgramBonusUpdateWithoutBonusInput, ProgramBonusUncheckedUpdateWithoutBonusInput>
  }

  export type ProgramBonusUpdateManyWithWhereWithoutBonusInput = {
    where: ProgramBonusScalarWhereInput
    data: XOR<ProgramBonusUpdateManyMutationInput, ProgramBonusUncheckedUpdateManyWithoutBonusInput>
  }

  export type AffiliateGiftsCreateWithoutGiftsInput = {
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutAffiliate_giftsInput
    stores: StoresCreateNestedOneWithoutAffiliate_giftsInput
  }

  export type AffiliateGiftsUncheckedCreateWithoutGiftsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateGiftsCreateOrConnectWithoutGiftsInput = {
    where: AffiliateGiftsWhereUniqueInput
    create: XOR<AffiliateGiftsCreateWithoutGiftsInput, AffiliateGiftsUncheckedCreateWithoutGiftsInput>
  }

  export type AffiliateGiftsCreateManyGiftsInputEnvelope = {
    data: AffiliateGiftsCreateManyGiftsInput | AffiliateGiftsCreateManyGiftsInput[]
    skipDuplicates?: boolean
  }

  export type StoresCreateWithoutGiftsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutGiftsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutGiftsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutGiftsInput, StoresUncheckedCreateWithoutGiftsInput>
  }

  export type AffiliateGiftsUpsertWithWhereUniqueWithoutGiftsInput = {
    where: AffiliateGiftsWhereUniqueInput
    update: XOR<AffiliateGiftsUpdateWithoutGiftsInput, AffiliateGiftsUncheckedUpdateWithoutGiftsInput>
    create: XOR<AffiliateGiftsCreateWithoutGiftsInput, AffiliateGiftsUncheckedCreateWithoutGiftsInput>
  }

  export type AffiliateGiftsUpdateWithWhereUniqueWithoutGiftsInput = {
    where: AffiliateGiftsWhereUniqueInput
    data: XOR<AffiliateGiftsUpdateWithoutGiftsInput, AffiliateGiftsUncheckedUpdateWithoutGiftsInput>
  }

  export type AffiliateGiftsUpdateManyWithWhereWithoutGiftsInput = {
    where: AffiliateGiftsScalarWhereInput
    data: XOR<AffiliateGiftsUpdateManyMutationInput, AffiliateGiftsUncheckedUpdateManyWithoutGiftsInput>
  }

  export type StoresUpsertWithoutGiftsInput = {
    update: XOR<StoresUpdateWithoutGiftsInput, StoresUncheckedUpdateWithoutGiftsInput>
    create: XOR<StoresCreateWithoutGiftsInput, StoresUncheckedCreateWithoutGiftsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutGiftsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutGiftsInput, StoresUncheckedUpdateWithoutGiftsInput>
  }

  export type StoresUpdateWithoutGiftsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutGiftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type AffiliatesCreateWithoutTransactionsInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutTransactionsInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutTransactionsInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutTransactionsInput, AffiliatesUncheckedCreateWithoutTransactionsInput>
  }

  export type StoresCreateWithoutTransactionsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutTransactionsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutTransactionsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutTransactionsInput, StoresUncheckedCreateWithoutTransactionsInput>
  }

  export type AffiliatesUpsertWithoutTransactionsInput = {
    update: XOR<AffiliatesUpdateWithoutTransactionsInput, AffiliatesUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AffiliatesCreateWithoutTransactionsInput, AffiliatesUncheckedCreateWithoutTransactionsInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutTransactionsInput, AffiliatesUncheckedUpdateWithoutTransactionsInput>
  }

  export type AffiliatesUpdateWithoutTransactionsInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type StoresUpsertWithoutTransactionsInput = {
    update: XOR<StoresUpdateWithoutTransactionsInput, StoresUncheckedUpdateWithoutTransactionsInput>
    create: XOR<StoresCreateWithoutTransactionsInput, StoresUncheckedCreateWithoutTransactionsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutTransactionsInput, StoresUncheckedUpdateWithoutTransactionsInput>
  }

  export type StoresUpdateWithoutTransactionsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutTransactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type StoresCreateWithoutSettingsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutSettingsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutSettingsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutSettingsInput, StoresUncheckedCreateWithoutSettingsInput>
  }

  export type StoresUpsertWithoutSettingsInput = {
    update: XOR<StoresUpdateWithoutSettingsInput, StoresUncheckedUpdateWithoutSettingsInput>
    create: XOR<StoresCreateWithoutSettingsInput, StoresUncheckedCreateWithoutSettingsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutSettingsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutSettingsInput, StoresUncheckedUpdateWithoutSettingsInput>
  }

  export type StoresUpdateWithoutSettingsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutSettingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type StoresCreateWithoutJobsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutJobsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutJobsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutJobsInput, StoresUncheckedCreateWithoutJobsInput>
  }

  export type PayoutsCreateWithoutJobsInput = {
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    affiliates: AffiliatesCreateNestedOneWithoutPayoutsInput
    stores: StoresCreateNestedOneWithoutPayoutsInput
    activity_log?: ActivityLogCreateNestedManyWithoutPayoutsInput
  }

  export type PayoutsUncheckedCreateWithoutJobsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutPayoutsInput
  }

  export type PayoutsCreateOrConnectWithoutJobsInput = {
    where: PayoutsWhereUniqueInput
    create: XOR<PayoutsCreateWithoutJobsInput, PayoutsUncheckedCreateWithoutJobsInput>
  }

  export type StoresUpsertWithoutJobsInput = {
    update: XOR<StoresUpdateWithoutJobsInput, StoresUncheckedUpdateWithoutJobsInput>
    create: XOR<StoresCreateWithoutJobsInput, StoresUncheckedCreateWithoutJobsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutJobsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutJobsInput, StoresUncheckedUpdateWithoutJobsInput>
  }

  export type StoresUpdateWithoutJobsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type PayoutsUpsertWithoutJobsInput = {
    update: XOR<PayoutsUpdateWithoutJobsInput, PayoutsUncheckedUpdateWithoutJobsInput>
    create: XOR<PayoutsCreateWithoutJobsInput, PayoutsUncheckedCreateWithoutJobsInput>
    where?: PayoutsWhereInput
  }

  export type PayoutsUpdateToOneWithWhereWithoutJobsInput = {
    where?: PayoutsWhereInput
    data: XOR<PayoutsUpdateWithoutJobsInput, PayoutsUncheckedUpdateWithoutJobsInput>
  }

  export type PayoutsUpdateWithoutJobsInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    affiliates?: AffiliatesUpdateOneRequiredWithoutPayoutsNestedInput
    stores?: StoresUpdateOneRequiredWithoutPayoutsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutPayoutsNestedInput
  }

  export type PayoutsUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutPayoutsNestedInput
  }

  export type AffiliatesCreateWithoutCustomersInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutCustomersInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutCustomersInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutCustomersInput, AffiliatesUncheckedCreateWithoutCustomersInput>
  }

  export type StoresCreateWithoutCustomersInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutCustomersInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutCustomersInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutCustomersInput, StoresUncheckedCreateWithoutCustomersInput>
  }

  export type OrderItemsCreateWithoutCustomersInput = {
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    affiliates: AffiliatesCreateNestedOneWithoutOrder_itemsInput
    orders: OrdersCreateNestedOneWithoutOrder_itemsInput
    stores: StoresCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemsUncheckedCreateWithoutCustomersInput = {
    id?: number
    store_id: number
    affiliate_id: number
    order_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrderItemsCreateOrConnectWithoutCustomersInput = {
    where: OrderItemsWhereUniqueInput
    create: XOR<OrderItemsCreateWithoutCustomersInput, OrderItemsUncheckedCreateWithoutCustomersInput>
  }

  export type OrderItemsCreateManyCustomersInputEnvelope = {
    data: OrderItemsCreateManyCustomersInput | OrderItemsCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutCustomersInput = {
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    commissions?: CommissionsCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsCreateNestedManyWithoutOrdersInput
    affiliates: AffiliatesCreateNestedOneWithoutOrdersInput
    programs?: ProgramsCreateNestedOneWithoutOrdersInput
    stores: StoresCreateNestedOneWithoutOrdersInput
    activity_log?: ActivityLogCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutCustomersInput = {
    id?: number
    store_id: number
    affiliate_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
    commissions?: CommissionsUncheckedCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutOrdersInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutCustomersInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutCustomersInput, OrdersUncheckedCreateWithoutCustomersInput>
  }

  export type OrdersCreateManyCustomersInputEnvelope = {
    data: OrdersCreateManyCustomersInput | OrdersCreateManyCustomersInput[]
    skipDuplicates?: boolean
  }

  export type AffiliatesUpsertWithoutCustomersInput = {
    update: XOR<AffiliatesUpdateWithoutCustomersInput, AffiliatesUncheckedUpdateWithoutCustomersInput>
    create: XOR<AffiliatesCreateWithoutCustomersInput, AffiliatesUncheckedCreateWithoutCustomersInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutCustomersInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutCustomersInput, AffiliatesUncheckedUpdateWithoutCustomersInput>
  }

  export type AffiliatesUpdateWithoutCustomersInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type StoresUpsertWithoutCustomersInput = {
    update: XOR<StoresUpdateWithoutCustomersInput, StoresUncheckedUpdateWithoutCustomersInput>
    create: XOR<StoresCreateWithoutCustomersInput, StoresUncheckedCreateWithoutCustomersInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutCustomersInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutCustomersInput, StoresUncheckedUpdateWithoutCustomersInput>
  }

  export type StoresUpdateWithoutCustomersInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type OrderItemsUpsertWithWhereUniqueWithoutCustomersInput = {
    where: OrderItemsWhereUniqueInput
    update: XOR<OrderItemsUpdateWithoutCustomersInput, OrderItemsUncheckedUpdateWithoutCustomersInput>
    create: XOR<OrderItemsCreateWithoutCustomersInput, OrderItemsUncheckedCreateWithoutCustomersInput>
  }

  export type OrderItemsUpdateWithWhereUniqueWithoutCustomersInput = {
    where: OrderItemsWhereUniqueInput
    data: XOR<OrderItemsUpdateWithoutCustomersInput, OrderItemsUncheckedUpdateWithoutCustomersInput>
  }

  export type OrderItemsUpdateManyWithWhereWithoutCustomersInput = {
    where: OrderItemsScalarWhereInput
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyWithoutCustomersInput>
  }

  export type OrdersUpsertWithWhereUniqueWithoutCustomersInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutCustomersInput, OrdersUncheckedUpdateWithoutCustomersInput>
    create: XOR<OrdersCreateWithoutCustomersInput, OrdersUncheckedCreateWithoutCustomersInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutCustomersInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutCustomersInput, OrdersUncheckedUpdateWithoutCustomersInput>
  }

  export type OrdersUpdateManyWithWhereWithoutCustomersInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutCustomersInput>
  }

  export type AffiliateBonusCreateWithoutAffiliatesInput = {
    created_at: bigint | number
    updated_at: bigint | number
    bonus: BonusCreateNestedOneWithoutAffiliate_bonusInput
    stores: StoresCreateNestedOneWithoutAffiliate_bonusInput
  }

  export type AffiliateBonusUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateBonusCreateOrConnectWithoutAffiliatesInput = {
    where: AffiliateBonusWhereUniqueInput
    create: XOR<AffiliateBonusCreateWithoutAffiliatesInput, AffiliateBonusUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateBonusCreateManyAffiliatesInputEnvelope = {
    data: AffiliateBonusCreateManyAffiliatesInput | AffiliateBonusCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateDiscountsCreateWithoutAffiliatesInput = {
    discount_id: bigint | number
    discount_code: string
    is_deleted?: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutAffiliate_discountsInput
  }

  export type AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    discount_id: bigint | number
    discount_code: string
    is_deleted?: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateDiscountsCreateOrConnectWithoutAffiliatesInput = {
    where: AffiliateDiscountsWhereUniqueInput
    create: XOR<AffiliateDiscountsCreateWithoutAffiliatesInput, AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateDiscountsCreateManyAffiliatesInputEnvelope = {
    data: AffiliateDiscountsCreateManyAffiliatesInput | AffiliateDiscountsCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateGiftsCreateWithoutAffiliatesInput = {
    created_at: bigint | number
    updated_at: bigint | number
    gifts: GiftsCreateNestedOneWithoutAffiliate_giftsInput
    stores: StoresCreateNestedOneWithoutAffiliate_giftsInput
  }

  export type AffiliateGiftsUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    gift_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateGiftsCreateOrConnectWithoutAffiliatesInput = {
    where: AffiliateGiftsWhereUniqueInput
    create: XOR<AffiliateGiftsCreateWithoutAffiliatesInput, AffiliateGiftsUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateGiftsCreateManyAffiliatesInputEnvelope = {
    data: AffiliateGiftsCreateManyAffiliatesInput | AffiliateGiftsCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateProgramHistoryCreateWithoutAffiliatesInput = {
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutAffiliate_program_historyInput
  }

  export type AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramHistoryCreateOrConnectWithoutAffiliatesInput = {
    where: AffiliateProgramHistoryWhereUniqueInput
    create: XOR<AffiliateProgramHistoryCreateWithoutAffiliatesInput, AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateProgramHistoryCreateManyAffiliatesInputEnvelope = {
    data: AffiliateProgramHistoryCreateManyAffiliatesInput | AffiliateProgramHistoryCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateProgramsCreateWithoutAffiliatesInput = {
    created_at: bigint | number
    updated_at: bigint | number
    programs: ProgramsCreateNestedOneWithoutAffiliate_programsInput
    stores: StoresCreateNestedOneWithoutAffiliate_programsInput
  }

  export type AffiliateProgramsUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    program_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramsCreateOrConnectWithoutAffiliatesInput = {
    where: AffiliateProgramsWhereUniqueInput
    create: XOR<AffiliateProgramsCreateWithoutAffiliatesInput, AffiliateProgramsUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateProgramsCreateManyAffiliatesInputEnvelope = {
    data: AffiliateProgramsCreateManyAffiliatesInput | AffiliateProgramsCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type MembersCreateWithoutAffiliatesInput = {
    member_id?: string
    first_name: string
    last_name: string
    email: string
    phone?: string | null
    member_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type MembersUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    member_id?: string
    first_name: string
    last_name: string
    email: string
    phone?: string | null
    member_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type MembersCreateOrConnectWithoutAffiliatesInput = {
    where: MembersWhereUniqueInput
    create: XOR<MembersCreateWithoutAffiliatesInput, MembersUncheckedCreateWithoutAffiliatesInput>
  }

  export type StoresCreateWithoutAffiliatesInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutAffiliatesInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutAffiliatesInput, StoresUncheckedCreateWithoutAffiliatesInput>
  }

  export type CommissionsCreateWithoutAffiliatesInput = {
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
    orders: OrdersCreateNestedOneWithoutCommissionsInput
    stores: StoresCreateNestedOneWithoutCommissionsInput
  }

  export type CommissionsUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    order_id: number
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CommissionsCreateOrConnectWithoutAffiliatesInput = {
    where: CommissionsWhereUniqueInput
    create: XOR<CommissionsCreateWithoutAffiliatesInput, CommissionsUncheckedCreateWithoutAffiliatesInput>
  }

  export type CommissionsCreateManyAffiliatesInputEnvelope = {
    data: CommissionsCreateManyAffiliatesInput | CommissionsCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type CustomersCreateWithoutAffiliatesInput = {
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutCustomersInput
    order_items?: OrderItemsCreateNestedManyWithoutCustomersInput
    orders?: OrdersCreateNestedManyWithoutCustomersInput
  }

  export type CustomersUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutCustomersInput
    orders?: OrdersUncheckedCreateNestedManyWithoutCustomersInput
  }

  export type CustomersCreateOrConnectWithoutAffiliatesInput = {
    where: CustomersWhereUniqueInput
    create: XOR<CustomersCreateWithoutAffiliatesInput, CustomersUncheckedCreateWithoutAffiliatesInput>
  }

  export type CustomersCreateManyAffiliatesInputEnvelope = {
    data: CustomersCreateManyAffiliatesInput | CustomersCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type OrderItemsCreateWithoutAffiliatesInput = {
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    customers: CustomersCreateNestedOneWithoutOrder_itemsInput
    orders: OrdersCreateNestedOneWithoutOrder_itemsInput
    stores: StoresCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemsUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    customer_id: number
    order_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrderItemsCreateOrConnectWithoutAffiliatesInput = {
    where: OrderItemsWhereUniqueInput
    create: XOR<OrderItemsCreateWithoutAffiliatesInput, OrderItemsUncheckedCreateWithoutAffiliatesInput>
  }

  export type OrderItemsCreateManyAffiliatesInputEnvelope = {
    data: OrderItemsCreateManyAffiliatesInput | OrderItemsCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type OrdersCreateWithoutAffiliatesInput = {
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    commissions?: CommissionsCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsCreateNestedManyWithoutOrdersInput
    customers: CustomersCreateNestedOneWithoutOrdersInput
    programs?: ProgramsCreateNestedOneWithoutOrdersInput
    stores: StoresCreateNestedOneWithoutOrdersInput
    activity_log?: ActivityLogCreateNestedManyWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
    commissions?: CommissionsUncheckedCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutOrdersInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutAffiliatesInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutAffiliatesInput, OrdersUncheckedCreateWithoutAffiliatesInput>
  }

  export type OrdersCreateManyAffiliatesInputEnvelope = {
    data: OrdersCreateManyAffiliatesInput | OrdersCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type PayoutsCreateWithoutAffiliatesInput = {
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    jobs: JobsCreateNestedOneWithoutPayoutsInput
    stores: StoresCreateNestedOneWithoutPayoutsInput
    activity_log?: ActivityLogCreateNestedManyWithoutPayoutsInput
  }

  export type PayoutsUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    job_id: number
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutPayoutsInput
  }

  export type PayoutsCreateOrConnectWithoutAffiliatesInput = {
    where: PayoutsWhereUniqueInput
    create: XOR<PayoutsCreateWithoutAffiliatesInput, PayoutsUncheckedCreateWithoutAffiliatesInput>
  }

  export type PayoutsCreateManyAffiliatesInputEnvelope = {
    data: PayoutsCreateManyAffiliatesInput | PayoutsCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type TransactionsCreateWithoutAffiliatesInput = {
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted?: boolean
    amount: number
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionsUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted?: boolean
    amount: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TransactionsCreateOrConnectWithoutAffiliatesInput = {
    where: TransactionsWhereUniqueInput
    create: XOR<TransactionsCreateWithoutAffiliatesInput, TransactionsUncheckedCreateWithoutAffiliatesInput>
  }

  export type TransactionsCreateManyAffiliatesInputEnvelope = {
    data: TransactionsCreateManyAffiliatesInput | TransactionsCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutAffiliatesInput = {
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
    stores: StoresCreateNestedOneWithoutActivity_logInput
    programs?: ProgramsCreateNestedOneWithoutActivity_logInput
    orders?: OrdersCreateNestedOneWithoutActivity_logInput
    payouts?: PayoutsCreateNestedOneWithoutActivity_logInput
  }

  export type ActivityLogUncheckedCreateWithoutAffiliatesInput = {
    id?: number
    store_id: number
    program_id?: number | null
    order_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type ActivityLogCreateOrConnectWithoutAffiliatesInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutAffiliatesInput, ActivityLogUncheckedCreateWithoutAffiliatesInput>
  }

  export type ActivityLogCreateManyAffiliatesInputEnvelope = {
    data: ActivityLogCreateManyAffiliatesInput | ActivityLogCreateManyAffiliatesInput[]
    skipDuplicates?: boolean
  }

  export type AffiliateBonusUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateBonusWhereUniqueInput
    update: XOR<AffiliateBonusUpdateWithoutAffiliatesInput, AffiliateBonusUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<AffiliateBonusCreateWithoutAffiliatesInput, AffiliateBonusUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateBonusUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateBonusWhereUniqueInput
    data: XOR<AffiliateBonusUpdateWithoutAffiliatesInput, AffiliateBonusUncheckedUpdateWithoutAffiliatesInput>
  }

  export type AffiliateBonusUpdateManyWithWhereWithoutAffiliatesInput = {
    where: AffiliateBonusScalarWhereInput
    data: XOR<AffiliateBonusUpdateManyMutationInput, AffiliateBonusUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type AffiliateDiscountsUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateDiscountsWhereUniqueInput
    update: XOR<AffiliateDiscountsUpdateWithoutAffiliatesInput, AffiliateDiscountsUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<AffiliateDiscountsCreateWithoutAffiliatesInput, AffiliateDiscountsUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateDiscountsUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateDiscountsWhereUniqueInput
    data: XOR<AffiliateDiscountsUpdateWithoutAffiliatesInput, AffiliateDiscountsUncheckedUpdateWithoutAffiliatesInput>
  }

  export type AffiliateDiscountsUpdateManyWithWhereWithoutAffiliatesInput = {
    where: AffiliateDiscountsScalarWhereInput
    data: XOR<AffiliateDiscountsUpdateManyMutationInput, AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type AffiliateGiftsUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateGiftsWhereUniqueInput
    update: XOR<AffiliateGiftsUpdateWithoutAffiliatesInput, AffiliateGiftsUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<AffiliateGiftsCreateWithoutAffiliatesInput, AffiliateGiftsUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateGiftsUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateGiftsWhereUniqueInput
    data: XOR<AffiliateGiftsUpdateWithoutAffiliatesInput, AffiliateGiftsUncheckedUpdateWithoutAffiliatesInput>
  }

  export type AffiliateGiftsUpdateManyWithWhereWithoutAffiliatesInput = {
    where: AffiliateGiftsScalarWhereInput
    data: XOR<AffiliateGiftsUpdateManyMutationInput, AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type AffiliateProgramHistoryUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateProgramHistoryWhereUniqueInput
    update: XOR<AffiliateProgramHistoryUpdateWithoutAffiliatesInput, AffiliateProgramHistoryUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<AffiliateProgramHistoryCreateWithoutAffiliatesInput, AffiliateProgramHistoryUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateProgramHistoryUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateProgramHistoryWhereUniqueInput
    data: XOR<AffiliateProgramHistoryUpdateWithoutAffiliatesInput, AffiliateProgramHistoryUncheckedUpdateWithoutAffiliatesInput>
  }

  export type AffiliateProgramHistoryUpdateManyWithWhereWithoutAffiliatesInput = {
    where: AffiliateProgramHistoryScalarWhereInput
    data: XOR<AffiliateProgramHistoryUpdateManyMutationInput, AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type AffiliateProgramsUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateProgramsWhereUniqueInput
    update: XOR<AffiliateProgramsUpdateWithoutAffiliatesInput, AffiliateProgramsUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<AffiliateProgramsCreateWithoutAffiliatesInput, AffiliateProgramsUncheckedCreateWithoutAffiliatesInput>
  }

  export type AffiliateProgramsUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: AffiliateProgramsWhereUniqueInput
    data: XOR<AffiliateProgramsUpdateWithoutAffiliatesInput, AffiliateProgramsUncheckedUpdateWithoutAffiliatesInput>
  }

  export type AffiliateProgramsUpdateManyWithWhereWithoutAffiliatesInput = {
    where: AffiliateProgramsScalarWhereInput
    data: XOR<AffiliateProgramsUpdateManyMutationInput, AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type MembersUpsertWithoutAffiliatesInput = {
    update: XOR<MembersUpdateWithoutAffiliatesInput, MembersUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<MembersCreateWithoutAffiliatesInput, MembersUncheckedCreateWithoutAffiliatesInput>
    where?: MembersWhereInput
  }

  export type MembersUpdateToOneWithWhereWithoutAffiliatesInput = {
    where?: MembersWhereInput
    data: XOR<MembersUpdateWithoutAffiliatesInput, MembersUncheckedUpdateWithoutAffiliatesInput>
  }

  export type MembersUpdateWithoutAffiliatesInput = {
    member_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    member_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MembersUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    member_id?: StringFieldUpdateOperationsInput | string
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    member_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StoresUpsertWithoutAffiliatesInput = {
    update: XOR<StoresUpdateWithoutAffiliatesInput, StoresUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<StoresCreateWithoutAffiliatesInput, StoresUncheckedCreateWithoutAffiliatesInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutAffiliatesInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutAffiliatesInput, StoresUncheckedUpdateWithoutAffiliatesInput>
  }

  export type StoresUpdateWithoutAffiliatesInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type CommissionsUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: CommissionsWhereUniqueInput
    update: XOR<CommissionsUpdateWithoutAffiliatesInput, CommissionsUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<CommissionsCreateWithoutAffiliatesInput, CommissionsUncheckedCreateWithoutAffiliatesInput>
  }

  export type CommissionsUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: CommissionsWhereUniqueInput
    data: XOR<CommissionsUpdateWithoutAffiliatesInput, CommissionsUncheckedUpdateWithoutAffiliatesInput>
  }

  export type CommissionsUpdateManyWithWhereWithoutAffiliatesInput = {
    where: CommissionsScalarWhereInput
    data: XOR<CommissionsUpdateManyMutationInput, CommissionsUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type CustomersUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: CustomersWhereUniqueInput
    update: XOR<CustomersUpdateWithoutAffiliatesInput, CustomersUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<CustomersCreateWithoutAffiliatesInput, CustomersUncheckedCreateWithoutAffiliatesInput>
  }

  export type CustomersUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: CustomersWhereUniqueInput
    data: XOR<CustomersUpdateWithoutAffiliatesInput, CustomersUncheckedUpdateWithoutAffiliatesInput>
  }

  export type CustomersUpdateManyWithWhereWithoutAffiliatesInput = {
    where: CustomersScalarWhereInput
    data: XOR<CustomersUpdateManyMutationInput, CustomersUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type OrderItemsUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: OrderItemsWhereUniqueInput
    update: XOR<OrderItemsUpdateWithoutAffiliatesInput, OrderItemsUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<OrderItemsCreateWithoutAffiliatesInput, OrderItemsUncheckedCreateWithoutAffiliatesInput>
  }

  export type OrderItemsUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: OrderItemsWhereUniqueInput
    data: XOR<OrderItemsUpdateWithoutAffiliatesInput, OrderItemsUncheckedUpdateWithoutAffiliatesInput>
  }

  export type OrderItemsUpdateManyWithWhereWithoutAffiliatesInput = {
    where: OrderItemsScalarWhereInput
    data: XOR<OrderItemsUpdateManyMutationInput, OrderItemsUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type OrdersUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: OrdersWhereUniqueInput
    update: XOR<OrdersUpdateWithoutAffiliatesInput, OrdersUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<OrdersCreateWithoutAffiliatesInput, OrdersUncheckedCreateWithoutAffiliatesInput>
  }

  export type OrdersUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: OrdersWhereUniqueInput
    data: XOR<OrdersUpdateWithoutAffiliatesInput, OrdersUncheckedUpdateWithoutAffiliatesInput>
  }

  export type OrdersUpdateManyWithWhereWithoutAffiliatesInput = {
    where: OrdersScalarWhereInput
    data: XOR<OrdersUpdateManyMutationInput, OrdersUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type PayoutsUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: PayoutsWhereUniqueInput
    update: XOR<PayoutsUpdateWithoutAffiliatesInput, PayoutsUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<PayoutsCreateWithoutAffiliatesInput, PayoutsUncheckedCreateWithoutAffiliatesInput>
  }

  export type PayoutsUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: PayoutsWhereUniqueInput
    data: XOR<PayoutsUpdateWithoutAffiliatesInput, PayoutsUncheckedUpdateWithoutAffiliatesInput>
  }

  export type PayoutsUpdateManyWithWhereWithoutAffiliatesInput = {
    where: PayoutsScalarWhereInput
    data: XOR<PayoutsUpdateManyMutationInput, PayoutsUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type TransactionsUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: TransactionsWhereUniqueInput
    update: XOR<TransactionsUpdateWithoutAffiliatesInput, TransactionsUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<TransactionsCreateWithoutAffiliatesInput, TransactionsUncheckedCreateWithoutAffiliatesInput>
  }

  export type TransactionsUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: TransactionsWhereUniqueInput
    data: XOR<TransactionsUpdateWithoutAffiliatesInput, TransactionsUncheckedUpdateWithoutAffiliatesInput>
  }

  export type TransactionsUpdateManyWithWhereWithoutAffiliatesInput = {
    where: TransactionsScalarWhereInput
    data: XOR<TransactionsUpdateManyMutationInput, TransactionsUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutAffiliatesInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutAffiliatesInput, ActivityLogUncheckedUpdateWithoutAffiliatesInput>
    create: XOR<ActivityLogCreateWithoutAffiliatesInput, ActivityLogUncheckedCreateWithoutAffiliatesInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutAffiliatesInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutAffiliatesInput, ActivityLogUncheckedUpdateWithoutAffiliatesInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutAffiliatesInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutAffiliatesInput>
  }

  export type AffiliatesCreateWithoutAffiliate_programsInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutAffiliate_programsInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutAffiliate_programsInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutAffiliate_programsInput, AffiliatesUncheckedCreateWithoutAffiliate_programsInput>
  }

  export type ProgramsCreateWithoutAffiliate_programsInput = {
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    customer_discounts?: CustomerDiscountsCreateNestedOneWithoutProgramsInput
    Orders?: OrdersCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutProgramsInput
    stores: StoresCreateNestedOneWithoutProgramsInput
    tiers?: TiersCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsUncheckedCreateWithoutAffiliate_programsInput = {
    id?: number
    store_id: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedOneWithoutProgramsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutProgramsInput
    tiers?: TiersUncheckedCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsCreateOrConnectWithoutAffiliate_programsInput = {
    where: ProgramsWhereUniqueInput
    create: XOR<ProgramsCreateWithoutAffiliate_programsInput, ProgramsUncheckedCreateWithoutAffiliate_programsInput>
  }

  export type StoresCreateWithoutAffiliate_programsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutAffiliate_programsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutAffiliate_programsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutAffiliate_programsInput, StoresUncheckedCreateWithoutAffiliate_programsInput>
  }

  export type AffiliatesUpsertWithoutAffiliate_programsInput = {
    update: XOR<AffiliatesUpdateWithoutAffiliate_programsInput, AffiliatesUncheckedUpdateWithoutAffiliate_programsInput>
    create: XOR<AffiliatesCreateWithoutAffiliate_programsInput, AffiliatesUncheckedCreateWithoutAffiliate_programsInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutAffiliate_programsInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutAffiliate_programsInput, AffiliatesUncheckedUpdateWithoutAffiliate_programsInput>
  }

  export type AffiliatesUpdateWithoutAffiliate_programsInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutAffiliate_programsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type ProgramsUpsertWithoutAffiliate_programsInput = {
    update: XOR<ProgramsUpdateWithoutAffiliate_programsInput, ProgramsUncheckedUpdateWithoutAffiliate_programsInput>
    create: XOR<ProgramsCreateWithoutAffiliate_programsInput, ProgramsUncheckedCreateWithoutAffiliate_programsInput>
    where?: ProgramsWhereInput
  }

  export type ProgramsUpdateToOneWithWhereWithoutAffiliate_programsInput = {
    where?: ProgramsWhereInput
    data: XOR<ProgramsUpdateWithoutAffiliate_programsInput, ProgramsUncheckedUpdateWithoutAffiliate_programsInput>
  }

  export type ProgramsUpdateWithoutAffiliate_programsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_discounts?: CustomerDiscountsUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutProgramsNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgramsNestedInput
    tiers?: TiersUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsUncheckedUpdateWithoutAffiliate_programsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    customer_discounts?: CustomerDiscountsUncheckedUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutProgramsNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutProgramsNestedInput
  }

  export type StoresUpsertWithoutAffiliate_programsInput = {
    update: XOR<StoresUpdateWithoutAffiliate_programsInput, StoresUncheckedUpdateWithoutAffiliate_programsInput>
    create: XOR<StoresCreateWithoutAffiliate_programsInput, StoresUncheckedCreateWithoutAffiliate_programsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutAffiliate_programsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutAffiliate_programsInput, StoresUncheckedUpdateWithoutAffiliate_programsInput>
  }

  export type StoresUpdateWithoutAffiliate_programsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutAffiliate_programsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type AffiliatesCreateWithoutAffiliate_program_historyInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutAffiliate_program_historyInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutAffiliate_program_historyInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutAffiliate_program_historyInput, AffiliatesUncheckedCreateWithoutAffiliate_program_historyInput>
  }

  export type StoresCreateWithoutAffiliate_program_historyInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutAffiliate_program_historyInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutAffiliate_program_historyInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutAffiliate_program_historyInput, StoresUncheckedCreateWithoutAffiliate_program_historyInput>
  }

  export type AffiliatesUpsertWithoutAffiliate_program_historyInput = {
    update: XOR<AffiliatesUpdateWithoutAffiliate_program_historyInput, AffiliatesUncheckedUpdateWithoutAffiliate_program_historyInput>
    create: XOR<AffiliatesCreateWithoutAffiliate_program_historyInput, AffiliatesUncheckedCreateWithoutAffiliate_program_historyInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutAffiliate_program_historyInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutAffiliate_program_historyInput, AffiliatesUncheckedUpdateWithoutAffiliate_program_historyInput>
  }

  export type AffiliatesUpdateWithoutAffiliate_program_historyInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutAffiliate_program_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type StoresUpsertWithoutAffiliate_program_historyInput = {
    update: XOR<StoresUpdateWithoutAffiliate_program_historyInput, StoresUncheckedUpdateWithoutAffiliate_program_historyInput>
    create: XOR<StoresCreateWithoutAffiliate_program_historyInput, StoresUncheckedCreateWithoutAffiliate_program_historyInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutAffiliate_program_historyInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutAffiliate_program_historyInput, StoresUncheckedUpdateWithoutAffiliate_program_historyInput>
  }

  export type StoresUpdateWithoutAffiliate_program_historyInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutAffiliate_program_historyInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type AffiliatesCreateWithoutAffiliate_discountsInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutAffiliate_discountsInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutAffiliate_discountsInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutAffiliate_discountsInput, AffiliatesUncheckedCreateWithoutAffiliate_discountsInput>
  }

  export type StoresCreateWithoutAffiliate_discountsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutAffiliate_discountsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutAffiliate_discountsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutAffiliate_discountsInput, StoresUncheckedCreateWithoutAffiliate_discountsInput>
  }

  export type AffiliatesUpsertWithoutAffiliate_discountsInput = {
    update: XOR<AffiliatesUpdateWithoutAffiliate_discountsInput, AffiliatesUncheckedUpdateWithoutAffiliate_discountsInput>
    create: XOR<AffiliatesCreateWithoutAffiliate_discountsInput, AffiliatesUncheckedCreateWithoutAffiliate_discountsInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutAffiliate_discountsInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutAffiliate_discountsInput, AffiliatesUncheckedUpdateWithoutAffiliate_discountsInput>
  }

  export type AffiliatesUpdateWithoutAffiliate_discountsInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutAffiliate_discountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type StoresUpsertWithoutAffiliate_discountsInput = {
    update: XOR<StoresUpdateWithoutAffiliate_discountsInput, StoresUncheckedUpdateWithoutAffiliate_discountsInput>
    create: XOR<StoresCreateWithoutAffiliate_discountsInput, StoresUncheckedCreateWithoutAffiliate_discountsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutAffiliate_discountsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutAffiliate_discountsInput, StoresUncheckedUpdateWithoutAffiliate_discountsInput>
  }

  export type StoresUpdateWithoutAffiliate_discountsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutAffiliate_discountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type AffiliatesCreateWithoutAffiliate_giftsInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutAffiliate_giftsInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutAffiliate_giftsInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutAffiliate_giftsInput, AffiliatesUncheckedCreateWithoutAffiliate_giftsInput>
  }

  export type GiftsCreateWithoutAffiliate_giftsInput = {
    title: string
    description: string
    products: JsonNullValueInput | InputJsonValue
    gift_type: $Enums.GiftType
    status: $Enums.StatusType
    shipping_method: $Enums.ShippingType
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutGiftsInput
  }

  export type GiftsUncheckedCreateWithoutAffiliate_giftsInput = {
    id?: number
    store_id: number
    title: string
    description: string
    products: JsonNullValueInput | InputJsonValue
    gift_type: $Enums.GiftType
    status: $Enums.StatusType
    shipping_method: $Enums.ShippingType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type GiftsCreateOrConnectWithoutAffiliate_giftsInput = {
    where: GiftsWhereUniqueInput
    create: XOR<GiftsCreateWithoutAffiliate_giftsInput, GiftsUncheckedCreateWithoutAffiliate_giftsInput>
  }

  export type StoresCreateWithoutAffiliate_giftsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutAffiliate_giftsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutAffiliate_giftsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutAffiliate_giftsInput, StoresUncheckedCreateWithoutAffiliate_giftsInput>
  }

  export type AffiliatesUpsertWithoutAffiliate_giftsInput = {
    update: XOR<AffiliatesUpdateWithoutAffiliate_giftsInput, AffiliatesUncheckedUpdateWithoutAffiliate_giftsInput>
    create: XOR<AffiliatesCreateWithoutAffiliate_giftsInput, AffiliatesUncheckedCreateWithoutAffiliate_giftsInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutAffiliate_giftsInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutAffiliate_giftsInput, AffiliatesUncheckedUpdateWithoutAffiliate_giftsInput>
  }

  export type AffiliatesUpdateWithoutAffiliate_giftsInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutAffiliate_giftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type GiftsUpsertWithoutAffiliate_giftsInput = {
    update: XOR<GiftsUpdateWithoutAffiliate_giftsInput, GiftsUncheckedUpdateWithoutAffiliate_giftsInput>
    create: XOR<GiftsCreateWithoutAffiliate_giftsInput, GiftsUncheckedCreateWithoutAffiliate_giftsInput>
    where?: GiftsWhereInput
  }

  export type GiftsUpdateToOneWithWhereWithoutAffiliate_giftsInput = {
    where?: GiftsWhereInput
    data: XOR<GiftsUpdateWithoutAffiliate_giftsInput, GiftsUncheckedUpdateWithoutAffiliate_giftsInput>
  }

  export type GiftsUpdateWithoutAffiliate_giftsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    products?: JsonNullValueInput | InputJsonValue
    gift_type?: EnumGiftTypeFieldUpdateOperationsInput | $Enums.GiftType
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    shipping_method?: EnumShippingTypeFieldUpdateOperationsInput | $Enums.ShippingType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutGiftsNestedInput
  }

  export type GiftsUncheckedUpdateWithoutAffiliate_giftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    products?: JsonNullValueInput | InputJsonValue
    gift_type?: EnumGiftTypeFieldUpdateOperationsInput | $Enums.GiftType
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    shipping_method?: EnumShippingTypeFieldUpdateOperationsInput | $Enums.ShippingType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type StoresUpsertWithoutAffiliate_giftsInput = {
    update: XOR<StoresUpdateWithoutAffiliate_giftsInput, StoresUncheckedUpdateWithoutAffiliate_giftsInput>
    create: XOR<StoresCreateWithoutAffiliate_giftsInput, StoresUncheckedCreateWithoutAffiliate_giftsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutAffiliate_giftsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutAffiliate_giftsInput, StoresUncheckedUpdateWithoutAffiliate_giftsInput>
  }

  export type StoresUpdateWithoutAffiliate_giftsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutAffiliate_giftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type AffiliatesCreateWithoutAffiliate_bonusInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutAffiliate_bonusInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutAffiliate_bonusInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutAffiliate_bonusInput, AffiliatesUncheckedCreateWithoutAffiliate_bonusInput>
  }

  export type BonusCreateWithoutAffiliate_bonusInput = {
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
    stores: StoresCreateNestedOneWithoutBonusInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutBonusInput
  }

  export type BonusUncheckedCreateWithoutAffiliate_bonusInput = {
    id?: number
    store_id: number
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutBonusInput
  }

  export type BonusCreateOrConnectWithoutAffiliate_bonusInput = {
    where: BonusWhereUniqueInput
    create: XOR<BonusCreateWithoutAffiliate_bonusInput, BonusUncheckedCreateWithoutAffiliate_bonusInput>
  }

  export type StoresCreateWithoutAffiliate_bonusInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutAffiliate_bonusInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutAffiliate_bonusInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutAffiliate_bonusInput, StoresUncheckedCreateWithoutAffiliate_bonusInput>
  }

  export type AffiliatesUpsertWithoutAffiliate_bonusInput = {
    update: XOR<AffiliatesUpdateWithoutAffiliate_bonusInput, AffiliatesUncheckedUpdateWithoutAffiliate_bonusInput>
    create: XOR<AffiliatesCreateWithoutAffiliate_bonusInput, AffiliatesUncheckedCreateWithoutAffiliate_bonusInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutAffiliate_bonusInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutAffiliate_bonusInput, AffiliatesUncheckedUpdateWithoutAffiliate_bonusInput>
  }

  export type AffiliatesUpdateWithoutAffiliate_bonusInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutAffiliate_bonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type BonusUpsertWithoutAffiliate_bonusInput = {
    update: XOR<BonusUpdateWithoutAffiliate_bonusInput, BonusUncheckedUpdateWithoutAffiliate_bonusInput>
    create: XOR<BonusCreateWithoutAffiliate_bonusInput, BonusUncheckedCreateWithoutAffiliate_bonusInput>
    where?: BonusWhereInput
  }

  export type BonusUpdateToOneWithWhereWithoutAffiliate_bonusInput = {
    where?: BonusWhereInput
    data: XOR<BonusUpdateWithoutAffiliate_bonusInput, BonusUncheckedUpdateWithoutAffiliate_bonusInput>
  }

  export type BonusUpdateWithoutAffiliate_bonusInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutBonusNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutBonusNestedInput
  }

  export type BonusUncheckedUpdateWithoutAffiliate_bonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutBonusNestedInput
  }

  export type StoresUpsertWithoutAffiliate_bonusInput = {
    update: XOR<StoresUpdateWithoutAffiliate_bonusInput, StoresUncheckedUpdateWithoutAffiliate_bonusInput>
    create: XOR<StoresCreateWithoutAffiliate_bonusInput, StoresUncheckedCreateWithoutAffiliate_bonusInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutAffiliate_bonusInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutAffiliate_bonusInput, StoresUncheckedUpdateWithoutAffiliate_bonusInput>
  }

  export type StoresUpdateWithoutAffiliate_bonusInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutAffiliate_bonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type BonusCreateWithoutProgram_bonusInput = {
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutBonusInput
    stores: StoresCreateNestedOneWithoutBonusInput
  }

  export type BonusUncheckedCreateWithoutProgram_bonusInput = {
    id?: number
    store_id: number
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutBonusInput
  }

  export type BonusCreateOrConnectWithoutProgram_bonusInput = {
    where: BonusWhereUniqueInput
    create: XOR<BonusCreateWithoutProgram_bonusInput, BonusUncheckedCreateWithoutProgram_bonusInput>
  }

  export type ProgramsCreateWithoutProgram_bonusInput = {
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsCreateNestedOneWithoutProgramsInput
    Orders?: OrdersCreateNestedManyWithoutProgramsInput
    stores: StoresCreateNestedOneWithoutProgramsInput
    tiers?: TiersCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsUncheckedCreateWithoutProgram_bonusInput = {
    id?: number
    store_id: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedOneWithoutProgramsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProgramsInput
    tiers?: TiersUncheckedCreateNestedManyWithoutProgramsInput
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsCreateOrConnectWithoutProgram_bonusInput = {
    where: ProgramsWhereUniqueInput
    create: XOR<ProgramsCreateWithoutProgram_bonusInput, ProgramsUncheckedCreateWithoutProgram_bonusInput>
  }

  export type StoresCreateWithoutProgram_bonusInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutProgram_bonusInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutProgram_bonusInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutProgram_bonusInput, StoresUncheckedCreateWithoutProgram_bonusInput>
  }

  export type BonusUpsertWithoutProgram_bonusInput = {
    update: XOR<BonusUpdateWithoutProgram_bonusInput, BonusUncheckedUpdateWithoutProgram_bonusInput>
    create: XOR<BonusCreateWithoutProgram_bonusInput, BonusUncheckedCreateWithoutProgram_bonusInput>
    where?: BonusWhereInput
  }

  export type BonusUpdateToOneWithWhereWithoutProgram_bonusInput = {
    where?: BonusWhereInput
    data: XOR<BonusUpdateWithoutProgram_bonusInput, BonusUncheckedUpdateWithoutProgram_bonusInput>
  }

  export type BonusUpdateWithoutProgram_bonusInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutBonusNestedInput
    stores?: StoresUpdateOneRequiredWithoutBonusNestedInput
  }

  export type BonusUncheckedUpdateWithoutProgram_bonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutBonusNestedInput
  }

  export type ProgramsUpsertWithoutProgram_bonusInput = {
    update: XOR<ProgramsUpdateWithoutProgram_bonusInput, ProgramsUncheckedUpdateWithoutProgram_bonusInput>
    create: XOR<ProgramsCreateWithoutProgram_bonusInput, ProgramsUncheckedCreateWithoutProgram_bonusInput>
    where?: ProgramsWhereInput
  }

  export type ProgramsUpdateToOneWithWhereWithoutProgram_bonusInput = {
    where?: ProgramsWhereInput
    data: XOR<ProgramsUpdateWithoutProgram_bonusInput, ProgramsUncheckedUpdateWithoutProgram_bonusInput>
  }

  export type ProgramsUpdateWithoutProgram_bonusInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUpdateManyWithoutProgramsNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgramsNestedInput
    tiers?: TiersUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsUncheckedUpdateWithoutProgram_bonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProgramsNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutProgramsNestedInput
  }

  export type StoresUpsertWithoutProgram_bonusInput = {
    update: XOR<StoresUpdateWithoutProgram_bonusInput, StoresUncheckedUpdateWithoutProgram_bonusInput>
    create: XOR<StoresCreateWithoutProgram_bonusInput, StoresUncheckedCreateWithoutProgram_bonusInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutProgram_bonusInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutProgram_bonusInput, StoresUncheckedUpdateWithoutProgram_bonusInput>
  }

  export type StoresUpdateWithoutProgram_bonusInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutProgram_bonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type StoresCreateWithoutNotificationsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutNotificationsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutNotificationsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutNotificationsInput, StoresUncheckedCreateWithoutNotificationsInput>
  }

  export type StoresUpsertWithoutNotificationsInput = {
    update: XOR<StoresUpdateWithoutNotificationsInput, StoresUncheckedUpdateWithoutNotificationsInput>
    create: XOR<StoresCreateWithoutNotificationsInput, StoresUncheckedCreateWithoutNotificationsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutNotificationsInput, StoresUncheckedUpdateWithoutNotificationsInput>
  }

  export type StoresUpdateWithoutNotificationsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type StoresCreateWithoutActivity_logInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutActivity_logInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutActivity_logInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutActivity_logInput, StoresUncheckedCreateWithoutActivity_logInput>
  }

  export type AffiliatesCreateWithoutActivity_logInput = {
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutAffiliatesInput
    members: MembersCreateNestedOneWithoutAffiliatesInput
    stores: StoresCreateNestedOneWithoutAffiliatesInput
    commissions?: CommissionsCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesUncheckedCreateWithoutActivity_logInput = {
    id?: number
    store_id: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutAffiliatesInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutAffiliatesInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutAffiliatesInput
    customers?: CustomersUncheckedCreateNestedManyWithoutAffiliatesInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutAffiliatesInput
    orders?: OrdersUncheckedCreateNestedManyWithoutAffiliatesInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutAffiliatesInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutAffiliatesInput
  }

  export type AffiliatesCreateOrConnectWithoutActivity_logInput = {
    where: AffiliatesWhereUniqueInput
    create: XOR<AffiliatesCreateWithoutActivity_logInput, AffiliatesUncheckedCreateWithoutActivity_logInput>
  }

  export type ProgramsCreateWithoutActivity_logInput = {
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsCreateNestedOneWithoutProgramsInput
    Orders?: OrdersCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutProgramsInput
    stores: StoresCreateNestedOneWithoutProgramsInput
    tiers?: TiersCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsUncheckedCreateWithoutActivity_logInput = {
    id?: number
    store_id: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutProgramsInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedOneWithoutProgramsInput
    Orders?: OrdersUncheckedCreateNestedManyWithoutProgramsInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutProgramsInput
    tiers?: TiersUncheckedCreateNestedManyWithoutProgramsInput
  }

  export type ProgramsCreateOrConnectWithoutActivity_logInput = {
    where: ProgramsWhereUniqueInput
    create: XOR<ProgramsCreateWithoutActivity_logInput, ProgramsUncheckedCreateWithoutActivity_logInput>
  }

  export type OrdersCreateWithoutActivity_logInput = {
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    commissions?: CommissionsCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsCreateNestedManyWithoutOrdersInput
    affiliates: AffiliatesCreateNestedOneWithoutOrdersInput
    customers: CustomersCreateNestedOneWithoutOrdersInput
    programs?: ProgramsCreateNestedOneWithoutOrdersInput
    stores: StoresCreateNestedOneWithoutOrdersInput
  }

  export type OrdersUncheckedCreateWithoutActivity_logInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
    commissions?: CommissionsUncheckedCreateNestedOneWithoutOrdersInput
    order_items?: OrderItemsUncheckedCreateNestedManyWithoutOrdersInput
  }

  export type OrdersCreateOrConnectWithoutActivity_logInput = {
    where: OrdersWhereUniqueInput
    create: XOR<OrdersCreateWithoutActivity_logInput, OrdersUncheckedCreateWithoutActivity_logInput>
  }

  export type PayoutsCreateWithoutActivity_logInput = {
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    affiliates: AffiliatesCreateNestedOneWithoutPayoutsInput
    jobs: JobsCreateNestedOneWithoutPayoutsInput
    stores: StoresCreateNestedOneWithoutPayoutsInput
  }

  export type PayoutsUncheckedCreateWithoutActivity_logInput = {
    id?: number
    store_id: number
    affiliate_id: number
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    job_id: number
  }

  export type PayoutsCreateOrConnectWithoutActivity_logInput = {
    where: PayoutsWhereUniqueInput
    create: XOR<PayoutsCreateWithoutActivity_logInput, PayoutsUncheckedCreateWithoutActivity_logInput>
  }

  export type StoresUpsertWithoutActivity_logInput = {
    update: XOR<StoresUpdateWithoutActivity_logInput, StoresUncheckedUpdateWithoutActivity_logInput>
    create: XOR<StoresCreateWithoutActivity_logInput, StoresUncheckedCreateWithoutActivity_logInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutActivity_logInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutActivity_logInput, StoresUncheckedUpdateWithoutActivity_logInput>
  }

  export type StoresUpdateWithoutActivity_logInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutActivity_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type AffiliatesUpsertWithoutActivity_logInput = {
    update: XOR<AffiliatesUpdateWithoutActivity_logInput, AffiliatesUncheckedUpdateWithoutActivity_logInput>
    create: XOR<AffiliatesCreateWithoutActivity_logInput, AffiliatesUncheckedCreateWithoutActivity_logInput>
    where?: AffiliatesWhereInput
  }

  export type AffiliatesUpdateToOneWithWhereWithoutActivity_logInput = {
    where?: AffiliatesWhereInput
    data: XOR<AffiliatesUpdateWithoutActivity_logInput, AffiliatesUncheckedUpdateWithoutActivity_logInput>
  }

  export type AffiliatesUpdateWithoutActivity_logInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutActivity_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type ProgramsUpsertWithoutActivity_logInput = {
    update: XOR<ProgramsUpdateWithoutActivity_logInput, ProgramsUncheckedUpdateWithoutActivity_logInput>
    create: XOR<ProgramsCreateWithoutActivity_logInput, ProgramsUncheckedCreateWithoutActivity_logInput>
    where?: ProgramsWhereInput
  }

  export type ProgramsUpdateToOneWithWhereWithoutActivity_logInput = {
    where?: ProgramsWhereInput
    data: XOR<ProgramsUpdateWithoutActivity_logInput, ProgramsUncheckedUpdateWithoutActivity_logInput>
  }

  export type ProgramsUpdateWithoutActivity_logInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutProgramsNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgramsNestedInput
    tiers?: TiersUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsUncheckedUpdateWithoutActivity_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutProgramsNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutProgramsNestedInput
  }

  export type OrdersUpsertWithoutActivity_logInput = {
    update: XOR<OrdersUpdateWithoutActivity_logInput, OrdersUncheckedUpdateWithoutActivity_logInput>
    create: XOR<OrdersCreateWithoutActivity_logInput, OrdersUncheckedCreateWithoutActivity_logInput>
    where?: OrdersWhereInput
  }

  export type OrdersUpdateToOneWithWhereWithoutActivity_logInput = {
    where?: OrdersWhereInput
    data: XOR<OrdersUpdateWithoutActivity_logInput, OrdersUncheckedUpdateWithoutActivity_logInput>
  }

  export type OrdersUpdateWithoutActivity_logInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    commissions?: CommissionsUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUpdateManyWithoutOrdersNestedInput
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrdersNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrdersNestedInput
    programs?: ProgramsUpdateOneWithoutOrdersNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutActivity_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    commissions?: CommissionsUncheckedUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type PayoutsUpsertWithoutActivity_logInput = {
    update: XOR<PayoutsUpdateWithoutActivity_logInput, PayoutsUncheckedUpdateWithoutActivity_logInput>
    create: XOR<PayoutsCreateWithoutActivity_logInput, PayoutsUncheckedCreateWithoutActivity_logInput>
    where?: PayoutsWhereInput
  }

  export type PayoutsUpdateToOneWithWhereWithoutActivity_logInput = {
    where?: PayoutsWhereInput
    data: XOR<PayoutsUpdateWithoutActivity_logInput, PayoutsUncheckedUpdateWithoutActivity_logInput>
  }

  export type PayoutsUpdateWithoutActivity_logInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    affiliates?: AffiliatesUpdateOneRequiredWithoutPayoutsNestedInput
    jobs?: JobsUpdateOneRequiredWithoutPayoutsNestedInput
    stores?: StoresUpdateOneRequiredWithoutPayoutsNestedInput
  }

  export type PayoutsUncheckedUpdateWithoutActivity_logInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    job_id?: IntFieldUpdateOperationsInput | number
  }

  export type StoresCreateWithoutMessageHistoryInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutMessageHistoryInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutMessageHistoryInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutMessageHistoryInput, StoresUncheckedCreateWithoutMessageHistoryInput>
  }

  export type StoresUpsertWithoutMessageHistoryInput = {
    update: XOR<StoresUpdateWithoutMessageHistoryInput, StoresUncheckedUpdateWithoutMessageHistoryInput>
    create: XOR<StoresCreateWithoutMessageHistoryInput, StoresUncheckedCreateWithoutMessageHistoryInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutMessageHistoryInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutMessageHistoryInput, StoresUncheckedUpdateWithoutMessageHistoryInput>
  }

  export type StoresUpdateWithoutMessageHistoryInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutMessageHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type StoresCreateWithoutPaymentGatewayInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutPaymentGatewayInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutPaymentGatewayInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutPaymentGatewayInput, StoresUncheckedCreateWithoutPaymentGatewayInput>
  }

  export type StoresUpsertWithoutPaymentGatewayInput = {
    update: XOR<StoresUpdateWithoutPaymentGatewayInput, StoresUncheckedUpdateWithoutPaymentGatewayInput>
    create: XOR<StoresCreateWithoutPaymentGatewayInput, StoresUncheckedCreateWithoutPaymentGatewayInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutPaymentGatewayInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutPaymentGatewayInput, StoresUncheckedUpdateWithoutPaymentGatewayInput>
  }

  export type StoresUpdateWithoutPaymentGatewayInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutPaymentGatewayInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type StoresCreateWithoutAppSubscriptionInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutAppSubscriptionInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    Integrations?: IntegrationsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutAppSubscriptionInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutAppSubscriptionInput, StoresUncheckedCreateWithoutAppSubscriptionInput>
  }

  export type StoresUpsertWithoutAppSubscriptionInput = {
    update: XOR<StoresUpdateWithoutAppSubscriptionInput, StoresUncheckedUpdateWithoutAppSubscriptionInput>
    create: XOR<StoresCreateWithoutAppSubscriptionInput, StoresUncheckedCreateWithoutAppSubscriptionInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutAppSubscriptionInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutAppSubscriptionInput, StoresUncheckedUpdateWithoutAppSubscriptionInput>
  }

  export type StoresUpdateWithoutAppSubscriptionInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutAppSubscriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    Integrations?: IntegrationsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type StoresCreateWithoutIntegrationsInput = {
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionCreateNestedOneWithoutStoresInput
    bonus?: BonusCreateNestedManyWithoutStoresInput
    commissions?: CommissionsCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsCreateNestedManyWithoutStoresInput
    customers?: CustomersCreateNestedManyWithoutStoresInput
    gifts?: GiftsCreateNestedManyWithoutStoresInput
    jobs?: JobsCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryCreateNestedManyWithoutStoresInput
    notifications?: NotificationsCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsCreateNestedManyWithoutStoresInput
    orders?: OrdersCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayCreateNestedManyWithoutStoresInput
    payouts?: PayoutsCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusCreateNestedManyWithoutStoresInput
    programs?: ProgramsCreateNestedManyWithoutStoresInput
    settings?: SettingsCreateNestedOneWithoutStoresInput
    tiers?: TiersCreateNestedManyWithoutStoresInput
    transactions?: TransactionsCreateNestedManyWithoutStoresInput
  }

  export type StoresUncheckedCreateWithoutIntegrationsInput = {
    id?: number
    store_id?: string
    domain: string
    myshopify_domain: string
    email: string
    blacklisted: boolean
    currency_code: string
    country_code: string
    language: string
    status: $Enums.StoreStatusType
    store_details: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token: string
    storefront_access_token: string
    created_at: bigint | number
    updated_at: bigint | number
    shopify_store_id?: bigint | number | null
    landing_page_id?: bigint | number | null
    portal_page_id?: bigint | number | null
    contact_email?: string
    contact_name?: string
    contact_phone?: string | null
    webhook_registration_check?: boolean | null
    activity_log?: ActivityLogUncheckedCreateNestedManyWithoutStoresInput
    affiliate_bonus?: AffiliateBonusUncheckedCreateNestedManyWithoutStoresInput
    affiliate_discounts?: AffiliateDiscountsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_gifts?: AffiliateGiftsUncheckedCreateNestedManyWithoutStoresInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedCreateNestedManyWithoutStoresInput
    affiliate_programs?: AffiliateProgramsUncheckedCreateNestedManyWithoutStoresInput
    affiliates?: AffiliatesUncheckedCreateNestedManyWithoutStoresInput
    AppSubscription?: AppSubscriptionUncheckedCreateNestedOneWithoutStoresInput
    bonus?: BonusUncheckedCreateNestedManyWithoutStoresInput
    commissions?: CommissionsUncheckedCreateNestedManyWithoutStoresInput
    customer_discounts?: CustomerDiscountsUncheckedCreateNestedManyWithoutStoresInput
    customers?: CustomersUncheckedCreateNestedManyWithoutStoresInput
    gifts?: GiftsUncheckedCreateNestedManyWithoutStoresInput
    jobs?: JobsUncheckedCreateNestedManyWithoutStoresInput
    messageHistory?: MessageHistoryUncheckedCreateNestedManyWithoutStoresInput
    notifications?: NotificationsUncheckedCreateNestedManyWithoutStoresInput
    orderItems?: OrderItemsUncheckedCreateNestedManyWithoutStoresInput
    orders?: OrdersUncheckedCreateNestedManyWithoutStoresInput
    PaymentGateway?: PaymentGatewayUncheckedCreateNestedManyWithoutStoresInput
    payouts?: PayoutsUncheckedCreateNestedManyWithoutStoresInput
    program_bonus?: ProgramBonusUncheckedCreateNestedManyWithoutStoresInput
    programs?: ProgramsUncheckedCreateNestedManyWithoutStoresInput
    settings?: SettingsUncheckedCreateNestedOneWithoutStoresInput
    tiers?: TiersUncheckedCreateNestedManyWithoutStoresInput
    transactions?: TransactionsUncheckedCreateNestedManyWithoutStoresInput
  }

  export type StoresCreateOrConnectWithoutIntegrationsInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutIntegrationsInput, StoresUncheckedCreateWithoutIntegrationsInput>
  }

  export type StoresUpsertWithoutIntegrationsInput = {
    update: XOR<StoresUpdateWithoutIntegrationsInput, StoresUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<StoresCreateWithoutIntegrationsInput, StoresUncheckedCreateWithoutIntegrationsInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutIntegrationsInput, StoresUncheckedUpdateWithoutIntegrationsInput>
  }

  export type StoresUpdateWithoutIntegrationsInput = {
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUpdateOneWithoutStoresNestedInput
    bonus?: BonusUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUpdateManyWithoutStoresNestedInput
    customers?: CustomersUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUpdateManyWithoutStoresNestedInput
    jobs?: JobsUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUpdateManyWithoutStoresNestedInput
    orders?: OrdersUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUpdateManyWithoutStoresNestedInput
    settings?: SettingsUpdateOneWithoutStoresNestedInput
    tiers?: TiersUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUpdateManyWithoutStoresNestedInput
  }

  export type StoresUncheckedUpdateWithoutIntegrationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    myshopify_domain?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    currency_code?: StringFieldUpdateOperationsInput | string
    country_code?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    status?: EnumStoreStatusTypeFieldUpdateOperationsInput | $Enums.StoreStatusType
    store_details?: JsonNullValueInput | InputJsonValue
    remote_details?: NullableJsonNullValueInput | InputJsonValue
    admin_access_token?: StringFieldUpdateOperationsInput | string
    storefront_access_token?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_store_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    landing_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    portal_page_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    contact_email?: StringFieldUpdateOperationsInput | string
    contact_name?: StringFieldUpdateOperationsInput | string
    contact_phone?: NullableStringFieldUpdateOperationsInput | string | null
    webhook_registration_check?: NullableBoolFieldUpdateOperationsInput | boolean | null
    activity_log?: ActivityLogUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutStoresNestedInput
    affiliates?: AffiliatesUncheckedUpdateManyWithoutStoresNestedInput
    AppSubscription?: AppSubscriptionUncheckedUpdateOneWithoutStoresNestedInput
    bonus?: BonusUncheckedUpdateManyWithoutStoresNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutStoresNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateManyWithoutStoresNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutStoresNestedInput
    gifts?: GiftsUncheckedUpdateManyWithoutStoresNestedInput
    jobs?: JobsUncheckedUpdateManyWithoutStoresNestedInput
    messageHistory?: MessageHistoryUncheckedUpdateManyWithoutStoresNestedInput
    notifications?: NotificationsUncheckedUpdateManyWithoutStoresNestedInput
    orderItems?: OrderItemsUncheckedUpdateManyWithoutStoresNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutStoresNestedInput
    PaymentGateway?: PaymentGatewayUncheckedUpdateManyWithoutStoresNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutStoresNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutStoresNestedInput
    programs?: ProgramsUncheckedUpdateManyWithoutStoresNestedInput
    settings?: SettingsUncheckedUpdateOneWithoutStoresNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutStoresNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type ActivityLogCreateManyStoresInput = {
    id?: number
    affiliate_id?: number | null
    program_id?: number | null
    order_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type AffiliateBonusCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateDiscountsCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    discount_id: bigint | number
    discount_code: string
    is_deleted?: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateGiftsCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    gift_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramHistoryCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramsCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    program_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliatesCreateManyStoresInput = {
    id?: number
    member_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
  }

  export type BonusCreateManyStoresInput = {
    id?: number
    title: string
    description: string
    bonus_associate: $Enums.BonusType
    target_type: $Enums.TierType
    target_goal: number
    bonus_type: $Enums.EarningType
    bonus_rate: number
    status: $Enums.StatusType
    begin_datetime: bigint | number
    expire_datetime: bigint | number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CommissionsCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    order_id: number
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CustomerDiscountsCreateManyStoresInput = {
    id?: number
    program_id: number
    discount_rate: number
    discount_options: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
    discount_type: $Enums.CustomerDiscountType
  }

  export type CustomersCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type GiftsCreateManyStoresInput = {
    id?: number
    title: string
    description: string
    products: JsonNullValueInput | InputJsonValue
    gift_type: $Enums.GiftType
    status: $Enums.StatusType
    shipping_method: $Enums.ShippingType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type IntegrationsCreateManyStoresInput = {
    id?: number
    integration_type: $Enums.IntegrationType
    status: $Enums.NotificationStatusType
    api_key: string
    api_secret?: string | null
    created_at: bigint | number
    updated_at: bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JobsCreateManyStoresInput = {
    id?: number
    job_metadata: JsonNullValueInput | InputJsonValue
    status: $Enums.JobsStatusType
    type: $Enums.JobType
    job_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type MessageHistoryCreateManyStoresInput = {
    id?: number
    status: $Enums.MessageHistoryStatusType
    referenceId: string
    metaData: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
  }

  export type NotificationsCreateManyStoresInput = {
    id?: number
    notification_id?: string
    type: $Enums.NotificationType
    receiver_type: $Enums.NotificationReceiverType
    subject: string
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
    languages?: string
  }

  export type OrderItemsCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    customer_id: number
    order_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrdersCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
  }

  export type PaymentGatewayCreateManyStoresInput = {
    id?: number
    payment_uuid?: string
    provider: $Enums.PaymentType
    credentials: JsonNullValueInput | InputJsonValue
    webhook_id?: string | null
    status: $Enums.NotificationStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type PayoutsCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    job_id: number
  }

  export type ProgramBonusCreateManyStoresInput = {
    id?: number
    program_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ProgramsCreateManyStoresInput = {
    id?: number
    title: string
    description: string
    currency_code: string
    program_details: JsonNullValueInput | InputJsonValue
    status: $Enums.ProgramStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TiersCreateManyStoresInput = {
    id?: number
    program_id: number
    tier_type: $Enums.TierType
    min_value: number
    max_value?: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TransactionsCreateManyStoresInput = {
    id?: number
    affiliate_id: number
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted?: boolean
    amount: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ActivityLogUpdateWithoutStoresInput = {
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneWithoutActivity_logNestedInput
    programs?: ProgramsUpdateOneWithoutActivity_logNestedInput
    orders?: OrdersUpdateOneWithoutActivity_logNestedInput
    payouts?: PayoutsUpdateOneWithoutActivity_logNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateBonusUpdateWithoutStoresInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_bonusNestedInput
    bonus?: BonusUpdateOneRequiredWithoutAffiliate_bonusNestedInput
  }

  export type AffiliateBonusUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateBonusUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateDiscountsUpdateWithoutStoresInput = {
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_discountsNestedInput
  }

  export type AffiliateDiscountsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateDiscountsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateGiftsUpdateWithoutStoresInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_giftsNestedInput
    gifts?: GiftsUpdateOneRequiredWithoutAffiliate_giftsNestedInput
  }

  export type AffiliateGiftsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    gift_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateGiftsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    gift_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramHistoryUpdateWithoutStoresInput = {
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_program_historyNestedInput
  }

  export type AffiliateProgramHistoryUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramHistoryUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramsUpdateWithoutStoresInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_programsNestedInput
    programs?: ProgramsUpdateOneRequiredWithoutAffiliate_programsNestedInput
  }

  export type AffiliateProgramsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliatesUpdateWithoutStoresInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    members?: MembersUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    member_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
  }

  export type BonusUpdateWithoutStoresInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutBonusNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutBonusNestedInput
  }

  export type BonusUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutBonusNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutBonusNestedInput
  }

  export type BonusUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    bonus_associate?: EnumBonusTypeFieldUpdateOperationsInput | $Enums.BonusType
    target_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    target_goal?: FloatFieldUpdateOperationsInput | number
    bonus_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    bonus_rate?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    begin_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    expire_datetime?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommissionsUpdateWithoutStoresInput = {
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutCommissionsNestedInput
    orders?: OrdersUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type CommissionsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommissionsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CustomerDiscountsUpdateWithoutStoresInput = {
    discount_rate?: FloatFieldUpdateOperationsInput | number
    discount_options?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_type?: EnumCustomerDiscountTypeFieldUpdateOperationsInput | $Enums.CustomerDiscountType
    programs?: ProgramsUpdateOneRequiredWithoutCustomer_discountsNestedInput
  }

  export type CustomerDiscountsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    discount_rate?: FloatFieldUpdateOperationsInput | number
    discount_options?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_type?: EnumCustomerDiscountTypeFieldUpdateOperationsInput | $Enums.CustomerDiscountType
  }

  export type CustomerDiscountsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    discount_rate?: FloatFieldUpdateOperationsInput | number
    discount_options?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_type?: EnumCustomerDiscountTypeFieldUpdateOperationsInput | $Enums.CustomerDiscountType
  }

  export type CustomersUpdateWithoutStoresInput = {
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutCustomersNestedInput
    order_items?: OrderItemsUpdateManyWithoutCustomersNestedInput
    orders?: OrdersUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    order_items?: OrderItemsUncheckedUpdateManyWithoutCustomersNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type GiftsUpdateWithoutStoresInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    products?: JsonNullValueInput | InputJsonValue
    gift_type?: EnumGiftTypeFieldUpdateOperationsInput | $Enums.GiftType
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    shipping_method?: EnumShippingTypeFieldUpdateOperationsInput | $Enums.ShippingType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutGiftsNestedInput
  }

  export type GiftsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    products?: JsonNullValueInput | InputJsonValue
    gift_type?: EnumGiftTypeFieldUpdateOperationsInput | $Enums.GiftType
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    shipping_method?: EnumShippingTypeFieldUpdateOperationsInput | $Enums.ShippingType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutGiftsNestedInput
  }

  export type GiftsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    products?: JsonNullValueInput | InputJsonValue
    gift_type?: EnumGiftTypeFieldUpdateOperationsInput | $Enums.GiftType
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    shipping_method?: EnumShippingTypeFieldUpdateOperationsInput | $Enums.ShippingType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type IntegrationsUpdateWithoutStoresInput = {
    integration_type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    integration_type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type IntegrationsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    integration_type?: EnumIntegrationTypeFieldUpdateOperationsInput | $Enums.IntegrationType
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    api_key?: StringFieldUpdateOperationsInput | string
    api_secret?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    integration_details?: NullableJsonNullValueInput | InputJsonValue
  }

  export type JobsUpdateWithoutStoresInput = {
    job_metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumJobsStatusTypeFieldUpdateOperationsInput | $Enums.JobsStatusType
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    job_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    payouts?: PayoutsUpdateOneWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumJobsStatusTypeFieldUpdateOperationsInput | $Enums.JobsStatusType
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    job_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    payouts?: PayoutsUncheckedUpdateOneWithoutJobsNestedInput
  }

  export type JobsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_metadata?: JsonNullValueInput | InputJsonValue
    status?: EnumJobsStatusTypeFieldUpdateOperationsInput | $Enums.JobsStatusType
    type?: EnumJobTypeFieldUpdateOperationsInput | $Enums.JobType
    job_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MessageHistoryUpdateWithoutStoresInput = {
    status?: EnumMessageHistoryStatusTypeFieldUpdateOperationsInput | $Enums.MessageHistoryStatusType
    referenceId?: StringFieldUpdateOperationsInput | string
    metaData?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MessageHistoryUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumMessageHistoryStatusTypeFieldUpdateOperationsInput | $Enums.MessageHistoryStatusType
    referenceId?: StringFieldUpdateOperationsInput | string
    metaData?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type MessageHistoryUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: EnumMessageHistoryStatusTypeFieldUpdateOperationsInput | $Enums.MessageHistoryStatusType
    referenceId?: StringFieldUpdateOperationsInput | string
    metaData?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type NotificationsUpdateWithoutStoresInput = {
    notification_id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFieldUpdateOperationsInput | $Enums.NotificationReceiverType
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    languages?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    notification_id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFieldUpdateOperationsInput | $Enums.NotificationReceiverType
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    languages?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    notification_id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    receiver_type?: EnumNotificationReceiverTypeFieldUpdateOperationsInput | $Enums.NotificationReceiverType
    subject?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    languages?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemsUpdateWithoutStoresInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrder_itemsNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrder_itemsNestedInput
    orders?: OrdersUpdateOneRequiredWithoutOrder_itemsNestedInput
  }

  export type OrderItemsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrdersUpdateWithoutStoresInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    commissions?: CommissionsUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUpdateManyWithoutOrdersNestedInput
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrdersNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrdersNestedInput
    programs?: ProgramsUpdateOneWithoutOrdersNestedInput
    activity_log?: ActivityLogUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    commissions?: CommissionsUncheckedUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutOrdersNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentGatewayUpdateWithoutStoresInput = {
    payment_uuid?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    credentials?: JsonNullValueInput | InputJsonValue
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PaymentGatewayUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_uuid?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    credentials?: JsonNullValueInput | InputJsonValue
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PaymentGatewayUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    payment_uuid?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    credentials?: JsonNullValueInput | InputJsonValue
    webhook_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumNotificationStatusTypeFieldUpdateOperationsInput | $Enums.NotificationStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type PayoutsUpdateWithoutStoresInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    affiliates?: AffiliatesUpdateOneRequiredWithoutPayoutsNestedInput
    jobs?: JobsUpdateOneRequiredWithoutPayoutsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutPayoutsNestedInput
  }

  export type PayoutsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    job_id?: IntFieldUpdateOperationsInput | number
    activity_log?: ActivityLogUncheckedUpdateManyWithoutPayoutsNestedInput
  }

  export type PayoutsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    job_id?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramBonusUpdateWithoutStoresInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    bonus?: BonusUpdateOneRequiredWithoutProgram_bonusNestedInput
    programs?: ProgramsUpdateOneRequiredWithoutProgram_bonusNestedInput
  }

  export type ProgramBonusUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramBonusUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramsUpdateWithoutStoresInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUpdateManyWithoutProgramsNestedInput
    tiers?: TiersUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutProgramsNestedInput
    customer_discounts?: CustomerDiscountsUncheckedUpdateOneWithoutProgramsNestedInput
    Orders?: OrdersUncheckedUpdateManyWithoutProgramsNestedInput
    program_bonus?: ProgramBonusUncheckedUpdateManyWithoutProgramsNestedInput
    tiers?: TiersUncheckedUpdateManyWithoutProgramsNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutProgramsNestedInput
  }

  export type ProgramsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    program_details?: JsonNullValueInput | InputJsonValue
    status?: EnumProgramStatusTypeFieldUpdateOperationsInput | $Enums.ProgramStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TiersUpdateWithoutStoresInput = {
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    programs?: ProgramsUpdateOneRequiredWithoutTiersNestedInput
  }

  export type TiersUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TiersUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TransactionsUpdateWithoutStoresInput = {
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TransactionsUncheckedUpdateManyWithoutStoresInput = {
    id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliatesCreateManyMembersInput = {
    id?: number
    store_id: number
    first_name?: string | null
    last_name?: string | null
    phone?: string | null
    referral_code: string
    status: $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: boolean | null
    created_at: bigint | number
    updated_at: bigint | number
    source?: $Enums.AffiliateSourceType | null
  }

  export type AffiliatesUpdateWithoutMembersInput = {
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUpdateManyWithoutAffiliatesNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliatesNestedInput
    commissions?: CommissionsUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
    affiliate_bonus?: AffiliateBonusUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_discounts?: AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_gifts?: AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_program_history?: AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesNestedInput
    affiliate_programs?: AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesNestedInput
    commissions?: CommissionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    customers?: CustomersUncheckedUpdateManyWithoutAffiliatesNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutAffiliatesNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutAffiliatesNestedInput
    payouts?: PayoutsUncheckedUpdateManyWithoutAffiliatesNestedInput
    transactions?: TransactionsUncheckedUpdateManyWithoutAffiliatesNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutAffiliatesNestedInput
  }

  export type AffiliatesUncheckedUpdateManyWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    referral_code?: StringFieldUpdateOperationsInput | string
    status?: EnumAffiliateStatusTypeFieldUpdateOperationsInput | $Enums.AffiliateStatusType
    affiliate_details?: NullableJsonNullValueInput | InputJsonValue
    payout_requested?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    source?: NullableEnumAffiliateSourceTypeFieldUpdateOperationsInput | $Enums.AffiliateSourceType | null
  }

  export type AffiliateProgramsCreateManyProgramsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrdersCreateManyProgramsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ProgramBonusCreateManyProgramsInput = {
    id?: number
    store_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type TiersCreateManyProgramsInput = {
    id?: number
    store_id: number
    tier_type: $Enums.TierType
    min_value: number
    max_value?: number | null
    commission_type: $Enums.EarningType
    commission_rate: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ActivityLogCreateManyProgramsInput = {
    id?: number
    store_id: number
    affiliate_id?: number | null
    order_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type AffiliateProgramsUpdateWithoutProgramsInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_programsNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_programsNestedInput
  }

  export type AffiliateProgramsUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramsUncheckedUpdateManyWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrdersUpdateWithoutProgramsInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    commissions?: CommissionsUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUpdateManyWithoutOrdersNestedInput
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrdersNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrdersNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrdersNestedInput
    activity_log?: ActivityLogUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    commissions?: CommissionsUncheckedUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutOrdersNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramBonusUpdateWithoutProgramsInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    bonus?: BonusUpdateOneRequiredWithoutProgram_bonusNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgram_bonusNestedInput
  }

  export type ProgramBonusUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramBonusUncheckedUpdateManyWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TiersUpdateWithoutProgramsInput = {
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutTiersNestedInput
  }

  export type TiersUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TiersUncheckedUpdateManyWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    tier_type?: EnumTierTypeFieldUpdateOperationsInput | $Enums.TierType
    min_value?: FloatFieldUpdateOperationsInput | number
    max_value?: NullableFloatFieldUpdateOperationsInput | number | null
    commission_type?: EnumEarningTypeFieldUpdateOperationsInput | $Enums.EarningType
    commission_rate?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogUpdateWithoutProgramsInput = {
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutActivity_logNestedInput
    affiliates?: AffiliatesUpdateOneWithoutActivity_logNestedInput
    orders?: OrdersUpdateOneWithoutActivity_logNestedInput
    payouts?: PayoutsUpdateOneWithoutActivity_logNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogUncheckedUpdateManyWithoutProgramsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsCreateManyOrdersInput = {
    id?: number
    store_id: number
    affiliate_id: number
    customer_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ActivityLogCreateManyOrdersInput = {
    id?: number
    store_id: number
    affiliate_id?: number | null
    program_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type OrderItemsUpdateWithoutOrdersInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrder_itemsNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrder_itemsNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemsUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogUpdateWithoutOrdersInput = {
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutActivity_logNestedInput
    affiliates?: AffiliatesUpdateOneWithoutActivity_logNestedInput
    programs?: ProgramsUpdateOneWithoutActivity_logNestedInput
    payouts?: PayoutsUpdateOneWithoutActivity_logNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogUncheckedUpdateManyWithoutOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogCreateManyPayoutsInput = {
    id?: number
    store_id: number
    affiliate_id?: number | null
    program_id?: number | null
    order_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type ActivityLogUpdateWithoutPayoutsInput = {
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutActivity_logNestedInput
    affiliates?: AffiliatesUpdateOneWithoutActivity_logNestedInput
    programs?: ProgramsUpdateOneWithoutActivity_logNestedInput
    orders?: OrdersUpdateOneWithoutActivity_logNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutPayoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogUncheckedUpdateManyWithoutPayoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: NullableIntFieldUpdateOperationsInput | number | null
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateBonusCreateManyBonusInput = {
    id?: number
    store_id: number
    affiliate_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ProgramBonusCreateManyBonusInput = {
    id?: number
    store_id: number
    program_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateBonusUpdateWithoutBonusInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_bonusNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_bonusNestedInput
  }

  export type AffiliateBonusUncheckedUpdateWithoutBonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateBonusUncheckedUpdateManyWithoutBonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramBonusUpdateWithoutBonusInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    programs?: ProgramsUpdateOneRequiredWithoutProgram_bonusNestedInput
    stores?: StoresUpdateOneRequiredWithoutProgram_bonusNestedInput
  }

  export type ProgramBonusUncheckedUpdateWithoutBonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ProgramBonusUncheckedUpdateManyWithoutBonusInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateGiftsCreateManyGiftsInput = {
    id?: number
    store_id: number
    affiliate_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateGiftsUpdateWithoutGiftsInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutAffiliate_giftsNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_giftsNestedInput
  }

  export type AffiliateGiftsUncheckedUpdateWithoutGiftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateGiftsUncheckedUpdateManyWithoutGiftsInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsCreateManyCustomersInput = {
    id?: number
    store_id: number
    affiliate_id: number
    order_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrdersCreateManyCustomersInput = {
    id?: number
    store_id: number
    affiliate_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
  }

  export type OrderItemsUpdateWithoutCustomersInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrder_itemsNestedInput
    orders?: OrdersUpdateOneRequiredWithoutOrder_itemsNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemsUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrdersUpdateWithoutCustomersInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    commissions?: CommissionsUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUpdateManyWithoutOrdersNestedInput
    affiliates?: AffiliatesUpdateOneRequiredWithoutOrdersNestedInput
    programs?: ProgramsUpdateOneWithoutOrdersNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrdersNestedInput
    activity_log?: ActivityLogUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    commissions?: CommissionsUncheckedUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutOrdersNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutCustomersInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    affiliate_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AffiliateBonusCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    bonus_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateDiscountsCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    discount_id: bigint | number
    discount_code: string
    is_deleted?: boolean | null
    status: $Enums.DiscountStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateGiftsCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    gift_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramHistoryCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    program_id: number
    program_name: string
    status: $Enums.ProgramHistoryStatusType
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type AffiliateProgramsCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    program_id: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CommissionsCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    order_id: number
    currency_code: string
    amount: number
    status: $Enums.StatusType
    approval_mode?: $Enums.ApprovalModeType | null
    review_on?: bigint | number | null
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type CustomersCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    shopify_customer_id: bigint | number
    first_name: string
    last_name: string
    contact_type: $Enums.ContactType
    email?: string | null
    phone?: string | null
    customer_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrderItemsCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    customer_id: number
    order_id: number
    item_id: bigint | number
    product_id: bigint | number
    variant_id: bigint | number
    product_title: string
    variant_title: string
    quantity: number
    shop_item_currency_code: string
    shop_item_amount: number
    customer_item_currency_code: string
    customer_item_amount: number
    item_details: JsonNullValueInput | InputJsonValue
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type OrdersCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    customer_id: number
    order_id: bigint | number
    shopify_order_number: number
    shop_order_currency_code: string
    shop_order_amount: number
    customer_order_currency_code: string
    customer_order_amount: number
    financial_status: string
    order_details: JsonNullValueInput | InputJsonValue
    attribute_type?: $Enums.OrderAttributeType
    status: $Enums.OrderStatusType
    created_at: bigint | number
    updated_at: bigint | number
    program_id?: number | null
  }

  export type PayoutsCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    transaction_id?: string
    currency_code: string
    amount: number
    notes: string
    payment_method: $Enums.PaymentType
    payment_details: JsonNullValueInput | InputJsonValue
    status: $Enums.StatusType
    created_at: bigint | number
    updated_at: bigint | number
    user_id?: bigint | number | null
    job_id: number
  }

  export type TransactionsCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    reference_type: $Enums.TransactionReferenceType
    reference_id: string
    currency_code: string
    type: $Enums.TransactionType
    is_reverted?: boolean
    amount: number
    created_at: bigint | number
    updated_at: bigint | number
  }

  export type ActivityLogCreateManyAffiliatesInput = {
    id?: number
    store_id: number
    program_id?: number | null
    order_id?: number | null
    payout_id?: number | null
    entity_type: $Enums.ActivityEntityType
    message: string
    created_at: bigint | number
  }

  export type AffiliateBonusUpdateWithoutAffiliatesInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    bonus?: BonusUpdateOneRequiredWithoutAffiliate_bonusNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_bonusNestedInput
  }

  export type AffiliateBonusUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateBonusUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    bonus_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateDiscountsUpdateWithoutAffiliatesInput = {
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutAffiliate_discountsNestedInput
  }

  export type AffiliateDiscountsUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateDiscountsUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    discount_id?: BigIntFieldUpdateOperationsInput | bigint | number
    discount_code?: StringFieldUpdateOperationsInput | string
    is_deleted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: EnumDiscountStatusTypeFieldUpdateOperationsInput | $Enums.DiscountStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateGiftsUpdateWithoutAffiliatesInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    gifts?: GiftsUpdateOneRequiredWithoutAffiliate_giftsNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_giftsNestedInput
  }

  export type AffiliateGiftsUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    gift_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateGiftsUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    gift_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramHistoryUpdateWithoutAffiliatesInput = {
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutAffiliate_program_historyNestedInput
  }

  export type AffiliateProgramHistoryUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramHistoryUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    program_name?: StringFieldUpdateOperationsInput | string
    status?: EnumProgramHistoryStatusTypeFieldUpdateOperationsInput | $Enums.ProgramHistoryStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramsUpdateWithoutAffiliatesInput = {
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    programs?: ProgramsUpdateOneRequiredWithoutAffiliate_programsNestedInput
    stores?: StoresUpdateOneRequiredWithoutAffiliate_programsNestedInput
  }

  export type AffiliateProgramsUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type AffiliateProgramsUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: IntFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommissionsUpdateWithoutAffiliatesInput = {
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    orders?: OrdersUpdateOneRequiredWithoutCommissionsNestedInput
    stores?: StoresUpdateOneRequiredWithoutCommissionsNestedInput
  }

  export type CommissionsUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CommissionsUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    approval_mode?: NullableEnumApprovalModeTypeFieldUpdateOperationsInput | $Enums.ApprovalModeType | null
    review_on?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type CustomersUpdateWithoutAffiliatesInput = {
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutCustomersNestedInput
    order_items?: OrderItemsUpdateManyWithoutCustomersNestedInput
    orders?: OrdersUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    order_items?: OrderItemsUncheckedUpdateManyWithoutCustomersNestedInput
    orders?: OrdersUncheckedUpdateManyWithoutCustomersNestedInput
  }

  export type CustomersUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    shopify_customer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    contact_type?: EnumContactTypeFieldUpdateOperationsInput | $Enums.ContactType
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    customer_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsUpdateWithoutAffiliatesInput = {
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    customers?: CustomersUpdateOneRequiredWithoutOrder_itemsNestedInput
    orders?: OrdersUpdateOneRequiredWithoutOrder_itemsNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemsUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrderItemsUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: IntFieldUpdateOperationsInput | number
    item_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_id?: BigIntFieldUpdateOperationsInput | bigint | number
    variant_id?: BigIntFieldUpdateOperationsInput | bigint | number
    product_title?: StringFieldUpdateOperationsInput | string
    variant_title?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    shop_item_currency_code?: StringFieldUpdateOperationsInput | string
    shop_item_amount?: FloatFieldUpdateOperationsInput | number
    customer_item_currency_code?: StringFieldUpdateOperationsInput | string
    customer_item_amount?: FloatFieldUpdateOperationsInput | number
    item_details?: JsonNullValueInput | InputJsonValue
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type OrdersUpdateWithoutAffiliatesInput = {
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    commissions?: CommissionsUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUpdateManyWithoutOrdersNestedInput
    customers?: CustomersUpdateOneRequiredWithoutOrdersNestedInput
    programs?: ProgramsUpdateOneWithoutOrdersNestedInput
    stores?: StoresUpdateOneRequiredWithoutOrdersNestedInput
    activity_log?: ActivityLogUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    commissions?: CommissionsUncheckedUpdateOneWithoutOrdersNestedInput
    order_items?: OrderItemsUncheckedUpdateManyWithoutOrdersNestedInput
    activity_log?: ActivityLogUncheckedUpdateManyWithoutOrdersNestedInput
  }

  export type OrdersUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    customer_id?: IntFieldUpdateOperationsInput | number
    order_id?: BigIntFieldUpdateOperationsInput | bigint | number
    shopify_order_number?: IntFieldUpdateOperationsInput | number
    shop_order_currency_code?: StringFieldUpdateOperationsInput | string
    shop_order_amount?: FloatFieldUpdateOperationsInput | number
    customer_order_currency_code?: StringFieldUpdateOperationsInput | string
    customer_order_amount?: FloatFieldUpdateOperationsInput | number
    financial_status?: StringFieldUpdateOperationsInput | string
    order_details?: JsonNullValueInput | InputJsonValue
    attribute_type?: EnumOrderAttributeTypeFieldUpdateOperationsInput | $Enums.OrderAttributeType
    status?: EnumOrderStatusTypeFieldUpdateOperationsInput | $Enums.OrderStatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PayoutsUpdateWithoutAffiliatesInput = {
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    jobs?: JobsUpdateOneRequiredWithoutPayoutsNestedInput
    stores?: StoresUpdateOneRequiredWithoutPayoutsNestedInput
    activity_log?: ActivityLogUpdateManyWithoutPayoutsNestedInput
  }

  export type PayoutsUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    job_id?: IntFieldUpdateOperationsInput | number
    activity_log?: ActivityLogUncheckedUpdateManyWithoutPayoutsNestedInput
  }

  export type PayoutsUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    transaction_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    notes?: StringFieldUpdateOperationsInput | string
    payment_method?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    payment_details?: JsonNullValueInput | InputJsonValue
    status?: EnumStatusTypeFieldUpdateOperationsInput | $Enums.StatusType
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    job_id?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionsUpdateWithoutAffiliatesInput = {
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionsUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type TransactionsUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    reference_type?: EnumTransactionReferenceTypeFieldUpdateOperationsInput | $Enums.TransactionReferenceType
    reference_id?: StringFieldUpdateOperationsInput | string
    currency_code?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    is_reverted?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    updated_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogUpdateWithoutAffiliatesInput = {
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
    stores?: StoresUpdateOneRequiredWithoutActivity_logNestedInput
    programs?: ProgramsUpdateOneWithoutActivity_logNestedInput
    orders?: OrdersUpdateOneWithoutActivity_logNestedInput
    payouts?: PayoutsUpdateOneWithoutActivity_logNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type ActivityLogUncheckedUpdateManyWithoutAffiliatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    store_id?: IntFieldUpdateOperationsInput | number
    program_id?: NullableIntFieldUpdateOperationsInput | number | null
    order_id?: NullableIntFieldUpdateOperationsInput | number | null
    payout_id?: NullableIntFieldUpdateOperationsInput | number | null
    entity_type?: EnumActivityEntityTypeFieldUpdateOperationsInput | $Enums.ActivityEntityType
    message?: StringFieldUpdateOperationsInput | string
    created_at?: BigIntFieldUpdateOperationsInput | bigint | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use StoresCountOutputTypeDefaultArgs instead
     */
    export type StoresCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoresCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MembersCountOutputTypeDefaultArgs instead
     */
    export type MembersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MembersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramsCountOutputTypeDefaultArgs instead
     */
    export type ProgramsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdersCountOutputTypeDefaultArgs instead
     */
    export type OrdersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayoutsCountOutputTypeDefaultArgs instead
     */
    export type PayoutsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayoutsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BonusCountOutputTypeDefaultArgs instead
     */
    export type BonusCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BonusCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GiftsCountOutputTypeDefaultArgs instead
     */
    export type GiftsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GiftsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomersCountOutputTypeDefaultArgs instead
     */
    export type CustomersCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomersCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliatesCountOutputTypeDefaultArgs instead
     */
    export type AffiliatesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliatesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoresDefaultArgs instead
     */
    export type StoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoresDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MembersDefaultArgs instead
     */
    export type MembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MembersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramsDefaultArgs instead
     */
    export type ProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TiersDefaultArgs instead
     */
    export type TiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TiersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDiscountsDefaultArgs instead
     */
    export type CustomerDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDiscountsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrdersDefaultArgs instead
     */
    export type OrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrdersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemsDefaultArgs instead
     */
    export type OrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommissionsDefaultArgs instead
     */
    export type CommissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommissionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayoutsDefaultArgs instead
     */
    export type PayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayoutsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BonusDefaultArgs instead
     */
    export type BonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BonusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GiftsDefaultArgs instead
     */
    export type GiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GiftsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionsDefaultArgs instead
     */
    export type TransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingsDefaultArgs instead
     */
    export type SettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobsDefaultArgs instead
     */
    export type JobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomersDefaultArgs instead
     */
    export type CustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliatesDefaultArgs instead
     */
    export type AffiliatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliatesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateProgramsDefaultArgs instead
     */
    export type AffiliateProgramsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateProgramsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateProgramHistoryDefaultArgs instead
     */
    export type AffiliateProgramHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateProgramHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateDiscountsDefaultArgs instead
     */
    export type AffiliateDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateDiscountsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateGiftsDefaultArgs instead
     */
    export type AffiliateGiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateGiftsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AffiliateBonusDefaultArgs instead
     */
    export type AffiliateBonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AffiliateBonusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramBonusDefaultArgs instead
     */
    export type ProgramBonusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramBonusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OtpDefaultArgs instead
     */
    export type OtpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OtpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationsDefaultArgs instead
     */
    export type NotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityLogDefaultArgs instead
     */
    export type ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MessageHistoryDefaultArgs instead
     */
    export type MessageHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MessageHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentGatewayDefaultArgs instead
     */
    export type PaymentGatewayArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentGatewayDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppSubscriptionDefaultArgs instead
     */
    export type AppSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppSubscriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IntegrationsDefaultArgs instead
     */
    export type IntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IntegrationsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}